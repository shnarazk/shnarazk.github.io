<!doctype html><html style="has-navbar-fixed-top has-navbar-fixed-bottom" lang=ja><head><meta charset=utf-8><meta viewport="width=device-width, initial-scale=1"><link href="/favicon.ico?refresh=1" rel=icon type=image/x-icon><link href=https://shnarazk.github.io/atom.xml rel=alternate title=RSS type=application/atom+xml><link href="https://fonts.googleapis.com/css?family=Roboto+Mono&display=swap" rel=stylesheet><link href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.8.2/css/all.min.css rel=stylesheet><link href=https://cdn.jsdelivr.net/npm/bulma@0.9.3/css/bulma.min.css rel=stylesheet><link href=/style.css rel=stylesheet><link crossorigin href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X rel=stylesheet><script crossorigin defer integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js></script><script crossorigin defer integrity=sha384-LJ2FmexL77rmGm6SIpxq7y+XA6bkLzGZEgCywzKOZG/ws4va9fUVu2neMjvc3zdv src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/mathtex-script-type.min.js></script><script onload="renderMathInElement(document.body, {
				delimiters: [
					{left: '$$', right: '$$', display: true},
					{left: '$', right: '$', display: false},
					{left: '\\(', right: '\\)', display: false},
					{left: '\\[', right: '\\]', display: true}
				]
			});" crossorigin defer integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js></script><script>document.addEventListener('DOMContentLoaded',()=>{const a=Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'),0);if(a.length>0){a.forEach(b=>{b.addEventListener('click',()=>{const c=b.dataset.target;const d=document.getElementById(c);b.classList.toggle('is-active');d.classList.toggle('is-active')})})}})</script><title>Just a note</title><body><nav aria-label="main navigation" class="navbar is-fixed-top is-light" role=navigation><div class=navbar-brand><div class=navbar-item> <i class="fas fa-book-open has-text-info"></i> <a class=title href=/>RustのClone on Writeについて</a></div><a aria-expanded=false aria-label=menu class=navbar-burger data-target=navigation-bar role=button> <span aria-hidden=true></span> <span aria-hidden=true></span> <span aria-hidden=true></span> </a></div><div class=navbar-menu id=navigation-bar><div class=navbar-end><div class="navbar-item has-dropdown" id=navigation-dropdown><a onclick="document.getElementById('navigation-dropdown').classList.toggle('is-active')" class=navbar-link></a><div class="navbar-dropdown is-right is-size-5"><a class=navbar-item href=/tags> <i class="fas fa-tags"></i> Tags </a><a class=navbar-item href=/about> <i class="fas fa-question-circle"></i> About </a><a class=navbar-item href=/atom.xml> <i class="fas fa-rss-square"></i>  RSS </a></div></div></div></div></nav><div style=padding-top:3rem><div class=article-banner><img src=/2020/2020-08-15_banner.jpg></div><div class=article-container><h1 class="subtitle has-text-info has-text-weight-semibold">std::borrow::cow</h1><p>自転車本では紹介されてないけれど、Rustならでは必要とされる面白い型、Copy on Writeではなくて、Clone on Writeを意味する<a href=https://doc.rust-lang.org/std/borrow/enum.Cow.html><code>std::borrow::Cow</code></a> の紹介です。<h2 id=前提知識：str_と_Stringの違い>前提知識：<code>str</code> と <code>String</code>の違い</h2><ul><li><code>str</code> -- （固定長の）UTF-8文字のスライス<li><code>&str</code> -- UTF-8文字のスライスへのポインタ<li><code>String</code> -- ヒープ上に置かれた、追加を含めた変更ができる文字列</ul><h2 id=前提知識：文字列定数とその参照>前提知識：文字列定数とその参照</h2><h4 id=ローカル変数>ローカル変数</h4><p>まず、以下のように関数内のローカルデータとして確保された文字列定数を参照する変数の型を確認しておきます。<pre class=language-rust data-lang=rust style=background:#fff;color:#323232><code class=language-rust data-lang=rust><span style=font-style:italic;color:#969896>/// コンパイルできる
</span><span style=font-weight:700;color:#a71d5d>fn </span><span style=font-weight:700;color:#795da3>f</span><span>() {
</span><span>  </span><span style=font-weight:700;color:#a71d5d>let</span><span> s </span><span style=font-weight:700;color:#a71d5d>= </span><span style=color:#183691>"a fixed string"</span><span>;
</span><span>  </span><span style=font-weight:700;color:#a71d5d>...
</span></code></pre><p>これは <code>&str</code> です。<pre class=language-rust data-lang=rust style=background:#fff;color:#323232><code class=language-rust data-lang=rust><span style=font-style:italic;color:#969896>/// コンパイルできる
</span><span style=font-weight:700;color:#a71d5d>fn </span><span style=font-weight:700;color:#795da3>f</span><span>() {
</span><span>  </span><span style=font-weight:700;color:#a71d5d>let</span><span> s: </span><span style=font-weight:700;color:#a71d5d>&str = </span><span style=color:#183691>"a fixed string"</span><span>;
</span><span>  </span><span style=font-weight:700;color:#a71d5d>...
</span></code></pre><ul><li><code>"a fixed string"</code>はローカルなデータなので（Boxも使ってないし）ヒープに置く必要はありません。<li>変数<code>s</code>はその確保された領域を指すように型付けられます。<li><code>str</code>は通常Rustのプログラムには出てきません。</ul><p>ちなみに<code>s</code>がグローバル変数<code>S</code>になるとどうなるでしょう。<pre class=language-rust data-lang=rust style=background:#fff;color:#323232><code class=language-rust data-lang=rust><span style=font-style:italic;color:#969896>/// 設計中
</span><span style=font-weight:700;color:#a71d5d>const</span><span> S: </span><span style=font-weight:700;color:#a71d5d>??? = </span><span style=color:#183691>"a fixed string"</span><span>;
</span></code></pre><p>グローバル変数も他の言語同様にヒープではなくOSで言うところのデータ領域に置かれるのでやはり<code>str</code>であり、 その領域を指すので変数<code>S</code> は<code>&str</code>型になります。<pre class=language-rust data-lang=rust style=background:#fff;color:#323232><code class=language-rust data-lang=rust><span style=font-style:italic;color:#969896>/// コンパイルできる
</span><span style=font-weight:700;color:#a71d5d>const</span><span> S: </span><span style=font-weight:700;color:#a71d5d>&str = </span><span style=color:#183691>"a fixed string"</span><span>;
</span></code></pre><h2 id=前提知識：strとString間の変換>前提知識：<code>str</code>と<code>String</code>間の変換</h2><h3 id=&strからStringへ><code>&str</code>から<code>String</code>へ</h3><p><code>&str</code>型の変数があればその指している対象から<code>to_string</code>メソッドを使って<code>String</code>を作ることができます。<pre class=language-rust data-lang=rust style=background:#fff;color:#323232><code class=language-rust data-lang=rust><span style=font-style:italic;color:#969896>/// コンパイルできる
</span><span style=font-weight:700;color:#a71d5d>fn </span><span style=font-weight:700;color:#795da3>f</span><span>() {
</span><span>  </span><span style=font-weight:700;color:#a71d5d>let</span><span> s: </span><span style=font-weight:700;color:#a71d5d>&str = </span><span style=color:#183691>"A fixed string" 
</span><span>  </span><span style=font-weight:700;color:#a71d5d>let</span><span> t </span><span style=font-weight:700;color:#a71d5d>=</span><span> s.</span><span style=color:#62a35c>to_string</span><span>();     </span><span style=font-style:italic;color:#969896>// ヒープ操作を必要とする
</span><span>  </span><span style=font-weight:700;color:#a71d5d>...
</span></code></pre><p>この時<code>t</code>の実体はヒープ上に置かれたfat pointerです。固定長なのでメモリを大きく消費するわけではありませんが、実体へのポインタを含む構造体をヒープ上に構成する必要があります。<h3 id=Stringから&strへ><code>String</code>から<code>&str</code>へ</h3><p>逆の操作は<code>as_str()</code>です。この操作は<code>String</code>を構成するfat pointerを流用すればいいので極めて軽量です。 これは<code>&srt</code>から<code>String</code>への変換が<code>to_*</code>系なのに対し、<code>String</code>から<code>&str</code>への変換が<code>as_*</code>系の<a href=https://rust-lang.github.io/api-guidelines/naming.html#ad-hoc-conversions-follow-as_-to_-into_-conventions-c-conv>命名</a>になっていることからもわかります。<pre class=language-rust data-lang=rust style=background:#fff;color:#323232><code class=language-rust data-lang=rust><span style=font-style:italic;color:#969896>/// コンパイルできる
</span><span style=font-weight:700;color:#a71d5d>fn </span><span style=font-weight:700;color:#795da3>f</span><span>() {
</span><span>  </span><span style=font-weight:700;color:#a71d5d>let</span><span> s: </span><span style=color:#0086b3>String </span><span style=font-weight:700;color:#a71d5d>= </span><span style=color:#183691>"A fixed string"</span><span>.</span><span style=color:#62a35c>to_string</span><span>();
</span><span>  </span><span style=font-weight:700;color:#a71d5d>let</span><span> t: </span><span style=font-weight:700;color:#a71d5d>&str =</span><span> s.</span><span style=color:#62a35c>as_str</span><span>();    </span><span style=font-style:italic;color:#969896>// 軽量な操作
</span><span>  </span><span style=font-weight:700;color:#a71d5d>...
</span></code></pre><p>ここまでが前提知識でした。<h1 id=問題となるシナリオ:_&str_と_String_の混在>問題となるシナリオ: <code>&str</code> と <code>String</code> の混在</h1><p>さて、以下のような構造体<code>S</code>に対してその文字列表現を返す<code>rep()</code>メソッドを定義するとします。<pre class=language-rust data-lang=rust style=background:#fff;color:#323232><code class=language-rust data-lang=rust><span style=font-weight:700;color:#a71d5d>struct </span><span>S {
</span><span>  index: </span><span style=font-weight:700;color:#a71d5d>usize</span><span>,
</span><span>  vec: </span><span style=color:#0086b3>Vec</span><span><</span><span style=font-weight:700;color:#a71d5d>usize</span><span>>,
</span><span>}
</span></code></pre><p>ただし、<ul><li>その構造体が持っているフィールド<code>index</code>が0の時は固定のメッセージを返す。<li>そうでなければ内部データの値がわかる文字列にしたい。</ul><p>とします。<pre class=language-rust data-lang=rust style=background:#fff;color:#323232><code class=language-rust data-lang=rust><span style=font-style:italic;color:#969896>/// 設計中
</span><span style=font-weight:700;color:#a71d5d>impl </span><span>S {
</span><span>  </span><span style=font-weight:700;color:#a71d5d>fn </span><span style=font-weight:700;color:#795da3>rep</span><span>(</span><span style=font-weight:700;color:#a71d5d>&</span><span>self) -> </span><span style=font-weight:700;color:#a71d5d>??? </span><span>{
</span><span>     </span><span style=font-weight:700;color:#a71d5d>if </span><span>self.index </span><span style=font-weight:700;color:#a71d5d>== </span><span style=color:#0086b3>0 </span><span>{
</span><span>         </span><span style=font-weight:700;color:#a71d5d>...
</span><span>     } </span><span style=font-weight:700;color:#a71d5d>else </span><span>{
</span><span>         </span><span style=font-weight:700;color:#a71d5d>...
</span><span>     }
</span><span>  }
</span><span>}
</span></code></pre><h3 id="Case_1:_index_==_0_のオブジェクトの場合">Case 1: index == 0 のオブジェクトの場合</h3><p>この場合、<code>rep()</code>内部で固定のメッセージを保持するローカル変数<code>mes</code>の値をそのまま返すことにします。 <code>mes</code>の型は <code>&str</code> であることから<code>rep()</code>の返値型も<code>&str</code>になります。<pre class=language-rust data-lang=rust style=background:#fff;color:#323232><code class=language-rust data-lang=rust><span style=font-style:italic;color:#969896>/// コンパイルできるはず
</span><span style=font-weight:700;color:#a71d5d>impl </span><span>S {
</span><span>  </span><span style=font-weight:700;color:#a71d5d>fn </span><span style=font-weight:700;color:#795da3>rep</span><span>(</span><span style=font-weight:700;color:#a71d5d>&</span><span>self) -> </span><span style=font-weight:700;color:#a71d5d>&str </span><span>{
</span><span>     </span><span style=font-weight:700;color:#a71d5d>if </span><span>self.index </span><span style=font-weight:700;color:#a71d5d>== </span><span style=color:#0086b3>0 </span><span>{
</span><span>         </span><span style=font-weight:700;color:#a71d5d>let</span><span> mes: </span><span style=font-weight:700;color:#a71d5d>&str = </span><span style=color:#183691>"null object"</span><span>;
</span><span>         mes
</span><span>     } </span><span style=font-weight:700;color:#a71d5d>else </span><span>{
</span><span>         </span><span style=font-weight:700;color:#a71d5d>...
</span><span>     }
</span><span>  }
</span><span>}
</span></code></pre><h3 id=Case_2:_それ以外>Case 2: それ以外</h3><p>フィールド<code>vec</code>の値を埋め込んだ文字列を作るため<code>format!</code>を使うことにしました。<p><code>format!</code>の返す型は<code>String</code>なので<code>rep()</code>の返値型も<code>String</code>になります。<pre class=language-rust data-lang=rust style=background:#fff;color:#323232><code class=language-rust data-lang=rust><span style=font-style:italic;color:#969896>/// コンパイルできない
</span><span style=font-weight:700;color:#a71d5d>impl </span><span>S {
</span><span>  </span><span style=font-weight:700;color:#a71d5d>fn </span><span style=font-weight:700;color:#795da3>rep</span><span>(</span><span style=font-weight:700;color:#a71d5d>&</span><span>self) -> String {
</span><span>
</span><span>
</span><span>         </span><span style=font-weight:700;color:#a71d5d>...
</span><span>     } </span><span style=font-weight:700;color:#a71d5d>else </span><span>{
</span><span>         format!(</span><span style=color:#183691>"S</span><span style=color:#0086b3>{{{:?}}}</span><span style=color:#183691>"</span><span>, self.vec)
</span><span>     }
</span><span>  }
</span><span>}
</span></code></pre><p>ここで型が一致しない問題に直面します。<h3 id=案1:_&strへの統一>案1: <code>&str</code>への統一</h3><p>既に見たようにどちらの方向にも変換できるのでまず<code>&str</code>へ統一することを考えてみます。<pre class=language-rust data-lang=rust style=background:#fff;color:#323232><code class=language-rust data-lang=rust><span>  </span><span style=font-weight:700;color:#a71d5d>fn </span><span style=font-weight:700;color:#795da3>rep</span><span>(</span><span style=font-weight:700;color:#a71d5d>&</span><span>self) -> </span><span style=font-weight:700;color:#a71d5d>&str </span><span>{
</span><span>     </span><span style=font-weight:700;color:#a71d5d>if </span><span>self.index </span><span style=font-weight:700;color:#a71d5d>== </span><span style=color:#0086b3>0 </span><span>{
</span><span>         </span><span style=font-weight:700;color:#a71d5d>let</span><span> mes: </span><span style=font-weight:700;color:#a71d5d>&str = </span><span style=color:#183691>"null object"</span><span>;
</span><span>         mes
</span><span>     } </span><span style=font-weight:700;color:#a71d5d>else </span><span>{
</span><span>         format!(</span><span style=color:#183691>"S</span><span style=color:#0086b3>{{{:?}}}</span><span style=color:#183691>"</span><span>, self.vec).</span><span style=color:#62a35c>as_str</span><span>()
</span><span>     }
</span><span>  }
</span><span>}
</span></code></pre><p>これはライフタイム制約を満足しないエラーになります。<pre class=language-txt data-lang=txt style=background:#fff;color:#323232><code class=language-txt data-lang=txt><span>error[E0515]: cannot return value referencing temporary value
</span><span>   |
</span><span>   |          format!("S{{{:?}}}", self.vec).as_str()                                                        
</span><span>   |          ------------------------------^^^^^^^^^
</span><span>   |          |
</span><span>   |          returns a value referencing data owned by the current function
</span><span>   |          temporary value created here
</span></code></pre><p>以下のようにローカル変数<code>res</code>にバインドしても、<pre class=language-rust data-lang=rust style=background:#fff;color:#323232><code class=language-rust data-lang=rust><span>  </span><span style=font-weight:700;color:#a71d5d>fn </span><span style=font-weight:700;color:#795da3>rep</span><span>(</span><span style=font-weight:700;color:#a71d5d>&</span><span>self) -> </span><span style=font-weight:700;color:#a71d5d>&str </span><span>{
</span><span>     </span><span style=font-weight:700;color:#a71d5d>if </span><span>self.index </span><span style=font-weight:700;color:#a71d5d>== </span><span style=color:#0086b3>0 </span><span>{
</span><span>         </span><span style=font-weight:700;color:#a71d5d>let</span><span> mes: </span><span style=font-weight:700;color:#a71d5d>&str = </span><span style=color:#183691>"null object"</span><span>;
</span><span>         mes
</span><span>     } </span><span style=font-weight:700;color:#a71d5d>else </span><span>{
</span><span>         </span><span style=font-weight:700;color:#a71d5d>let</span><span> res </span><span style=font-weight:700;color:#a71d5d>= </span><span>format!(</span><span style=color:#183691>"S</span><span style=color:#0086b3>{{{:?}}}</span><span style=color:#183691>"</span><span>, self.vec);
</span><span>         res.</span><span style=color:#62a35c>as_str</span><span>()
</span><span>     }
</span><span>  }
</span><span>}
</span></code></pre><p>ライフタイムが短すぎることには変わりはないので、エラーになります（<code>res</code>はヒープに置かれても所有者である<code>rep</code>からexitする時点で回収されてしまう）<pre class=language-txt data-lang=txt style=background:#fff;color:#323232><code class=language-txt data-lang=txt><span>error[E0515]: cannot return value referencing local variable `res`
</span><span>   |
</span><span>   |          res.as_str()                                                        
</span><span>   |          ---^^^^^^^^^
</span><span>   |          |
</span><span>   |          returns a value referencing data owned by the current function
</span><span>   |          `res` is borrowed here
</span></code></pre><p>なので、<code>format!</code>で作った<code>String</code>実体を呼び出し側に渡さないといけません。<h3 id=案2:_Stringへの統一>案2: <code>String</code>への統一</h3><p>ということで<code>&str</code>型の<code>mes</code>を返しているパスの型を変えることにします。関数の返値型を変えてコンパイルすると以下のようなエラーメッセージが表示されます。<pre class=language-txt data-lang=txt style=background:#fff;color:#323232><code class=language-txt data-lang=txt><span>error[E0308]: mismatched types
</span><span>  --> src/main.rs:13:10
</span><span>   |
</span><span>   |   fn rep(&self) -> String {                                                                               
</span><span>   |                    ------ expected `std::string::String` because of return type
</span><span>...
</span><span>   |          mes                                                                                           
</span><span>   |          ^^^^
</span><span>   |          |
</span><span>   |          expected struct `std::string::String`, found `&str`
</span><span>   |          help: try using a conversion method: `mes.to_string()`
</span><span>
</span></code></pre><p>ヘルプに従って修正すれば問題はなくなります。<pre class=language-rust data-lang=rust style=background:#fff;color:#323232><code class=language-rust data-lang=rust><span>  </span><span style=font-style:italic;color:#969896>/// コンパイルできる
</span><span>  </span><span style=font-weight:700;color:#a71d5d>fn </span><span style=font-weight:700;color:#795da3>rep</span><span>(</span><span style=font-weight:700;color:#a71d5d>&</span><span>self) -> String {
</span><span>     </span><span style=font-weight:700;color:#a71d5d>if </span><span>self.index </span><span style=font-weight:700;color:#a71d5d>== </span><span style=color:#0086b3>0 </span><span>{
</span><span>         </span><span style=font-weight:700;color:#a71d5d>let</span><span> mes: </span><span style=font-weight:700;color:#a71d5d>&str = </span><span style=color:#183691>"null object"</span><span>;
</span><span>         mes.</span><span style=color:#62a35c>to_string</span><span>()
</span><span>     } </span><span style=font-weight:700;color:#a71d5d>else </span><span>{
</span><span>         </span><span style=font-weight:700;color:#a71d5d>let</span><span> res </span><span style=font-weight:700;color:#a71d5d>= </span><span>format!(</span><span style=color:#183691>"S</span><span style=color:#0086b3>{{{:?}}}</span><span style=color:#183691>"</span><span>, self.vec);
</span><span>         res.</span><span style=color:#62a35c>as_str</span><span>()
</span><span>     }
</span><span>  }
</span><span>}
</span></code></pre><p>しかしこれは、必要とは思われないヒープでのオブジェクト生成をしているため、時間的にも空間的にも（できれば避けたい）コストをかけてしまっています。ゼロコストアブストラクションをうたうRustのプログラムとしては是非とも避けたいところです。<h3 id=案3:_型の包含>案3: 型の包含</h3><p>この問題を解決するには「借用」と「実体」のどちらも返せるような<code>enum</code>を用意するという手が使えます。<ul><li>借用でいいならなら借用を包む<li>実体が必要なら、実体を包む</ul><pre class=language-rust data-lang=rust style=background:#fff;color:#323232><code class=language-rust data-lang=rust><span style=font-style:italic;color:#969896>/// 設計中（ライフタイム指定がまだついていない）
</span><span style=font-weight:700;color:#a71d5d>enum </span><span>WrapStr {
</span><span>  </span><span style=color:#62a35c>from_str</span><span>(</span><span style=font-weight:700;color:#a71d5d>&str</span><span>),
</span><span>  </span><span style=color:#62a35c>from_format</span><span>(</span><span style=color:#0086b3>String</span><span>),
</span><span>}
</span><span>
</span><span style=font-weight:700;color:#a71d5d>impl </span><span>S {
</span><span>  </span><span style=font-weight:700;color:#a71d5d>fn </span><span style=font-weight:700;color:#795da3>rep</span><span>(</span><span style=font-weight:700;color:#a71d5d>&</span><span>self) -> WrapStr {
</span><span>     </span><span style=font-weight:700;color:#a71d5d>if </span><span>self.index </span><span style=font-weight:700;color:#a71d5d>== </span><span style=color:#0086b3>0 </span><span>{
</span><span>         </span><span style=font-weight:700;color:#a71d5d>let</span><span> mes: </span><span style=font-weight:700;color:#a71d5d>&str = </span><span style=color:#183691>"null object"</span><span>;
</span><span>         WrapStr::from_str(mes)
</span><span>     } </span><span style=font-weight:700;color:#a71d5d>else </span><span>{
</span><span>         WraStr::from_format(format!(</span><span style=color:#183691>"S</span><span style=color:#0086b3>{{{:?}}}</span><span style=color:#183691>"</span><span>, self.vec))
</span><span>     }
</span><span>  }
</span><span>}
</span></code></pre><p>こうすれば型の問題は解決するし、見かけ上構造体で包むコストは（おそらく）コンパイラの最適化中に何もしないコードに変換されることが期待できます。ということで<code>WrapStr</code>を追加定義すれば問題解決します。ポインタを含むのでライフタイム制約が必要かな。。。<h1 id=Cow>Cow</h1><p>しかし自分で定義するよりも、このような状況のための型がすでに標準ライブラリに用意されているのでそれを使いましょう。 それがClone on Write, <code>Cow</code>型です。これは以下のように定義されています。 https://doc.rust-lang.org/std/borrow/enum.Cow.html<pre class=language-rust data-lang=rust style=background:#fff;color:#323232><code class=language-rust data-lang=rust><span style=font-style:italic;color:#969896>/// https://doc.rust-lang.org/std/borrow/enum.Cow.html
</span><span style=font-weight:700;color:#a71d5d>pub enum </span><span>Cow<'a, B> 
</span><span>where
</span><span>    B: 'a + ToOwned + ?Sized, 
</span><span> {
</span><span>    Borrowed(</span><span style=font-weight:700;color:#a71d5d>&'a</span><span> B),
</span><span>    Owned(</span><span style=font-weight:700;color:#a71d5d><</span><span>B </span><span style=font-weight:700;color:#a71d5d>as </span><span style=color:#0086b3>ToOwned</span><span style=font-weight:700;color:#a71d5d>></span><span>::Owned),
</span><span>}
</span></code></pre><p><code>ToOwned</code>は借用したデータから、所有権を持つ実体を構成することができるというトレイトです。 文字列関連では以下のようになっています。 https://doc.rust-lang.org/std/borrow/trait.ToOwned.html<pre style=background:#fff;color:#323232><code><span>/// https://doc.rust-lang.org/std/borrow/trait.ToOwned.html
</span><span>impl ToOwned for str
</span><span>  type Owned = String
</span><span>  
</span><span>  /// Examples
</span><span>  let s: &str = "a";
</span><span>  let ss: String = s.to_owned();
</span></code></pre><p>つまり<code>str</code>から<code>String</code>が作れると。これを見ながら<code>Cow</code>の定義の<code>B</code>を<code>str</code>に変換してやると以下のようになります。<pre style=background:#fff;color:#323232><code><span>pub enum Cow<'a, str> 
</span><span>where
</span><span>    str: 'a + ToOwned + ?Sized,  // 条件OK
</span><span> {
</span><span>    Borrowed(&'a str),
</span><span>    Owned(String),
</span><span>}
</span></code></pre><p>ということで、借用(<code>&str</code>)は<code>Cow::Borrowed</code>で実体(<code>String</code>)は<code>Cow::Owned</code>で包んでやればいいことがわかりました。<p>最終的なプログラムはこうなります。<pre class=language-rust data-lang=rust style=background:#fff;color:#323232><code class=language-rust data-lang=rust><span style=font-weight:700;color:#a71d5d>use </span><span>std::borrow::Cow;
</span><span>
</span><span style=font-weight:700;color:#a71d5d>impl </span><span>S {
</span><span>  </span><span style=font-style:italic;color:#969896>/// コンパイルできる
</span><span>  </span><span style=font-weight:700;color:#a71d5d>fn </span><span style=font-weight:700;color:#795da3>rep</span><span>(</span><span style=font-weight:700;color:#a71d5d>&</span><span>self) -> Cow<'</span><span style=font-weight:700;color:#a71d5d>_</span><span>, </span><span style=font-weight:700;color:#a71d5d>str</span><span>> {
</span><span>    </span><span style=font-weight:700;color:#a71d5d>if </span><span>self.index </span><span style=font-weight:700;color:#a71d5d>== </span><span style=color:#0086b3>0 </span><span>{
</span><span>      Cow::Borrowed(</span><span style=color:#183691>"Null S"</span><span>)                  </span><span style=font-style:italic;color:#969896>// 場所は確保済み => 借用したい
</span><span>    } </span><span style=font-weight:700;color:#a71d5d>else </span><span>{
</span><span>      Cow::Owned(format!(</span><span style=color:#183691>"S[</span><span style=color:#0086b3>{:?}</span><span style=color:#183691>]"</span><span>, self.vec)) </span><span style=font-style:italic;color:#969896>// 借用ではダメ =>実体を渡したい
</span><span>    }
</span><span>  }
</span><span>}
</span></code></pre><p>使う側では一回derefしてやれば借用であったか実体であったかを気にする必要はありません。<pre class=language-rust data-lang=rust style=background:#fff;color:#323232><code class=language-rust data-lang=rust><span>   println!(</span><span style=color:#183691>"</span><span style=color:#0086b3>{}</span><span style=color:#183691>"</span><span>, </span><span style=font-weight:700;color:#a71d5d>*</span><span>s.</span><span style=color:#62a35c>rep</span><span>());
</span></code></pre><p>ちなみにderefしたものが何型になっているかというと、<pre class=language-rust data-lang=rust style=background:#fff;color:#323232><code class=language-rust data-lang=rust><span>  </span><span style=font-style:italic;color:#969896>// コンパイルできる
</span><span>  </span><span style=font-weight:700;color:#a71d5d>let</span><span> temp: </span><span style=font-weight:700;color:#a71d5d>&str = &*</span><span>s.</span><span style=color:#62a35c>rep</span><span>();
</span></code></pre><p>だそうです。文字列のスライスみたいですね。<h3 id=コストについて>コストについて</h3><p>derefのコストは以下に引用したようにポインタ辿りだけなので、「軽量」と言ってしまっていいでしょう。<p>https://doc.rust-lang.org/src/alloc/borrow.rs.html#320<pre style=background:#fff;color:#323232><code><span>/// https://doc.rust-lang.org/src/alloc/borrow.rs.html#320
</span><span>#[stable(feature = "rust1", since = "1.0.0")]
</span><span>impl&LTB: ?Sized + ToOwned> Deref for Cow<'_, B> {
</span><span>    type Target = B;
</span><span>
</span><span>    fn deref(&self) -> &B {
</span><span>        match *self {
</span><span>            Borrowed(borrowed) => borrowed,
</span><span>            Owned(ref owned) => owned.borrow(),
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>https://doc.rust-lang.org/src/core/borrow.rs.html#212<pre class=language-rust data-lang=rust style=background:#fff;color:#323232><code class=language-rust data-lang=rust><span style=font-style:italic;color:#969896>/// https://doc.rust-lang.org/src/core/borrow.rs.html#212
</span><span>#[stable(feature </span><span style=font-weight:700;color:#a71d5d>= </span><span style=color:#183691>"rust1"</span><span>, since </span><span style=font-weight:700;color:#a71d5d>= </span><span style=color:#183691>"1.0.0"</span><span>)]
</span><span style=font-weight:700;color:#a71d5d>impl</span><span>&LTT: </span><span style=background:#f5f5f5;font-weight:700;color:#b52a1d>?</span><span>Sized> Borrow&LTT> for T {
</span><span>    </span><span style=font-weight:700;color:#a71d5d>fn </span><span style=font-weight:700;color:#795da3>borrow</span><span>(</span><span style=font-weight:700;color:#a71d5d>&</span><span>self) -> </span><span style=font-weight:700;color:#a71d5d>&</span><span>T {
</span><span>        self
</span><span>    }
</span><span>}
</span></code></pre><p>https://doc.rust-lang.org/src/core/borrow.rs.html#226<pre class=language-rust data-lang=rust style=background:#fff;color:#323232><code class=language-rust data-lang=rust><span style=font-style:italic;color:#969896>/// https://doc.rust-lang.org/src/core/borrow.rs.html#226
</span><span>#[stable(feature </span><span style=font-weight:700;color:#a71d5d>= </span><span style=color:#183691>"rust1"</span><span>, since </span><span style=font-weight:700;color:#a71d5d>= </span><span style=color:#183691>"1.0.0"</span><span>)]
</span><span style=font-weight:700;color:#a71d5d>impl</span><span>&LTT: </span><span style=background:#f5f5f5;font-weight:700;color:#b52a1d>?</span><span>Sized> Borrow&LTT> for </span><span style=font-weight:700;color:#a71d5d>&</span><span>T {
</span><span>    </span><span style=font-weight:700;color:#a71d5d>fn </span><span style=font-weight:700;color:#795da3>borrow</span><span>(</span><span style=font-weight:700;color:#a71d5d>&</span><span>self) -> </span><span style=font-weight:700;color:#a71d5d>&</span><span>T {
</span><span>        </span><span style=font-weight:700;color:#a71d5d>&**</span><span>self
</span><span>    }
</span><span>}
</span></code></pre><div class="date-footer is-size-7 is-family-code has-text-grey has-text-right" style=margin-top:2rem>Published at 2020-08-15</div></div><nav class="navbar is-fixed-bottom" aria-label=navigation id=bottombar><div class=navbar-brand><div class=navbar-item><a class=tagword href=/tags/#rust>#Rust</a></div></div></nav><footer class="copyright is-size-6 has-text-info">Copyright 2019-2023 Narazaki Shuji.</footer>