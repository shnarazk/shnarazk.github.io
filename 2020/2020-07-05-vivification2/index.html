<!doctype html><html style="has-navbar-fixed-top has-navbar-fixed-bottom" lang=ja><head><meta charset=utf-8><meta viewport="width=device-width, initial-scale=1"><link href="/favicon.ico?refresh=1" rel=icon type=image/x-icon><link href=https://shnarazk.github.io/atom.xml rel=alternate title=RSS type=application/atom+xml><link href="https://fonts.googleapis.com/css?family=Roboto+Mono&display=swap" rel=stylesheet><link href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.8.2/css/all.min.css rel=stylesheet><link href=https://cdn.jsdelivr.net/npm/bulma@0.9.3/css/bulma.min.css rel=stylesheet><link href=/style.css rel=stylesheet><link crossorigin href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X rel=stylesheet><script crossorigin defer integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js></script><script crossorigin defer integrity=sha384-LJ2FmexL77rmGm6SIpxq7y+XA6bkLzGZEgCywzKOZG/ws4va9fUVu2neMjvc3zdv src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/mathtex-script-type.min.js></script><script onload="renderMathInElement(document.body, {
				delimiters: [
					{left: '$$', right: '$$', display: true},
					{left: '$', right: '$', display: false},
					{left: '\\(', right: '\\)', display: false},
					{left: '\\[', right: '\\]', display: true}
				]
			});" crossorigin defer integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js></script><script>document.addEventListener('DOMContentLoaded',()=>{const a=Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'),0);if(a.length>0){a.forEach(b=>{b.addEventListener('click',()=>{const c=b.dataset.target;const d=document.getElementById(c);b.classList.toggle('is-active');d.classList.toggle('is-active')})})}})</script><title>Just a note</title><body><nav aria-label="main navigation" class="navbar is-fixed-top is-light" role=navigation><div class=navbar-brand><div class=navbar-item> <i class="fas fa-book-open has-text-info"></i> <a class=title href=/>Clause Vivification updated 2020</a></div><a aria-expanded=false aria-label=menu class=navbar-burger data-target=navigation-bar role=button> <span aria-hidden=true></span> <span aria-hidden=true></span> <span aria-hidden=true></span> </a></div><div class=navbar-menu id=navigation-bar><div class=navbar-end><div class="navbar-item has-dropdown" id=navigation-dropdown><a onclick="document.getElementById('navigation-dropdown').classList.toggle('is-active')" class=navbar-link></a><div class="navbar-dropdown is-right is-size-5"><a class=navbar-item href=/tags> <i class="fas fa-tags"></i> Tags </a><a class=navbar-item href=/about> <i class="fas fa-question-circle"></i> About </a><a class=navbar-item href=/atom.xml> <i class="fas fa-rss-square"></i>  RSS </a></div></div></div></div></nav><div style=padding-top:3rem><div class=article-banner><img src="https://images.unsplash.com/photo-1586508217007-6e8b3151a6f2?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1950&q=80"></div><div class=article-container><h1 class="subtitle has-text-info has-text-weight-semibold">vivification part 2</h1><p><strong>cover image: https://unsplash.com/photos/tYs9rjaT8Vc</strong><p>Vivification についての調査第2弾、2018年投稿2019年公開の論文をまとめてみた。<ul><li><p>Chu-Min Li <em>et al.</em>, "Clause vivification by unit propagation in CDCL SAT solvers,”<em>Artif. Intell.</em>, vol. 279, 2019.</p><li><p><a href=/2020/2020-08-19-splr-with-vivification/>part 2</a></p></ul><h3 id=Errata>Errata</h3><ul><li><strong>Algorithm 3</strong>のL17はforeachの内側<li><strong>Algorithm 4</strong>のLL.9-10はthen節の中</ul><h3 id=Outline>Outline</h3><p>Vivificationは魅力的な節削減手法のでSAT competitionに提出されるようなソルバに導入されたもの、その後改善が計算量に見合わないため、取り下げられることが続いてきた。 この論文はどのタイミングで、どの節を、どのリテラルからvivifyすればよいかについて論じている。 特に<a href=/2020/2020-06-20-vivification/>原論文</a>では'future work'としてのみ触れられていたin-processorとして使う場合の改善に重きを置いている。 なお、Cadicalはこの論文で提案された手法とは無関係。所与の節にもvivificationをするべきだという主張の傍証実験に使われただけ。ただし、Cadicalが使っているのは著者らの別の論文に基づくものなので、無関係とは言い過ぎかも。<p>結論は以下の通り。<ul><li>タイミング -- 節削減の後のリスタート<li>対象節 -- LBD順で対象集合の半分 <ul><li>与えられた節 -- LBDが20以下の学習節の導出に使われており、LBDが1になる、またはLBDが3回減少すれば再び対象に加える。それとは別に pre-processing phase で$10^8$リテラルまで処理する。<li>学習節 -- LBDが1になる、またはLBDが2回減少すれば再び対象に加える</ul><li>リテラル順 -- as is</ul><p>なお、以下のようにin-processor向けに <code>vivify</code> のアルゴリズムが変更されている。<p><img alt src=/img/2020/2020-07-05_vivi-algo3.jpg><ul><li>節へのリテラルの追加は$\vee$で、節集合および部分割り当てへの節または割り当ての追加は$\cup$で表されている。つまり節が拡大するのはL17のみ。(<strong>2020-08-21追記</strong>)<li><del>なんか怪しい。なぜ $\phi \cup \neg C'$ なのだ？ どうして$C$に含まれていたリテラルの否定を集めた節が$\text{vivified} C = C'$ なのだ</del> ここがミソ。<li>何にせよ最初に存在した節は17行目で必ず削除される。<li>17行目は一つ内側のループに含まれるはずですけど。<li>この関数は決定レベル0を想定していない。だから<code>conflictAnalysis</code>を呼び出している。もし決定レベル0を想定するなら、これは決定変数の否定からなる単位節を返す処理に帰着する。従ってL10は $C' \leftarrow {l_i}$と等価だか、そもそも$l_i$は割り当て済みだから何もしないのと同等。一方L13に関しては、その前のステップで決定による割り当てを行っている可能性があるのでレベル0が仮定できない。従って通常の矛盾解析を行い、<strong>学習節を追加する</strong>ことが必要である。</ul><h3 id=節$C$が冗長であることを言う。>節$C$が冗長であることを言う。</h3><p>数学的準備：<ul><li>$(\phi, \omega) \models \omega'$は節集合$\phi$と部分割当集合$\omega$から無矛盾な割り当て集合$\omega'$が導出されることを意味する。割当が空でも$\omega$を導出できるなら$\phi \models \omega$とも書く。<li>$(\phi, \omega)$が矛盾を起こしているなら$\bot$で矛盾を表し、$(\phi, \omega) \models \bot$と書くことにする。<li>節$C$が冗長とは式$\phi$と$\phi\setminus{C}$が論理的に等値であることを意味する。<li>一般に節$C$に含まれる全てのリテラルを否定した節を$\neg C$と書くと$\forall C: (C \cup \neg C) \models \bot$が成立する。<li>（⭐️）一般に節$C$に対して自身の部分節$C'$の否定節$\neg C'$を加えることで矛盾が生じる（$C \cup \neg C' \models \bot$）なら、節$C$は$C'$に包含される。節$C$はリテラル$l' \in C\setminus{C'}$に対して何の制約にもなっていない。</ul><ol><li>前提として$\phi \nvDash \bot$であるとする。<li>ある節Cの部分節$C'$の否定節を加えても矛盾を導出しないなら、それは節Cは$C\setminus{C'}$に包摂できることを意味している。<li>そのような部分節にリテラル$l' \in C$の否定を加えた節を追加すると矛盾が起きたとする。それは部分節または$l'$のどちらかが充足することが必要であることを意味している。これは$\phi$から導出された学習節である（$\phi$の論理的帰結）。<li>学習節$\neg \neg C' \cup {\neg \neg l'} = C' \cup l'$は節$C$の部分節である。なので（⭐️）より置き換えてよい。</ol><h3 id=余談>余談</h3><ul><li>COMiniSATPS, MapleCOMSPS, MapleCOMSPS_LRB は学習節の3層管理をしている。節削減対象はLOCALのみ。 <ul><li>CORE -- LBDが小さいもの<li>TIER2 --　LBDが中間のもの。長期間依存グラフに現れないと格下げ。<li>LOCAL -- それ以外</ul><li>COMiniSATPS, MapleCOMSPS, MapleCOMSPS_LRB はGulcose的なリスタートフェーズとLuby列に基づくリスタートフェーズを交互に使っている。これはStabilizationの先駆け？</ul><h3 id=2020-07-05_Splr_approach>2020-07-05 Splr approach</h3><pre class=language-rust data-lang=rust style=background:#fff;color:#323232><code class=language-rust data-lang=rust><span style=font-weight:700;color:#a71d5d>fn </span><span style=font-weight:700;color:#795da3>vivify</span><span>(asg: </span><span style=font-weight:700;color:#a71d5d>&mut</span><span> AssignStack, cdb: </span><span style=font-weight:700;color:#a71d5d>&mut</span><span> ClauseDB) {
</span><span>    'next_clause: </span><span style=font-weight:700;color:#a71d5d>for</span><span> ci </span><span style=font-weight:700;color:#a71d5d>in</span><span> clauses.</span><span style=color:#62a35c>iter</span><span>() {
</span><span>        </span><span style=font-weight:700;color:#a71d5d>let</span><span> c: </span><span style=font-weight:700;color:#a71d5d>&</span><span>Clause </span><span style=font-weight:700;color:#a71d5d>= &</span><span>cdb[ci];
</span><span>        </span><span style=font-weight:700;color:#a71d5d>if</span><span> c.</span><span style=color:#62a35c>is</span><span>(Flag::</span><span style=color:#0086b3>DEAD</span><span>) { </span><span style=font-weight:700;color:#a71d5d>continue</span><span>; }
</span><span>        </span><span style=font-weight:700;color:#a71d5d>let mut</span><span> copied: </span><span style=color:#0086b3>Vec</span><span>&LTLit> </span><span style=font-weight:700;color:#a71d5d>= </span><span style=color:#0086b3>Vec</span><span>::new();
</span><span>        </span><span style=font-weight:700;color:#a71d5d>let mut</span><span> vivified: </span><span style=color:#0086b3>Vec</span><span>&LTLit> </span><span style=font-weight:700;color:#a71d5d>= </span><span style=color:#0086b3>Vec</span><span>::new();
</span><span>        </span><span style=font-weight:700;color:#a71d5d>for</span><span> l </span><span style=font-weight:700;color:#a71d5d>in</span><span> c.lits.</span><span style=color:#62a35c>clone</span><span>().</span><span style=color:#62a35c>iter</span><span>() {
</span><span>            </span><span style=font-weight:700;color:#a71d5d>match</span><span> asg.</span><span style=color:#62a35c>assigned</span><span>(</span><span style=font-weight:700;color:#a71d5d>*</span><span>l) {
</span><span>                </span><span style=color:#0086b3>Some</span><span>(</span><span style=color:#0086b3>false</span><span>) </span><span style=font-weight:700;color:#a71d5d>=></span><span> copied.</span><span style=color:#62a35c>push</span><span>(</span><span style=font-weight:700;color:#a71d5d>!*</span><span>l),            </span><span style=font-style:italic;color:#969896>// Rule 1
</span><span>                </span><span style=color:#0086b3>Some</span><span>(</span><span style=color:#0086b3>true</span><span>) </span><span style=font-weight:700;color:#a71d5d>=> continue 'next_clause</span><span>,        </span><span style=font-style:italic;color:#969896>// Rule 2'
</span><span>                </span><span style=color:#0086b3>None </span><span style=font-weight:700;color:#a71d5d>=> </span><span>{
</span><span>                    </span><span style=font-weight:700;color:#a71d5d>let</span><span> cid: </span><span style=color:#0086b3>Option</span><span>&LTClauseId> </span><span style=font-weight:700;color:#a71d5d>= match</span><span> copied.</span><span style=color:#62a35c>len</span><span>() {
</span><span>                        </span><span style=color:#0086b3>0 </span><span style=font-weight:700;color:#a71d5d>=> </span><span style=color:#0086b3>None</span><span>,
</span><span>                        </span><span style=color:#0086b3>1 </span><span style=font-weight:700;color:#a71d5d>=> </span><span>{ asg.</span><span style=color:#62a35c>assign_by_decision</span><span>(copied[</span><span style=color:#0086b3>0</span><span>]); </span><span style=color:#0086b3>None </span><span>}
</span><span>                        </span><span style=font-weight:700;color:#a71d5d>_ => </span><span style=color:#0086b3>Some</span><span>(cdb.</span><span style=color:#62a35c>new_clause</span><span>(asg, </span><span style=font-weight:700;color:#a71d5d>&mut</span><span> copied)), </span><span style=font-style:italic;color:#969896>// L.12
</span><span>                    };
</span><span>                    asg.</span><span style=color:#62a35c>assign_by_decision</span><span>(</span><span style=font-weight:700;color:#a71d5d>!*</span><span>l);
</span><span>                    </span><span style=font-weight:700;color:#a71d5d>let</span><span> cc </span><span style=font-weight:700;color:#a71d5d>=</span><span> asg.</span><span style=color:#62a35c>propagate</span><span>(cdb);
</span><span>                    </span><span style=font-weight:700;color:#a71d5d>if</span><span> cc </span><span style=font-weight:700;color:#a71d5d>!= </span><span>ClauseId::default() {
</span><span>                        vivified </span><span style=font-weight:700;color:#a71d5d>=</span><span> asg.</span><span style=color:#62a35c>minimize</span><span>(cdb, </span><span style=font-weight:700;color:#a71d5d>&</span><span>v, </span><span style=font-weight:700;color:#a71d5d>&</span><span>cdb[cc].lits); </span><span style=font-style:italic;color:#969896>// Rule 3
</span><span>                    }
</span><span>                    </span><span style=font-weight:700;color:#a71d5d>if let </span><span style=color:#0086b3>Some</span><span>(cj) </span><span style=font-weight:700;color:#a71d5d>=</span><span> cid { cdb.</span><span style=color:#62a35c>remove_clause</span><span>(cj); }
</span><span>                    asg.</span><span style=color:#62a35c>cancel_until</span><span>(asg.root_level);
</span><span>                    </span><span style=font-weight:700;color:#a71d5d>if</span><span> cc </span><span style=font-weight:700;color:#a71d5d>!= </span><span>ClauseId::default() { </span><span style=font-weight:700;color:#a71d5d>break</span><span>; }
</span><span>                    copied.</span><span style=color:#62a35c>push</span><span>(</span><span style=font-weight:700;color:#a71d5d>!*</span><span>l);                       </span><span style=font-style:italic;color:#969896>// Rule 4
</span><span>                }
</span><span>            }
</span><span>        }
</span><span>        </span><span style=font-weight:700;color:#a71d5d>if</span><span> vivified.</span><span style=color:#62a35c>is_empty</span><span>() {
</span><span>            </span><span style=font-weight:700;color:#a71d5d>for</span><span> l </span><span style=font-weight:700;color:#a71d5d>in &mut</span><span> copied { </span><span style=font-weight:700;color:#a71d5d>*</span><span>l </span><span style=font-weight:700;color:#a71d5d>= !*</span><span>l; }
</span><span>            std::mem::swap(</span><span style=font-weight:700;color:#a71d5d>&mut</span><span> vivified, </span><span style=font-weight:700;color:#a71d5d>&mut</span><span> copied);
</span><span>        }
</span><span>        </span><span style=font-weight:700;color:#a71d5d>match</span><span> vivified.</span><span style=color:#62a35c>len</span><span>() {
</span><span>            </span><span style=color:#0086b3>0 </span><span style=font-weight:700;color:#a71d5d>=> break 'next_clause</span><span>,
</span><span>            </span><span style=color:#0086b3>1 </span><span style=font-weight:700;color:#a71d5d>=> </span><span>{
</span><span>                asg.</span><span style=color:#62a35c>assign_at_rootlevel</span><span>(vivified[</span><span style=color:#0086b3>0</span><span>]).</span><span style=color:#62a35c>expect</span><span>(</span><span style=color:#183691>"impossible"</span><span>);
</span><span>                assert!(asg.</span><span style=color:#62a35c>propagate</span><span>(cdb) </span><span style=font-weight:700;color:#a71d5d>== </span><span>ClauseId::default(), </span><span style=color:#183691>"UNSAT"</span><span>);
</span><span>            }
</span><span>            </span><span style=font-weight:700;color:#a71d5d>_ =></span><span> cdb.</span><span style=color:#62a35c>new_clause</span><span>(asg, </span><span style=font-weight:700;color:#a71d5d>&mut</span><span> vivified),
</span><span>        }
</span><span>        cdb.</span><span style=color:#62a35c>remove_clause</span><span>(</span><span style=font-weight:700;color:#a71d5d>*</span><span>ci);
</span><span>    }
</span><span>}
</span></code></pre><ul><li>空節の取り扱い（Rule 1'）、充足節の除去（Rule 2）はsolverに任せるのがいいだろうから、こう変更することにした。ただ、空節があるのに先に行っていいものだろうかという疑問はある。また、空節の場合のみ31行が成立するから8行めは無意味かも。</ul><pre class=language-diff data-lang=diff style=background:#fff;color:#323232><code class=language-diff data-lang=diff><span style=background:#ffecec;color:#323232>-                 Some(false) => copied.push(!*l),            // Rule 1
</span><span style=background:#eaffea;font-weight:700;color:#55a532>+</span><span style=background:#eaffea;color:#323232>                 Some(false) => continue,                    // Rule 1'
</span></code></pre><h3 id=2020-07-07>2020-07-07</h3><p>読了。そして理解した。プログラムを論文に忠実なものにした。 読む前はその分量に抵抗を感じていたのだけど、意外に素直な読みやすい論文だった。 「permanent clauseは <code>rank</code> を変更しない」というマイクロチューニングを放棄する日が来るとは。。。<ul><li>Rule 1が正しいものに戻された<li>Rule 2が正しいものに戻された<li>部分節なのかその否定なのかを変数<code>flipped</code>で保持<li>flippedの役割も担っていた変数<code>vivified</code>は削除<li>部分節が空節の場合でも処理を続ける<li>部分節が単位節の場合の検査は省略して、そのまま例外を上流に投げる</ul><pre class=language-rust data-lang=rust style=background:#fff;color:#323232><code class=language-rust data-lang=rust><span style=font-weight:700;color:#a71d5d>fn </span><span style=font-weight:700;color:#795da3>vivify</span><span>(asg: </span><span style=font-weight:700;color:#a71d5d>&mut</span><span> AssignStack, cdb: </span><span style=font-weight:700;color:#a71d5d>&mut</span><span> ClauseDB) -> MaybeInconsistent {
</span><span>    </span><span style=font-weight:700;color:#a71d5d>let mut</span><span> clauses: </span><span style=color:#0086b3>Vec</span><span>&LTClauseId> </span><span style=font-weight:700;color:#a71d5d>= </span><span style=color:#0086b3>Vec</span><span>::new();
</span><span>    </span><span style=font-weight:700;color:#a71d5d>for </span><span>(i, c) </span><span style=font-weight:700;color:#a71d5d>in</span><span> cdb.</span><span style=color:#62a35c>iter_mut</span><span>().</span><span style=color:#62a35c>enumerate</span><span>() {
</span><span>        </span><span style=font-weight:700;color:#a71d5d>if</span><span> c.</span><span style=color:#62a35c>to_vivify</span><span>() { clauses.</span><span style=color:#62a35c>push</span><span>(ClauseId::from(i)); }
</span><span>    }
</span><span>    clauses.</span><span style=color:#62a35c>sort_by_key</span><span>(|ci| cdb[</span><span style=font-weight:700;color:#a71d5d>*</span><span>ci].rank);
</span><span>    </span><span style=font-weight:700;color:#a71d5d>for</span><span> ci </span><span style=font-weight:700;color:#a71d5d>in</span><span> clauses.</span><span style=color:#62a35c>iter</span><span>() {
</span><span>        </span><span style=font-weight:700;color:#a71d5d>let</span><span> c: </span><span style=font-weight:700;color:#a71d5d>&mut</span><span> Clause </span><span style=font-weight:700;color:#a71d5d>= &mut</span><span> cdb[ci];
</span><span>        </span><span style=font-weight:700;color:#a71d5d>let mut</span><span> copied: </span><span style=color:#0086b3>Vec</span><span>&LTLit> </span><span style=font-weight:700;color:#a71d5d>= </span><span style=color:#0086b3>Vec</span><span>::new();
</span><span>        </span><span style=font-weight:700;color:#a71d5d>let mut</span><span> flipped </span><span style=font-weight:700;color:#a71d5d>= </span><span style=color:#0086b3>true</span><span>;
</span><span>        'this_clause: </span><span style=font-weight:700;color:#a71d5d>for</span><span> l </span><span style=font-weight:700;color:#a71d5d>in</span><span> c.lits.</span><span style=color:#62a35c>iter</span><span>() {
</span><span>            </span><span style=font-weight:700;color:#a71d5d>match</span><span> asg.</span><span style=color:#62a35c>assigned</span><span>(</span><span style=font-weight:700;color:#a71d5d>*</span><span>l) {
</span><span>                </span><span style=color:#0086b3>Some</span><span>(</span><span style=color:#0086b3>false</span><span>) </span><span style=font-weight:700;color:#a71d5d>=> continue 'this_clause</span><span>,         </span><span style=font-style:italic;color:#969896>// Rule 1
</span><span>                </span><span style=color:#0086b3>Some</span><span>(</span><span style=color:#0086b3>true</span><span>) </span><span style=font-weight:700;color:#a71d5d>=> </span><span>{
</span><span>                    copied.</span><span style=color:#62a35c>push</span><span>(</span><span style=font-weight:700;color:#a71d5d>!*</span><span>l);
</span><span>                    </span><span style=font-weight:700;color:#a71d5d>let</span><span> r </span><span style=font-weight:700;color:#a71d5d>=</span><span> asg.</span><span style=color:#62a35c>reason_literals</span><span>(cdb, </span><span style=font-weight:700;color:#a71d5d>*</span><span>l);
</span><span>                    copied </span><span style=font-weight:700;color:#a71d5d>=</span><span> asg.</span><span style=color:#62a35c>minimize</span><span>(cdb, </span><span style=font-weight:700;color:#a71d5d>&</span><span>copied, </span><span style=font-weight:700;color:#a71d5d>&</span><span>r);  </span><span style=font-style:italic;color:#969896>// Rule 2
</span><span>                    flipped </span><span style=font-weight:700;color:#a71d5d>= </span><span style=color:#0086b3>false</span><span>;
</span><span>                    </span><span style=font-weight:700;color:#a71d5d>break 'this_clause</span><span>;
</span><span>                }
</span><span>                </span><span style=color:#0086b3>None </span><span style=font-weight:700;color:#a71d5d>=> </span><span>{
</span><span>                    </span><span style=font-weight:700;color:#a71d5d>let</span><span> cid: </span><span style=color:#0086b3>Option</span><span>&LTClauseId> </span><span style=font-weight:700;color:#a71d5d>= match</span><span> copied.</span><span style=color:#62a35c>len</span><span>() {
</span><span>                        </span><span style=color:#0086b3>0 </span><span style=font-weight:700;color:#a71d5d>=> </span><span style=color:#0086b3>None</span><span>,
</span><span>                        </span><span style=color:#0086b3>1 </span><span style=font-weight:700;color:#a71d5d>=> </span><span>{ asg.</span><span style=color:#62a35c>assign_by_decision</span><span>(copied[</span><span style=color:#0086b3>0</span><span>]); </span><span style=color:#0086b3>None </span><span>}
</span><span>                        </span><span style=font-weight:700;color:#a71d5d>_ => </span><span style=color:#0086b3>Some</span><span>(cdb.</span><span style=color:#62a35c>new_clause</span><span>(asg, </span><span style=font-weight:700;color:#a71d5d>&mut</span><span> copied)),
</span><span>                    };
</span><span>                    asg.</span><span style=color:#62a35c>assign_by_decision</span><span>(</span><span style=font-weight:700;color:#a71d5d>!*</span><span>l);
</span><span>                    </span><span style=font-weight:700;color:#a71d5d>let</span><span> cc </span><span style=font-weight:700;color:#a71d5d>=</span><span> asg.</span><span style=color:#62a35c>propagate</span><span>(cdb);
</span><span>                    copied.</span><span style=color:#62a35c>push</span><span>(</span><span style=font-weight:700;color:#a71d5d>!*</span><span>l);                         </span><span style=font-style:italic;color:#969896>// Rule 4
</span><span>                    </span><span style=font-weight:700;color:#a71d5d>if</span><span> cc </span><span style=font-weight:700;color:#a71d5d>!= </span><span>ClauseId::default() {
</span><span>                        </span><span style=font-weight:700;color:#a71d5d>let</span><span> r </span><span style=font-weight:700;color:#a71d5d>=</span><span> cdb[cc].lits.</span><span style=color:#62a35c>clone</span><span>();         </span><span style=font-style:italic;color:#969896>// Rule 3
</span><span>                        copied </span><span style=font-weight:700;color:#a71d5d>=</span><span> asg.</span><span style=color:#62a35c>minimize</span><span>(cdb, </span><span style=font-weight:700;color:#a71d5d>&</span><span>copied, </span><span style=font-weight:700;color:#a71d5d>&</span><span>r);
</span><span>                        flipped </span><span style=font-weight:700;color:#a71d5d>= </span><span style=color:#0086b3>false</span><span>;
</span><span>                    }
</span><span>                    asg.</span><span style=color:#62a35c>cancel_until</span><span>(asg.root_level);
</span><span>                    </span><span style=font-weight:700;color:#a71d5d>if let </span><span style=color:#0086b3>Some</span><span>(cj) </span><span style=font-weight:700;color:#a71d5d>=</span><span> cid { cdb.</span><span style=color:#62a35c>remove_clause</span><span>(cj); }
</span><span>                    </span><span style=font-weight:700;color:#a71d5d>if</span><span> cc </span><span style=font-weight:700;color:#a71d5d>!= </span><span>ClauseId::default() { </span><span style=font-weight:700;color:#a71d5d>break 'this_clause</span><span>; }
</span><span>                }
</span><span>            }
</span><span>        }
</span><span>        </span><span style=font-weight:700;color:#a71d5d>if</span><span> flipped { </span><span style=color:#62a35c>flip</span><span>(</span><span style=font-weight:700;color:#a71d5d>&mut</span><span> copied); }
</span><span>        </span><span style=font-weight:700;color:#a71d5d>match</span><span> copied.</span><span style=color:#62a35c>len</span><span>() {
</span><span>            </span><span style=color:#0086b3>0 </span><span style=font-weight:700;color:#a71d5d>=> </span><span>(),
</span><span>            </span><span style=color:#0086b3>1 </span><span style=font-weight:700;color:#a71d5d>=></span><span> asg.</span><span style=color:#62a35c>assign_at_rootlevel</span><span>(copied[</span><span style=color:#0086b3>0</span><span>])</span><span style=font-weight:700;color:#a71d5d>?</span><span>,
</span><span>            </span><span style=font-weight:700;color:#a71d5d>_ =></span><span> cdb.</span><span style=color:#62a35c>new_clause</span><span>(asg, </span><span style=font-weight:700;color:#a71d5d>&mut</span><span> copied),
</span><span>        }
</span><span>        cdb.</span><span style=color:#62a35c>remove_clause</span><span>(</span><span style=font-weight:700;color:#a71d5d>*</span><span>ci);
</span><span>    }
</span><span>	</span><span style=color:#0086b3>Ok</span><span>(())
</span><span>}
</span></code></pre><h3 id=2020-07-08>2020-07-08</h3><p>ほぼ完成。 色々とチューニング中。 途中で答えの充足性が無茶苦茶になってしまってまた大変なデバッグが始まるのかと思いきや、原因を追っていくと決定レベルが0でないところでvivificationをしていただけだった。<p>修正しながら、このコードは特に決定レベル0に依存するところはないなあ（lockされた節さえ避ければよい）と気づいたのだが、さて、そうすると、解の近くにきた場合にrandom walkというかbelief propagationというか、そういうのの代わりに使えないものだろうか。。。。<p>それは無理。12行目で割当てを調べているが、この値は現在の部分割当て列に依存している。これは単なる仮説。 従ってこの結果に基づいてリテラルを削除したり簡略化したりはできない。<h3 id=2020-07-09>2020-07-09</h3><p>L45で追加してL47削除するのは無駄なので対消滅させた。なぜかinconsistent errorが出た。 <code>propagate</code>が矛盾を返す。なぜだろう。<p>そのうちなくなった。。。<h3 id=2020-07-22>2020-07-22</h3><p>250変数の問題でpanicを起こした！ トレースしてみると、27行目の<code>assign_by_decision</code>が実際には矛盾を発生していたにも関わらず、この関数は例外を投げないので、後の伝播で問題が発生したようだ。 propagate側の関数にはあまり手を入れたくなかったので、27行目の前にチェックを入れることにして対応した（24行目の方は論理的に大丈夫なはず）。 まさか、こんな小さな問題でバグが検出されるとは。<p>ついでに45行目の前にbiclauseだったら重複検査もすることにしました。<h3 id=2020-08-14>2020-08-14</h3><p>まだバグが出る。 やはりL44の<code>asg.assign_at_rootlevel(copied[0])?</code>で変数がassertされたら直後に<code>propagate</code>しないと、伝播の取りこぼしが起きてしまうようだ。 vivificationの対象リテラル数を増やすと現れてきたのでおそらくこの解釈でいいんだと思う。<h3 id=2020-08-15>2020-08-15</h3><p>うーむ、ここではひっかかるまいとちょっとだけ期待していたのだが、天網恢恢疎にして漏らさず、やっぱり上で追加した<code>propagate</code>が矛盾を発生させることもあるわいなぁ。 ちゃんと返値をチェックして<code>SolverError::Inconsistent</code>を返すことにしました。<pre style=background:#fff;color:#323232><code><span>Running on the 204-206th problem ezfact64_8.shuffled-as.sat03-1524-sc2002...SAT/SR19/f10nidw-sc2012.cnf: thread 'main' panicked at 'Vivification found an uncatchable inconsistency.', src/solver/vivify.rs:147:21
</span><span>note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</span></code></pre><div class="date-footer is-size-7 is-family-code has-text-grey has-text-right" style=margin-top:2rem>Published at 2020-07-05   Last updated 2020-08-23 </div></div><nav class="navbar is-fixed-bottom" aria-label=navigation id=bottombar><div class=navbar-brand><div class=navbar-item><a class=tagword href=/tags/#sat>#SAT</a></div><div class=navbar-item><a class=tagword href=/tags/#vivification>#vivification</a></div><div class=navbar-item><a class=tagword href=/tags/#splr>#splr</a></div></div></nav><footer class="copyright is-size-6 has-text-info">Copyright 2019-2023 Narazaki Shuji.</footer>