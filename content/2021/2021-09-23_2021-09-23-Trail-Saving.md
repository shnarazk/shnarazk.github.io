---
title: Implement Trail Saving instead of ChronoBT
updated: 2021-09-28
extra:
  banner: /2021/2021-09-23_banner.jpg
  banner_caption: Let's recycle!
  subtitle: I gave it up.
taxonomies:
    tags: ["SAT", "splr", "chronoBT", "trail-saving"]
---
ChronoBTがちゃんと動かない！いくら考えてもなぜUNSAT certificateがおかしくなるのか見当もつかないので、諦めてもっと新しいアプローチに乗り換えることにした！
Splr-0.13にランディングの[予定](https://github.com/shnarazk/splr/pull/144)。

### preparation

先頭部が削除、追加されるので使用するデータ型はスタックにした。

```rust
sturct AssignStack {
    /// Partial record of unassigned assignments as stack
    trail_saved: Vec<Lit>,
    reason_saved: Vec<AssignReason>,
}
```

### fn backtrack

![](/2021/2021-09-23_Backtrack.png)

```rust
fn backtrack(&mut self, bt_level: DecisionLevel) {
  let current_level = self.decision_level();
  let head = self.len_upto(bt_level + 1);
  for lit in self.trail[head..self.len_upto(current_level - 1)].rev() {
    let vi = lit.vi();
    // copy the reason
    self.reason_saved[vi] = self.reason[vi];
    // save the assign
    self.trail_saved.push(lit);
  }
  self.trail.truncate(head);
}
```

### fn propagate

![](/2021/2021-09-23_Propagate.png)

返値の型を`Option`から`Result`に変更した。

```rust
fn new_propagate(&mut self) -> Result<(), ConflictContext> {
    while self.remains() {
        self.use_saved_trail()?;
        // 以前のpropagateの処理を1リテラル分だけ走らせる。
        self.propagate_single()?;
    }
    Ok(())
}
```
### fn use_saved_trail

![](/2021/2021-09-23_UseSavedTrail.png)

以下の2つは等価だから条件式は <i>O(1)</i> なものに変換した。
- self.trail.contains(&lit)
- self.assigned(lit) == Some(true)

```rust
fn use_saved_trail(&mut) -> Result<(), ConflictContext> {
    for i in (0..self.trail_saved.len()).rev() {
        let lit = self.trail_saved[i];
        let vi = lit.vi();
        match self.reason_saved[vi] {
            AssignReason::Decision => {
                if self.assigned(lit) == Some(true) {
                    continue;
                }
                self.trail_saved.truncate(i + 1);
                return Ok(());
            }
            AssignReason::Implication(c, l) => {
                match self.assigned(lit) {
                    Some(true) => continue,
                    Some(false) => return Err(ConflictContext{ cid: c, link: l}),
                    None => { self.assign_by_implication(lit, _, c, l) }
                }
            }
            AssignReason::Asserted(_) => panic!("impossible path"),
            AssignReason::None => panic!("impossible path"),
        }
    }
}
```

## 2021-09-28

このように短いコードなので、1日で実装終わるはずだったのに3日ほどデバッグで苦しんでしまった。

一体何が問題だったかというと、`reason_saved`に入れた節がいつの間にかreasonでなくっていたせい。
確かに他の伝播（つまり別リテラルのreasonに使われる）場合、節内リテラル順序は変更されるのでそういう場合を想定しなければならない。少なくともSplrでは（論文ではどういう実装を考えているのだ？）。

そして観測を続けると、reason_savedに保存された節の全てのリテラルが否定されることがあるようだ。
これは矛盾状態なので、どのリテラルで考えるかによらず（先頭がどのリテラルなのかを気にすることなく）矛盾解析に回してよさそうだが、矛盾扱いすると、UNSAT certificateがおかしくなってしまう。

一体何が起きているのだろう。
`q_head`の更新し忘れなのだろうか。



