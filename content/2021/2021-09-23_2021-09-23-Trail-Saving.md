---
title: Trail Saving instead of Chrono-BT
extra:
  banner: /2021/2021-09-23_banner.jpg
  banner_caption: Let's recycle!
  subtitle: I gave it up.
taxonomies:
    tags: ["SAT", "splr", "chronoBT", "trail-saving"]
---
Chrono-BTがちゃんと動かない！
諦めてもっと新しいアプローチに乗り換える！
Splr-0.13にランディングする予定。

```rust
fn backtrack(&mut self, bt_level: DecisionLevel) {
  let current_level = self.decision_level();
  let head = self.len_upto(bt_level + 1);
  // trail_savedはstackになっているので注意。
  // self.trail_saved.clear(); 前回の結果をクリアする必要ある？
  for lit in self.trail[head..self.len_upto(current_level - 1)] {
    let vi = lit.vi()
    // copy the reason
    self.reason_saved[vi] = self.reason[vi];
    // save the assign
    self.trail_saved.push(lit);
  }
  self.trail.truncate(head);
}
```

```rust
fn new_propagate(&mut self, mut ix: usize) -> Option<ConflictContext> {
    for i in ix..self.trail.len() {
       if let cc@Some(_clause) = self.use_saved_trail() {
           return cc;
       }
       let propagating_literal = self.trail[i];
       // TODO
       for each clause c in watchlist(!l) {
           if c is unit implying x {
               T.addToEnd(x);
               reason(x) = c;
           } else if c is falsified {
               return Some(ConflictContext(..));
           } else {
               update c's watches.
           }
       }
    }
    None
}
```

`saved`は使い捨てだとして簡略化したもの。要検証。

```rust
fn use_saved_trail(&mut self) -> Option<ConflictContext> {
    while let Some(lit) = self.tail_save.pop() {
        match self.assigned(lit) {
            // trailにあるから無視できる。
            Some(true) => continue,
            // trailに反リテラルがあるから矛盾した。
            Some(false) => {
                if let AssignReason::Implication(c, l) = self.reason[lit.vi()] {
                    return Some(ConflictContext(c, l));
                } else {
                    panic!("impossible");
                }
            }
            // 以前は決定変数だったのでsolverで決定レベルを上げてもらう。
            _ if self.reason_saved[lit.vi()].is_none() => return None,
            // savedから復活させる
            _ => {
                let vi = lit.vi();
                self.level[vi] = lv;
                self.reason[vi] = self.reason_saved[vi]
                self.reason_saved[vi] = AssignReason::None;
                self.reward_at_assign(vi); // mulitple borrows here
                self.trail.push(l);
                if self.root_level == lv {
                    self.make_var_asserted(vi);
                }
            }
        }
    }
    None
}
```

```rust
fn use_saved_trail2(&mut self) -> Option<ConflictContext> {
    while let Some(lit) = self.tail_save.pop() {
      // 以下の2つは等価だから条件式はO(1)なものに変換できるはず
      // - self.trail.contains(&lit)
      // - self.assigned(lit) == Some(true)
      if self.trail.contains(&lit) {
          continue;
      }
      if self.reason_saved[lit.vi()].is_none() {
          return None;
      }
      if self.trail.contains(&!lit) {
          return Some(ConflictContext(reasonsave(lit)));
      }
      T.addToEnd(lsave);
      self.reason[lit.vi()] = self.reason_saved[lit.vi()];
    }
    None
}
```

元々の関数。

```rust
fn use_saved_trail_original(&mut self) -> Option<ConflictContext> {
    for i in 0..self.tail_save.len() {
      // TODO
      lsave = Tsave[idx];
      if reasonsave(lsave) == empty {
          if lsave in T {
              continue;
          } else {
              break;
          }
      } else {
          if lsave in T {
              continue;
          } else if !lsave in T {
              c = reasonsave(lsave);
              idx = 0;
              break;
          } else {
              T.addToEnd(lsave);
              reason(lsave) = reason_save(lsave);
          }
      }
    }
    for i in 0..idx {
        Tsave.removeFront();
    }
    None
}
```
