---
title: Trail Saving instead of ChronoBT
extra:
  banner: /2021/2021-09-23_banner.jpg
  banner_caption: Let's recycle!
  subtitle: I gave it up.
taxonomies:
    tags: ["SAT", "splr", "chronoBT", "trail-saving"]
---
ChronoBTがちゃんと動かない！
諦めてもっと新しいアプローチに乗り換える！
Splr-0.13にランディングする予定。

### preparation

```rust
sturct AssignStack {
    /// stack of temporal and partial record of assignments
    trail_saved: Vec<lit>,
}

### backtrack

![](/2021/2021-09-23_Backtrack.png)

```rust
fn backtrack(&mut self, bt_level: DecisionLevel) {
  let current_level = self.decision_level();
  let head = self.len_upto(bt_level + 1);
  for lit in self.trail[head..self.len_upto(current_level - 1)].rev() {
    let vi = lit.vi();
    // copy the reason
    self.reason_saved[vi] = self.reason[vi];
    // save the assign
    self.trail_saved.push(lit);
  }
  self.trail.truncate(head);
}
```

### propagate

![](/2021/2021-09-23_Propagate.png)

返値の型を`Option`から`Result`に変更した。

```rust
fn new_propagate(&mut self) -> Result<(), ConflictContext> {
    while self.remains() {
        self.use_saved_trail()?;
        // 以前のpropagateの処理を1リテラル分だけ走らせる。
        self.propagate_single()?;
    }
    Ok(())
}
```
### use_saved_trail

![](/2021/2021-09-23_UseSavedTrail.png)

以下の2つは等価だから条件式はO(1)なものに変換した。
- self.trail.contains(&lit)
- self.assigned(lit) == Some(true)

```rust
fn use_saved_trail(&mut self) -> Result<(), ConflictContext> {
    let mut processed = 0;
    while let Some(lit) = self.trail_saved.pop() {
        processed.push(lit);
        match self.assigned(lit) {
            // trailにあるから無視できる。
            Some(true) => continue,
            // trailに反リテラルがあるから矛盾した。
            Some(false) => {
                if let AssignReason::Implication(c, l) = self.reason[lit.vi()] {
                    while let Some(l) = dropped.pop() {
                        self.trail_save.push(l);
                    }
                    return Err(ConflictContext(c, l));
                }
                panic!("Impossible pash 1 in use_saved_trail");
            }
            None => {
                match self.reason_saved[lit.vi()] {
                    // 決定変数として記録されているのでここで打ち切る。
                    AssignReason::Decision => return Ok(()),
                    // 含意変数として記録されているのでsavedから復活させる。
                    reason@AssignReason::Implication(_, _) => {
                        self.assign_by_implication(lit, reason);
                    }
                    _ => panic!("Impossible path 2 in use_saved_trail"),
                }
            }
        }
    }
    Ok(())
}
```

```rust
fn use_saved_trail2(&mut self) -> Option<ConflictContext> {
    while let Some(lit) = self.tail_save.pop() {
      if self.trail.contains(&lit) {
          continue;
      }
      if self.reason_saved[lit.vi()].is_none() {
          return None;
      }
      if self.trail.contains(&!lit) {
          return Some(ConflictContext(reasonsave(lit)));
      }
      T.addToEnd(lsave);
      self.reason[lit.vi()] = self.reason_saved[lit.vi()];
    }
    None
}
```
