---
title: BQNでAoC2022 day19を解こう
extra:
  banner: /2023/2023-03-07.jpg
  banner_caption: Let's learn BQN
  subtitle: under construction
taxonomies:
  tags: ["bqn", "advent-of-code"]
---
# s this!?

[Advent of Code y2022 day19](https://adventofcode.com/2022/day/19)の[BQN](https://github.com/mlochbaum/BQN)解法に大変苦労した（している）のでちょこっとメモしておこう。

基本的には最短経路問題なのでRust版だとこんな感じ。
```rust
var to_visit: BinaryHeap;
var visited: HashSet;

while let Some(state) = to_visit.pop() {
  for next in state.expand() {
    if !visited.contains(&next) {
      visited.insert(&next);
      to_visit.insert(&next);
    }
  }
}
```
これを基にBQN版を作っていったのだがとても遅くて解けるとは言えなかったのでさらに知恵を絞ることになった。
ちなみにdzaima版は実行してない。

1. 時間を単位とする遷移からロボット追加を単位とする遷移へ
これはRust版でも実装済み。状態空間を縮小するため何もしないで資源が増えるだけの状態を保持するのではなく、ロボットの増加を状態遷移の条件としよう。


2. 必要以上にロボットを溜め込む必要はない
clayロボットだけを作り続ける遷移は意味がない。他のロボットも作らねば。
ということで必要以上にロボットを溜め込むような次状態は探索対象にしないようにした。

3. N台のロボットの状態からN+1台のロボットの状態に遷移したあとではN台のロボットの状態を記憶しておく必要はない。
ロボット数の増加が状態遷移をもたらすなら、ロボット数Nの状態からなる集合をそれぞれ展開（探索）してできる状態集合は（全ての）ロボット数N+1の状態なので探索済みかどうかはその集合内要素が重複していないことの判定に帰着する。
N未満のロボット数の状態を記憶しておく必要はない。Life gameのように2つのbagを切り替えながら展開していけばよい。

4. 深さ1のリスト化
```apl
time‿⟨nore‿nclay‿nobsidian‿ngeode⟩‿⟨rore‿rclay‿robsidian‿rgeode⟩
```

```apl
time‿nore‿nclay‿nobsidian‿ngeode‿rore‿rclay‿robsidian‿rgeode
```

5. 時間方向を逆転することで状態の半順序関係定義の簡略化

```apl
{(𝕨(>○⊑)𝕩)∧(𝕨((∧´<)○(1↓))𝕩)}
```

```apl
(∧´<)
```

6. 状態集合の整列
