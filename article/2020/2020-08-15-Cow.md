---
title: RustのClone on Writeについて
subtitle: std::borrow::cow
date: 2020-08-15
tag: ["Rust"]
---
自転車本では紹介されてないけれど、Rustならでは必要とされる面白い型、Copy on Writeではなくて、Clone on Writeを意味する`std::borrow::Cow`の紹介です。

## 前提知識：`str` と `String`の違い

* `str` -- （固定長の）UTF-8文字のスライス
* `&str` -- UTF-8文字のスライスへのポインタ
* `String` -- ヒープ上に置かれた、追加を含めた変更ができる文字列


## 前提知識：文字列定数とその参照

#### ローカル変数

まず、以下のように関数内のローカルデータとして確保された文字列定数を参照する変数は何型でしょうか。

```rust
fn f() {
  let s = "a fixed string";
  ...
```

これは `&str` です。

```rust
fn f() {
  let s: &str = "a fixed string";
  ...
```

* `"a fixed string"`はローカル変数なのでヒープに置く必要はありません。
* `str`は通常Rustのプログラムには出て来ない。変数`s`はその確保された領域を指すように片付けられます。

#### グローバル変数

では`s`がグローバル変数`S`になるとどうなるでしょう。

```rust
const S: ??? = "a fixed string";
```

グローバル変数も他の言語同様にヒープではなくOSで言うところのデータ領域に置かれるのでやはり`str`であり、
その領域を指すので変数`S` は`&str`型になります。

## 前提知識：`str`と`String`間の変換

### `&str`から`String`へ

`&str`型の変数があればその指している対象から`to_string`メソッドを使ってStringを作ることができます。

```rust
fn f() {
  let s: &str = "A fixed string" 
  let t = s.to_string();     // ヒープ操作を必要とする
  ...
```

この時tの実体はヒープ上に置かれたfat pointerです。固定長なのでメモリを大きく消費するわけではありませんが、実体を正しく指すポインタを含む構造体をヒープ上に構成する必要があります。

### `String`から`&str`へ

逆の操作は`as_str()`です。この操作は`String`を構成するfat pointerの一部を参照すればいいので極めて軽量です。
これは`&srt`から`String`への変換が`to_*`系なのに対し、`String`から`&str`への変換が`as_*`系の命名になっていることからもわかります。

```rust
fn f() {
  let s: String = "A fixed string".to_string();
  let t: &str = s.as_str();    // 軽量な操作
  ...
```

ここまでが前提知識でした。

# 問題となるシナリオ: `&str` と `String` の混在

