---
title: RustのClone on Writeについて
subtitle: 'std::borrow::cow'
date: 2020-08-15
tags: ["Rust"]
---
自転車本では紹介されてないけれど、Rustならでは必要とされる面白い型、Copy on Writeではなくて、Clone on Writeを意味する`std::borrow::Cow`の紹介です。

## 前提知識：`str` と `String`の違い

* `str` -- （固定長の）UTF-8文字のスライス
* `&str` -- UTF-8文字のスライスへのポインタ
* `String` -- ヒープ上に置かれた、追加を含めた変更ができる文字列


## 前提知識：文字列定数とその参照

#### ローカル変数

まず、以下のように関数内のローカルデータとして確保された文字列定数を参照する変数は何型でしょうか。

```rust
fn f() {
  let s = "a fixed string";
  ...
```

これは `&str` です。

```rust
fn f() {
  let s: &str = "a fixed string";
  ...
```

* `"a fixed string"`はローカル変数なのでヒープに置く必要はありません。
* `str`は通常Rustのプログラムには出て来ない。変数`s`はその確保された領域を指すように片付けられます。

#### グローバル変数

では`s`がグローバル変数`S`になるとどうなるでしょう。

```rust
const S: ??? = "a fixed string";
```

グローバル変数も他の言語同様にヒープではなくOSで言うところのデータ領域に置かれるのでやはり`str`であり、
その領域を指すので変数`S` は`&str`型になります。

## 前提知識：`str`と`String`間の変換

### `&str`から`String`へ

`&str`型の変数があればその指している対象から`to_string`メソッドを使ってStringを作ることができます。

```rust
fn f() {
  let s: &str = "A fixed string" 
  let t = s.to_string();     // ヒープ操作を必要とする
  ...
```

この時tの実体はヒープ上に置かれたfat pointerです。固定長なのでメモリを大きく消費するわけではありませんが、実体を正しく指すポインタを含む構造体をヒープ上に構成する必要があります。

### `String`から`&str`へ

逆の操作は`as_str()`です。この操作は`String`を構成するfat pointerの一部を参照すればいいので極めて軽量です。
これは`&srt`から`String`への変換が`to_*`系なのに対し、`String`から`&str`への変換が`as_*`系の命名になっていることからもわかります。

```rust
fn f() {
  let s: String = "A fixed string".to_string();
  let t: &str = s.as_str();    // 軽量な操作
  ...
```

ここまでが前提知識でした。

# 問題となるシナリオ: `&str` と `String` の混在

ある構造体`S`に対してその文字列表現を返す`rep()`メソッドを定義するとします。
ただし、

* その構造体が持っているフィールド`index`が0の時は固定のメッセージ
* そうでなければ内部データの値がわかる文字列にしたい

とします。

```rust
struct S {
  index: usize,
  vec: Vec<usize>,
}

impl S {
  fn rep(&self) -> ??? {
     let null: &str = "null object";
     if self.index == 0 {
         ...
     } else {
         ...
     }
  }
}
```

### Case 1: index == 0のnull オブジェクトの場合

この場合、`rep()`内部でローカル変数`null`の値をそのまま返すのがいいでしょう。
`null`の型は `&str` であることから`rep()`の返値型も`&str`になります。

```rust
struct S {
  index: usize,
  vec: Vec<usize>,
}

impl S {
  fn rep(&self) -> &str {
     let null: &str = "null object";
     if self.index == 0 {
         null
     } else {
         ...
     }
  }
}
```

### Case 2: それ以外

フィールド`vec`の値を埋め込んだ文字列を作るため`format!`を使いましょう。

`format!`の返す型は`String`なので`rep()`の返値型も`String`になります。
```rust
struct S {
  index: usize,
  vec: Vec<usize>,
}

impl S {
  fn rep(&self) -> String {


         ...
     } else {
         format!("S{{{:?}}}", self.vec)
     }
  }
}
```

ここで型が一致しない問題に直面します。

### 解決1: `&str`への統一

既に見たようにどちらの方向にも変換できるのでまず`&str`へ統一することを考えてみます。

```rust
  fn rep(&self) -> &str {
     let null: &str = "null object";
     if self.index == 0 {
         null
     } else {
         format!("S{{{:?}}}", self.vec).as_str()
     }
  }
}
```

これはライフタイム制約を満足しないエラーになります。

```
error[E0515]: cannot return value referencing temporary value
   |
   |          format!("S{{{:?}}}", self.vec).as_str()                                                        
   |          ------------------------------^^^^^^^^^
   |          |
   |          returns a value referencing data owned by the current function
   |          temporary value created here
```

以下のようにローカル変数にバインドしても、

```rust
  fn rep(&self) -> &str {
     let null: &str = "null object";
     if self.index == 0 {
         null
     } else {
         let res = format!("S{{{:?}}}", self.vec);
         res.as_str()
     }
  }
}
```

ライフタイムが短すぎることには変わりはないので、エラーになります（`f`はヒープに置かれても所有者である`rep`からexitする時点で回収されてしまう）

```
error[E0515]: cannot return value referencing local variable `f`
   |
   |          f.as_str()                                                        
   |          -^^^^^^^^^
   |          |
   |          returns a value referencing data owned by the current function
   |          `f` is borrowed here
```

なので、`format!`で作った`String`は呼び出し側に返さないといけません。

### 解決2: `String`への統一

ということで`&str`型の`null`を返しているパスの型を変えることにします。関数の返値型を変えてコンパイルすると以下のようなエラーメッセージが表示されます。

```
error[E0308]: mismatched types
  --> src/main.rs:13:10
   |
   |   fn rep(&self) -> String {                                                                               
   |                    ------ expected `std::string::String` because of return type
...
   |          null                                                                                           
   |          ^^^^
   |          |
   |          expected struct `std::string::String`, found `&str`
   |          help: try using a conversion method: `null.to_string()`

```

ヘルプに従って修正すれば問題はなくなります。

```rust
  fn rep(&self) -> String {
     let null: &str = "null object";
     if self.index == 0 {
         null.to_string()
     } else {
         let res = format!("S{{{:?}}}", self.vec);
         res.as_str()
     }
  }
}
```

しかしこれは、必要とは思われないヒープでのオブジェクト生成をしているため、時間的にも空間的にも（できれば避けたい）コストをかけてしまっています。ゼロコストアブストラクションをうたうRustのプログラムとしては是非とも避けたいところです。

# 解決案

この問題を解決するには「借用」と「実体」のどちらも返せるような`enum`を用意するという手が使えます。

* 借用でいいならなら借用を包む
* 実体が必要なら、実体を包む

```rust
enum WrapStr {
  from_borrow(&str),
  from_format(String),
}

impl S {
  fn rep(&self) -> WrapStr {
     let null: &str = "null object";
     if self.index == 0 {
         WrapStr::from_borrow(null)
     } else {
         WraStr::from_format(format!("S{{{:?}}}", self.vec))
     }
  }
}
```

こうすれば肩の問題は解決するし、見かけ上構造体で包むコストは（おそらく）コンパイラの最適化中に何もしないコードに変換されることが期待できます。ということで`WrapStr`を追加定義すれば問題解決します。ポインタを含むのでライフタイム制約が必要かな。。。

# Cow

しかし自分で定義するよりも、すでにこのような型が標準ライブラリに用意されているのでそれを使いましょう。
それがClone on Write, `Cow`型です。以下のように定義されています。

```
pub enum Cow<'a, B> 
where
    B: 'a + ToOwned + ?Sized, 
 {
    Borrowed(&'a B),
    Owned(<B as ToOwned>::Owned),
}
```

`ToOwned`は借用したデータから、所有権を持つ実体を構成することができるというトレイトです。
文字列関連では以下のようになっています。

```
impl ToOwned for str
  type Owned = String
  
  /// Examples
  let s: &str = "a";
  let ss: String = s.to_owned();
```

つまり`str`から`String`が作れると。これを見ながら`Cow`の定義の`B`を`str`に変換してやると以下のようになります。

```
pub enum Cow<'a, str> 
where
    str: 'a + ToOwned + ?Sized,  // 条件OK
 {
    Borrowed(&'a str),
    Owned(String),
}
```

ということで、借用(`&str`)は`Cow::Borrowed`で実体(`String`)は`Cow::Owned`で包んでやればいいことがわかりました。

最終的なプログラムはこうなります。

```rust
use std::borrow::Cow;

impl S {
  fn rep(&self) -> Cow<'_, str> {
    let null: &str = "Null S1";
    if self.index == 0 {
      Cow::Borrowed(null)                  // 場所は確保済み => 借用したい
    } else {
      Cow::Owned(format!("S1[{:?}]", self.vec)) // 借用ではダメ =>実体を渡したい
    }
  }
}
```

使う側では一回derefしてやれば借用であったか実体であったかを気にする必要はありません。

```rust
   println!("{}", *s.rep());
```

ちなみにderefしたものが何型になっているかというと、

```rust
  let temp: &str = &*s.rep();
```

だそうです。文字列のスライスみたいですね。
