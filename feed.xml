<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Just a Note</title>
        <link>https://shnarazk.now.sh</link>
        <description>a collection of memo</description>
        <lastBuildDate>Tue, 07 Jul 2020 13:16:39 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>nuxtjs/feed</generator>
        <item>
            <title><![CDATA[Clause Vivification updated 2020]]></title>
            <link>https://shnarazk.now.sh/2020/2020-07-05-vivification2</link>
            <guid>https://shnarazk.now.sh/2020/2020-07-05-vivification2</guid>
            <pubDate>Mon, 06 Jul 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[**cover image: https://unsplash.com/photos/tYs9rjaT8Vc**

Vivification についての調査第2弾、2018年投稿2019年公開の論文をまとめてみた。

* Chu-Min Li *et al.*, "Clause vivification by unit propagation in CDCL SAT solvers,”*Artif. Intell.*, vol. 279, 2019.

### Outline

Vivificationは魅力的な節削減手法のでSAT competitionに提出されるようなソルバに導入されたもの、その後改善が計算量に見合わないため、取り下げられることが続いてきた。
この論文はどのタイミングで、どの節を、どのリテラルからvivifyすればよいかについて論じている。
特に[原論文](/2020]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[UNSAT LOG, 2010, Jun.]]></title>
            <link>https://shnarazk.now.sh/2020/2020-07-05-UNSATlog</link>
            <guid>https://shnarazk.now.sh/2020/2020-07-05-UNSATlog</guid>
            <pubDate>Sun, 05 Jul 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[# 6月の総括

先月、性能良くなってきたのでなんとかかんとかと書いたのですが、実はGlucose 4.1よりも全然改善されてないことがわかったので、前言撤回。どうしたものか半分途方にくれた6月でした。
後半は気を取り直して、[vivificationの実装](https://shnarazk.github.io/2020/2020-06-20-vivification/)に取り組みました。

# Vivification

読んだのは2008年の論文。

* C. Piette, Y. Hamadi, and L. Saïs, "Vivifying propositional clausal formulae," *Front. Artif. Intell. Appl.*, vol. 178, pp. 525–529, 2008.

短い論文だったし、アルゴリズムもそれほど難しいものでは]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Duplicate Learnt Clauses]]></title>
            <link>https://shnarazk.now.sh/2020/2020-06-22-duplicate-learnt-clause</link>
            <guid>https://shnarazk.now.sh/2020/2020-06-22-duplicate-learnt-clause</guid>
            <pubDate>Tue, 23 Jun 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[Google Scholar alert 発令。今日のお題は「重複した学習節による速度向上」！？

* S. Kochemazov, O. Zaikin, A. Semenov, and V. Kondratiev, "Speeding Up CDCL Inference With Duplicate Learnt Clauses," *24th European Conference on Artificial Intelligence - ECAI2020*, 2020.

duplicateは複数持つのではなく何度でも現れるという意味だ。
そのような節を削除せずに保持することで求解数が向上する（そういう問題セットが存在する）とのこと。
論文ではHash表を使って再出現を検知しようとしているようだ。
LBDによる層化は必ずしも正しいとは限らないと。

変数に比べ節の尺度はそれほど注意が]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Vivification of a CNF formula]]></title>
            <link>https://shnarazk.now.sh/2020/2020-06-20-vivification</link>
            <guid>https://shnarazk.now.sh/2020/2020-06-20-vivification</guid>
            <pubDate>Sun, 05 Jul 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[Vivification がなんなのか、日本語で探しても出てこないので以下の論文をまとめてみた。
（最新の話かと思っていたけど2008年とは。。。）

* C. Piette, Y. Hamadi, and L. Saïs, "Vivifying propositional clausal formulae,” *Front. Artif. Intell*. Appl., vol. 178, pp. 525–529, 2008.

Splr でいうところの `processor` が節数に対する制約内での網羅的な変数除去と節包摂(clause subsumption)とを実行するのに対し、vivification は（その節に「対応」する割り当てを仮定して）propagateを行った結果を用いて節の包摂方針を決めるというもの。
節長を減らす方向でのみ置換するので、（節数の増加と引き換えに）]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[井上ひさし、四千万歩の男]]></title>
            <link>https://shnarazk.now.sh/2020/2020-06-19-40M-steps</link>
            <guid>https://shnarazk.now.sh/2020/2020-06-19-40M-steps</guid>
            <pubDate>Fri, 19 Jun 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[題材が今ひとつ興味が持てなくて、しかしベストセラーになっていたので、時間ができたら読もうと思っていた
井上ひさしの長編小説「四千万歩の男」。
ようやく読了。

なんと、

* 未完！四百万歩くらいで終わった。単行本が出てから作者が亡くなるまで随分と時間があったはずなのでもう当然完結したストーリーだと思っていたのだが。。。
* 「小説」であった。同時代の有名人が毎回登場して絡んでいく。なんか早坂暁の「天下御免」を思い出した。
* なので伊能忠敬に関するドラマ化というよりも、アイヌ問題とか、農民の困窮生活とか、学閥間の争いとか、御家騒動とか、大名間の闘争とか、ドロドロした話が一話完結的に展開していく。
* 主人公が百姓上がりということから、特にその時代の百姓の生活が色々と描かれている。そういう時代を舞台にしたものは米村圭伍、岡本綺堂、半村良、NHK土曜時代劇くらいしか読んだ（り見たりした）こと]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Clap-3.0.0-beta.1]]></title>
            <link>https://shnarazk.now.sh/2020/2020-06-13-clap3</link>
            <guid>https://shnarazk.now.sh/2020/2020-06-13-clap3</guid>
            <pubDate>Sat, 13 Jun 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[[Clap](https://crates.io/crates/clap)-3.0だと[StructOpt](https://crates.io/crates/structopt)が要らなくなるのでclap-3.0.0-beta.1をちょっと試してみた。

### 1. PathBufの取扱いの違い

StructOptでは問題なくオプションになる以下のフィールドは、

```rust
   #[structopt(long = "result", default_value = "", parse(from_os_str))]
   pub result: PathBuf,
```

Clapでは引数が指定されてないエラーを起こしてしまう。
default_valueを空以外にすれば直るのだが、それは困る、Optionでくるむことにした：

```rust
    #[clap(long]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[How to compile cargo-instruments]]></title>
            <link>https://shnarazk.now.sh/2020/2020-06-07-cargo-instruments</link>
            <guid>https://shnarazk.now.sh/2020/2020-06-07-cargo-instruments</guid>
            <pubDate>Sun, 07 Jun 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[## Rustでプロファイリングしたいんじゃあ

valgrindは動くけど、perfはない、massive-visualizerもない。
Linuxに比べてmacOSはRustのプロファイリングが不自由だなあ。
それでも、まともなLinuxマシンが手元にないのでなんとかmac上でプロファイリングしなければならない。
何かインストールしなければ。
いくつか調べてみて（そもそも検索でヒットするページが意外なほど少ないのだけど）[cargo-instruments](https://crates.io/crates/cargo-instruments)というのがよさそうだということがわかりました。
残念だけど、opensshのバージョン問題で単に`cargo install`とするだけではコンパイルできないようです。
brewを使っているのが前提になっているのだろうか。
うーん、これはいつもの]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[UNSAT LOG, 2010, May.]]></title>
            <link>https://shnarazk.now.sh/2020/2020-05-29-UNSATlog</link>
            <guid>https://shnarazk.now.sh/2020/2020-05-29-UNSATlog</guid>
            <pubDate>Fri, 29 May 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[## Splr-0.4.1リリースの5月
今月たてたissue及びブランチは以下の通り：

* No restart for LR and Stabilization
* 20200514-incremental
* 20200524-handle
* 20200502-new-select
* 20200503-litpointer-on-0.3.1
* 20200509-new-rephrase
* 20200510-restart-for-lr
* 20200514-incremental
* 20200516-no-restart
* 20200518-tuning
* 20200524-dead
* 20200524-handle

Splr-0.4.0以降の分をまとめると

* incremental SATソルバの実装
* stabilizationの解釈と変数選択機構の実装]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[What's Miracle Sudoku?]]></title>
            <link>https://shnarazk.now.sh/2020/2020-05-26-MiracleSudoku</link>
            <guid>https://shnarazk.now.sh/2020/2020-05-26-MiracleSudoku</guid>
            <pubDate>Mon, 01 Jun 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[25日のHacker Newsで初めて知ったMiracle Sudoku。[ビデオ](https://www.youtube.com/watch?v=cvEq_XkQg8U)の横に書いてあることから判断するに

* Normal Sudoku rules apply.
* ナイトまたはキングが1hopで行ける場所には同じ数は置けない: Any two cells separated by a knight's move or a king's move (in chess) cannot contain the same digit.
* 近接した4近傍には連続する数列は置けない: Any two orthogonally adjacent cells cannot contain consecutive digits.

さあSATソルバの出番。

# 2020-05-30 mokumo]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[LR needs something to explore the world]]></title>
            <link>https://shnarazk.now.sh/2020/2020-05-20-LR-needs-something</link>
            <guid>https://shnarazk.now.sh/2020/2020-05-20-LR-needs-something</guid>
            <pubDate>Thu, 21 May 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[引き続きよくわかってない人の意見の連投ですが。

## LRのリスタート問題

LR はよさそうなんだけども、そんなにいいならリスタートの立場はどうなる？
矛盾発生率の最適化を達成していて何故リスタートが必要になるのだろうか。

しかし何かそのようなものが必要なことはすぐわかる。
以前も書いたような気がするがリスタートはリスタートであって、決してリセットではないのだ。
EVSIDS も含めた変数選択ヒューリスティックスは割当て後にその使われた変数に値を割り当てるもので、使われてない変数に脚光を当てるものではない。
従って、リスタートを掛けても優先度が高い変数間の順序が変わるだけと書いてもそれほど言い過ぎというわけではないだろう。
もちろん順序を入れ替えることによってリスタート後の伝播の方向がこれまでと違う方向へと向かうことはあるけども、いきなり極端に違う変数が選ばれるものではない（という去]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[What's the difference between EVSIDS and LR?]]></title>
            <link>https://shnarazk.now.sh/2020/2020-05-19-two-heuristics</link>
            <guid>https://shnarazk.now.sh/2020/2020-05-19-two-heuristics</guid>
            <pubDate>Tue, 19 May 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[よくわかってない人の意見ですが。

最近のSATソルバの注目すべきアイデアの一つにLearning Rate (+ Reason-Side) Rewardingがある。
長らく続いてきたEVSIDS一強時代に対抗できる成果を残している。と言っても完全に上回るのではなく
「タイムアウトを長くした」場合という限定詞付きではあるが、それでも注目すべき技術だろう。
というわけで最近のSplrでもfeatureで切り替えられるようにした。

LRのよさはなんとなくわかる。LRのアイデアは学習率の最適化により矛盾発生頻度を最大化しようとするものである[1]。

> In particular, we model the variable selection optimization problem as an online multi-armed bandit, a special-case of r]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[What's 's-l'?]]></title>
            <link>https://shnarazk.now.sh/2020/2020-05-09-Emacs-keybind-s-l</link>
            <guid>https://shnarazk.now.sh/2020/2020-05-09-Emacs-keybind-s-l</guid>
            <pubDate>Sat, 09 May 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[[lsp-mode](https://github.com/emacs-lsp/lsp-mode)がプレフィックスとして採用している'`s-l`'とは一体なんなんだ？

'`s`'は`Super`かとも思うのだがだったら大文字ではないのか？　いや、それなら`Shift`になる。。。
`Super`のつもりで`Option`キーを押してみても反応ない。。。

ググってわかった。やはり`Super`だった。macのコンソールに入力できてないだけだった。
と思ったらちゃんと入力方法が用意してあった(https://emacs.stackexchange.com/questions/55199/what-are-these-prefix-commands-that-start-with-s-l)。

> You can simulate these additional keys with som]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[UNSAT LOG, 2010, Apr.]]></title>
            <link>https://shnarazk.now.sh/2020/2020-04-22-UNSATlog</link>
            <guid>https://shnarazk.now.sh/2020/2020-04-22-UNSATlog</guid>
            <pubDate>Wed, 22 Apr 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[# 0.3.3まだまだ

非常事態宣言が発出されて外を出歩かなくなってしまったのでカバーに使えるような写真のストックがなくなっ
てきました。プログラミングの時間は増えてそれなりに進展あり。

# CaDiCaLにおける重要技術の絞り込み

[CaDiCaL](https://github.com/arminbiere/cadical)の何がいいのかを調べるため[sat-bench](https://github.com/shnarazk/SAT-bench)でオプションを切り替えながら3SATを実行してみました。詳細な結果は[Importance of modern techniques in SAT solvers](/2020/2020-04-08-modern-techniques-of-SAT-solver/) に書きました。

結論として、今のSplrにないものをまとめると、

]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Building Emacs27.nix on MacOS]]></title>
            <link>https://shnarazk.now.sh/2020/2020-04-11-emacs27-on-nix</link>
            <guid>https://shnarazk.now.sh/2020/2020-04-11-emacs27-on-nix</guid>
            <pubDate>Sat, 11 Apr 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[* `?`を使ったカスタマイズはemacsをオーバーレイする前に解決されてしまっているので`call-process`を呼び
  出すのでなければ、（`nativeBuildInputs`に対してやっているように）自前で各アトリビュートを上書きするしかない。
* なんか`rev`が無視されているような気がする -> ちゃんとダミー値を与えて一回失敗させないといけない。
  これでちゃんと更新されるようになった。

```
# ~/.config/nixpkgs/overlays/emacs27.nix
self: super:
{
  emacs27 = super.emacs.overrideAttrs (attrs: rec {
    pname = "emacs27";
    # srcRepo = true;
    name = "emacs27-${version}";
 ]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Importance of modern techniques in SAT solvers]]></title>
            <link>https://shnarazk.now.sh/2020/2020-04-08-modern-techniques-of-SAT-solver</link>
            <guid>https://shnarazk.now.sh/2020/2020-04-08-modern-techniques-of-SAT-solver</guid>
            <pubDate>Mon, 20 Apr 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[さあ[CaDiCaL](https://github.com/arminbiere/cadical)がなぜ速いのか検討しよう。
CaDiCalのbool型のオプションを一つづつ外して、[SAT-bench](https://github.com/shnarazk/SAT-bench)を使ってUF250とUUF250の実行速度を計測してみた。以下が結果の生データ。

| Technique          |     SAT   |    UNSAT  |
| -----------------  | --------: | --------: |
| arena              |  67.276   |  411.603  |
| arenacompact       |  72.570   |  385.086  |
| arenasort          |  64.9]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Liveness of nix-store created by 'nix-build']]></title>
            <link>https://shnarazk.now.sh/2020/2020-04-05-nix-liveness</link>
            <guid>https://shnarazk.now.sh/2020/2020-04-05-nix-liveness</guid>
            <pubDate>Sun, 05 Apr 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[昨日、[nixOS](https://nixos.org) に [cadical](https://github.com/arminbiere/cadical) が追加されたけど、それに至るまでは[nixpkgsリポジトリ](https://github.com/NixOS/nixpkgs)のクローンを作って、自分でnix-buildを繰り返していた。
一旦 `nix-build -A cadical` でパッケージを作成するとnix expressionを変更してもartifactのstoreが更新されないことが多い。
調べて nix-storeのdeleteオプションで消せることがわかったけど、実行すると死んでないから削除できないというエラーが出る。`nix-env -e cadical` で削除しても同じエラーになる。

deleteオプションには`--ignore-liveness]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[pre.commit hook for Rust project]]></title>
            <link>https://shnarazk.now.sh/2020/2020-03-27-commit-hook</link>
            <guid>https://shnarazk.now.sh/2020/2020-03-27-commit-hook</guid>
            <pubDate>Fri, 27 Mar 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[commitする前にフォーマットをチェックするための `.git/hooks/pre.commit`。
github gistで拾ったもの。

```shell
#!/bin/bash

diff=$(cargo fmt -- --check)
result=$?

if [[ ${result} -ne 0 ]] ; then
    cat <<\EOF
There are some code style issues, run `cargo fmt` first.
EOF
    exit 1
fi

exit 0
```]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[UNSAT LOG, 2020, Mar.]]></title>
            <link>https://shnarazk.now.sh/2020/2020-03-21-UNSATlog</link>
            <guid>https://shnarazk.now.sh/2020/2020-03-21-UNSATlog</guid>
            <pubDate>Sat, 21 Mar 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[新型コロナウィルスで世間は大変なことになっているけど、確定申告以外はコツコツとSplrの開発を続ける日々。第３号です。

# splr-0.3.1そして0.3.2のリリース
ようやくChoroBTのバグが取れてSplr-0.3.1がリリースできました。いつものベンチマーク設定においても、どうも一つは多く解けるような感じ。そしてこれによって事実上、deep searchモードの引退になりました。開発は一つ階段を登った感じ。ただベンチマークの結果はそれほどよくない。SAT Competitionに出しても参加賞がもらえる程度だなあ。ということで引き続き0.3.2の開発を開始しました。0.3.1ではなんとGlucose流のヒューリスティック選択が有効に働いていない（設定していない項目があった）ので、その修正を始めたら、またこれが時間を取る作業で、ほぼ毎日ベンチマークを取る羽目に。さらにその途中で]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Passing args to StructOpt]]></title>
            <link>https://shnarazk.now.sh/2020/2020-03-19-structopt</link>
            <guid>https://shnarazk.now.sh/2020/2020-03-19-structopt</guid>
            <pubDate>Thu, 19 Mar 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[[SAT-bench](https://github.com/shnarazk/SAT-bench)はRust製SATソルバ
[Splr](https://github.com/shnarazk/splr)のベンチマーク支援Rust製ツールです。
設定を変えてベンチマークを実行するためにSplrへのオプションを受け渡せるように以下のような`Config`になっ
ています。

```rust
#[derive(Clone, Debug, StructOpt)]
#[structopt(name = "sat-bench", about = "A SAT Competition benchmark runner")]
pub struct Config {
    /// the problem
    #[structopt(long = "benchmark", short = "B", ]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Profile Guided Optimization on Rust]]></title>
            <link>https://shnarazk.now.sh/2020/2020-03-16-Profile-Guided-Optimization-on-Rust</link>
            <guid>https://shnarazk.now.sh/2020/2020-03-16-Profile-Guided-Optimization-on-Rust</guid>
            <pubDate>Mon, 16 Mar 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[[The rustc book](https://doc.rust-lang.org/rustc/index.html)に
[profile guided optimization](https://doc.rust-lang.org/rustc/profile-guided-optimization.html)
のわかりやすい説明があったのでSplrでやってみた。

```
DATA=./pgo-data
MERGED=/tmp/merged.profdata

# STEP 0: Make sure there is no left-over profiling data from previous runs
rm -rf ${DATA}
mkdir ${DATA}

# STEP 1: Build the instrumented binaries
RUSTFLAGS="-Cprof]]></content:encoded>
        </item>
    </channel>
</rss>