<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Just a Note</title>
        <link>https://shnarazk.github.io</link>
        <description>a collection of memo</description>
        <lastBuildDate>Fri, 14 Aug 2020 03:33:11 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>nuxtjs/feed</generator>
        <item>
            <title><![CDATA[JUSTANOTE Version 1.0.2]]></title>
            <link>https://shnarazk.github.io/2020/2020-08-14-justanote-102</link>
            <guid>https://shnarazk.github.io/2020/2020-08-14-justanote-102</guid>
            <pubDate>Fri, 14 Aug 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[このブログの静的サイトジェネレータ（名前はまだないとりあえず"JUSTANOTE"にしておきます）をバージョン1.0.2に更新しました。変更点はgithub.comに作ったgistが取り込めるようになったこと。


[Observable](https://observablehq.com/)が（結構）簡単に取り込めたので、1時間程度でできるかと思ったら数日掛かってしまいました。

* githubが埋め込み用に提供するのはjavascriptまたはjson。ちょっとjavascriptは置いといてjsonを使う方向で計画。
* ところがjsonを読み込もうとすると `Cross-Access-Allow-Origin` の制約に引っかかってデータがとって来れない。手動でリロードを掛けて、サーバー側のレンダリングされたページを持ってくれば表示はできるけどかっこ悪い。
* asyncData]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[NixOS on Big Sur]]></title>
            <link>https://shnarazk.github.io/2020/2020-08-07-NixOS-on-BigSur</link>
            <guid>https://shnarazk.github.io/2020/2020-08-07-NixOS-on-BigSur</guid>
            <pubDate>Tue, 11 Aug 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[### Big Sur以前

/etc/synthetic.conf　に

```
nix
```

を追加してmountしていた。

### Big Sur

なんだかmountしてくれないので `/nix` をシンボリックリンクに変更して対応することにした。
そのため、/etc/synthetic.conf を

```
nix	/Volumes/Nix
```
に編集。さらにどこかで

```
export NIX_IGNORE_SYMLINK_STORE=1
```

を実行して、リンクを辿ってくれるようにすればいいようだ。

それにしてもGnomeだなぁ。。。

### 2020-08-09

/usr/lib/system/libcache.dylib がないのでrustプログラムがコンパイルできなくなっている。

Cコンパイラも動かないのでemacs27も作れない。

###]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[UNSAT LOG, 2020, Jul.]]></title>
            <link>https://shnarazk.github.io/2020/2020-07-31-UNSATlog</link>
            <guid>https://shnarazk.github.io/2020/2020-07-31-UNSATlog</guid>
            <pubDate>Fri, 31 Jul 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[# UNSATlog

## 今月のキーワード
* Debugging Vivification
* Restricted Stabilization
* Maximum LBD of Dependency Graph
* Duplicated Bin-clause Checking
* Change of Restart Point

## Vivification update
 先月、実装終わったつもりだったvivification。本当に効果あるのかどうかベンチマークを走らせているはずなんだけども、他のアイデアが出てきたりして、なかなかコードがフィックスしない。そして7月も下旬になってから実はエラーを出していたことが判明しました。Splrでは決定による含意での割り当てはエラーを返さないのが原因なので、割り当てチェックを走らせることで対応します（これでいいはず）。

## 節の重複検]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[What's new in CryptoMiniSat 5.8.0]]></title>
            <link>https://shnarazk.github.io/2020/2020-07-28-whats-new-in-cryptmitsat580</link>
            <guid>https://shnarazk.github.io/2020/2020-07-28-whats-new-in-cryptmitsat580</guid>
            <pubDate>Tue, 28 Jul 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[もう今年のcompetition終わっていた。

https://www.msoos.org/2020/07/cryptominisat-5-8-0-released/

* Guass-Jordan Elimination とは? 変数ペアを作るのだろうか？ XOR制約がわかってないが他のソルバではどうなんだろう
* CaDiCaL風のtarget phase。やはりやる価値があるのか。読み間違えているかなあ。
* Local search solver -- ふーむ、ここはまだ全然手を付けてない

どうも、次に手をつけるべきは、うーむlocal search solverかなあ。]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Swiftのfallthroughについて]]></title>
            <link>https://shnarazk.github.io/2020/2020-07-28-fallthrough-in-swift</link>
            <guid>https://shnarazk.github.io/2020/2020-07-28-fallthrough-in-swift</guid>
            <pubDate>Tue, 28 Jul 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[*The Swift Programming Language -- Swift 5.3 Edition (beta)* を読んでいて、`fallthrough` に関するちょっと信じられない記述を目にした。

> Program execution continues to the next case even if the patterns of the case label do not match the value of the switch statement’s control expression.

playgroundで実行してみた。

```swift
var x = 1

switch x {
    case 1: print(1)
            fallthrough
    case 2: print(2)
    default: break
}
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[まとめて借用]]></title>
            <link>https://shnarazk.github.io/2020/2020-07-25-lifetime-of-trait-object-type</link>
            <guid>https://shnarazk.github.io/2020/2020-07-25-lifetime-of-trait-object-type</guid>
            <pubDate>Wed, 05 Aug 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[オブジェクトからフィールドを借用したい。
借用したいオブジェクトの型がいくつもあり、型ごとに借用したい個数が違うので、できるだけgenericなtrait化が望ましい。
よくわかってないとこの程度のことでもつまづいてしまうのでメモしておく。

### Box

困った時は一旦スタックに持っていく、そのために `Box` を使う、という定石を使ってみるとこうなる。

```rust
pub trait Export<'a, T> {
    fn exports(&'a self) -> Box<T>;
}

impl<'a> Export<'a, (&'a Ema2, &'a Ema2, &'a Ema2, &'a Ema2)> for Restarter {
    fn exports(&'a self) -> Box<(&'a Ema2, &'a Ema2, &'a Ema2, &']]></content:encoded>
        </item>
        <item>
            <title><![CDATA[What's KISSAT]]></title>
            <link>https://shnarazk.github.io/2020/2020-07-21-what-is-kissat</link>
            <guid>https://shnarazk.github.io/2020/2020-07-21-what-is-kissat</guid>
            <pubDate>Tue, 21 Jul 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[SAT Competition 2020の予稿集より。

* 変数のiteratorを使用するようになった
* なんかWatcherのメモリ使用量が減った
* ただしtagつけるので変数のインデックスはCPUアーキテクチャギリギリのビット幅ではなく、28ビットで表現できるところまで減少する。これは約2億7000万変数を意味する。

など。
TBC]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Lives of Clauses]]></title>
            <link>https://shnarazk.github.io/2020/2020-07-18-summer-homework</link>
            <guid>https://shnarazk.github.io/2020/2020-07-18-summer-homework</guid>
            <pubDate>Wed, 12 Aug 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[**cover image: https://unsplash.com/photos/UsSfqYdR64Q**

# イントロとベルリンの壁

論文書くのは仕事じゃない。しかし一年に一度くらいは開発ではなくて、文章をまとめる一ヶ月があってもいいかもね。そもそも今年もCompetitionに出しそびれたし。それに夏といえば、宿題やるのが日本の文化。
9月1日提出に間に合うようになんかしよう。爆音で音楽聴きながらlatex的なことをしよう。

# 2020-07-24

* 旧題: Restart as A Multi-Armed Bandid Problem
* 新題: Lives of Clauses

# 2020-07-27

0.4.2がいい結果を出しそうなので、それをリリースしてから、なぜ0.4.2がいいのかを説明できるようなものにしよう。
"Lives of Clauses"は]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Clause Vivification updated 2020]]></title>
            <link>https://shnarazk.github.io/2020/2020-07-05-vivification2</link>
            <guid>https://shnarazk.github.io/2020/2020-07-05-vivification2</guid>
            <pubDate>Wed, 22 Jul 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[**cover image: https://unsplash.com/photos/tYs9rjaT8Vc**

Vivification についての調査第2弾、2018年投稿2019年公開の論文をまとめてみた。

* Chu-Min Li *et al.*, "Clause vivification by unit propagation in CDCL SAT solvers,”*Artif. Intell.*, vol. 279, 2019.

### Outline

Vivificationは魅力的な節削減手法のでSAT competitionに提出されるようなソルバに導入されたもの、その後改善が計算量に見合わないため、取り下げられることが続いてきた。
この論文はどのタイミングで、どの節を、どのリテラルからvivifyすればよいかについて論じている。
特に[原論文](/2020]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[UNSAT LOG, 2020, Jun.]]></title>
            <link>https://shnarazk.github.io/2020/2020-07-05-UNSATlog</link>
            <guid>https://shnarazk.github.io/2020/2020-07-05-UNSATlog</guid>
            <pubDate>Sun, 05 Jul 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[# 6月の総括

先月、性能良くなってきたのでなんとかかんとかと書いたのですが、実はGlucose 4.1よりも全然改善されてないことがわかったので、前言撤回。どうしたものか半分途方にくれた6月でした。
後半は気を取り直して、[vivificationの実装](https://shnarazk.github.io/2020/2020-06-20-vivification/)に取り組みました。

# Vivification

読んだのは2008年の論文。

* C. Piette, Y. Hamadi, and L. Saïs, "Vivifying propositional clausal formulae," *Front. Artif. Intell. Appl.*, vol. 178, pp. 525–529, 2008.

短い論文だったし、アルゴリズムもそれほど難しいものでは]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Duplicate Learnt Clauses]]></title>
            <link>https://shnarazk.github.io/2020/2020-06-22-duplicate-learnt-clause</link>
            <guid>https://shnarazk.github.io/2020/2020-06-22-duplicate-learnt-clause</guid>
            <pubDate>Tue, 23 Jun 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[Google Scholar alert 発令。今日のお題は「重複した学習節による速度向上」！？

* S. Kochemazov, O. Zaikin, A. Semenov, and V. Kondratiev, "Speeding Up CDCL Inference With Duplicate Learnt Clauses," *24th European Conference on Artificial Intelligence - ECAI2020*, 2020.

duplicateは複数持つのではなく何度でも現れるという意味だ。
そのような節を削除せずに保持することで求解数が向上する（そういう問題セットが存在する）とのこと。
論文ではHash表を使って再出現を検知しようとしているようだ。
LBDによる層化は必ずしも正しいとは限らないと。

変数に比べ節の尺度はそれほど注意が]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Vivification of a CNF formula]]></title>
            <link>https://shnarazk.github.io/2020/2020-06-20-vivification</link>
            <guid>https://shnarazk.github.io/2020/2020-06-20-vivification</guid>
            <pubDate>Sun, 05 Jul 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[Vivification がなんなのか、日本語で探しても出てこないので以下の論文をまとめてみた。
（最新の話かと思っていたけど2008年とは。。。）

* C. Piette, Y. Hamadi, and L. Saïs, "Vivifying propositional clausal formulae,” *Front. Artif. Intell*. Appl., vol. 178, pp. 525–529, 2008.

Splr でいうところの `processor` が節数に対する制約内での網羅的な変数除去と節包摂(clause subsumption)とを実行するのに対し、vivification は（その節に「対応」する割り当てを仮定して）propagateを行った結果を用いて節の包摂方針を決めるというもの。
節長を減らす方向でのみ置換するので、（節数の増加と引き換えに）]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[井上ひさし、四千万歩の男]]></title>
            <link>https://shnarazk.github.io/2020/2020-06-19-40M-steps</link>
            <guid>https://shnarazk.github.io/2020/2020-06-19-40M-steps</guid>
            <pubDate>Fri, 19 Jun 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[題材が今ひとつ興味が持てなくて、しかしベストセラーになっていたので、時間ができたら読もうと思っていた
井上ひさしの長編小説「四千万歩の男」。
ようやく読了。

なんと、

* 未完！四百万歩くらいで終わった。単行本が出てから作者が亡くなるまで随分と時間があったはずなのでもう当然完結したストーリーだと思っていたのだが。。。
* 「小説」であった。同時代の有名人が毎回登場して絡んでいく。なんか早坂暁の「天下御免」を思い出した。
* なので伊能忠敬に関するドラマ化というよりも、アイヌ問題とか、農民の困窮生活とか、学閥間の争いとか、御家騒動とか、大名間の闘争とか、ドロドロした話が一話完結的に展開していく。
* 主人公が百姓上がりということから、特にその時代の百姓の生活が色々と描かれている。そういう時代を舞台にしたものは米村圭伍、岡本綺堂、半村良、NHK土曜時代劇くらいしか読んだ（り見たりした）こと]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Clap-3.0.0-beta.1]]></title>
            <link>https://shnarazk.github.io/2020/2020-06-13-clap3</link>
            <guid>https://shnarazk.github.io/2020/2020-06-13-clap3</guid>
            <pubDate>Sat, 13 Jun 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[[Clap](https://crates.io/crates/clap)-3.0だと[StructOpt](https://crates.io/crates/structopt)が要らなくなるのでclap-3.0.0-beta.1をちょっと試してみた。

### 1. PathBufの取扱いの違い

StructOptでは問題なくオプションになる以下のフィールドは、

```rust
   #[structopt(long = "result", default_value = "", parse(from_os_str))]
   pub result: PathBuf,
```

Clapでは引数が指定されてないエラーを起こしてしまう。
default_valueを空以外にすれば直るのだが、それは困る、Optionでくるむことにした：

```rust
    #[clap(long]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[How to compile cargo-instruments]]></title>
            <link>https://shnarazk.github.io/2020/2020-06-07-cargo-instruments</link>
            <guid>https://shnarazk.github.io/2020/2020-06-07-cargo-instruments</guid>
            <pubDate>Sun, 07 Jun 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[## Rustでプロファイリングしたいんじゃあ

valgrindは動くけど、perfはない、massive-visualizerもない。
Linuxに比べてmacOSはRustのプロファイリングが不自由だなあ。
それでも、まともなLinuxマシンが手元にないのでなんとかmac上でプロファイリングしなければならない。
何かインストールしなければ。
いくつか調べてみて（そもそも検索でヒットするページが意外なほど少ないのだけど）[cargo-instruments](https://crates.io/crates/cargo-instruments)というのがよさそうだということがわかりました。
残念だけど、opensshのバージョン問題で単に`cargo install`とするだけではコンパイルできないようです。
brewを使っているのが前提になっているのだろうか。
うーん、これはいつもの]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[UNSAT LOG, 2020, May.]]></title>
            <link>https://shnarazk.github.io/2020/2020-05-29-UNSATlog</link>
            <guid>https://shnarazk.github.io/2020/2020-05-29-UNSATlog</guid>
            <pubDate>Fri, 29 May 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[## Splr-0.4.1リリースの5月
今月たてたissue及びブランチは以下の通り：

* No restart for LR and Stabilization
* 20200514-incremental
* 20200524-handle
* 20200502-new-select
* 20200503-litpointer-on-0.3.1
* 20200509-new-rephrase
* 20200510-restart-for-lr
* 20200514-incremental
* 20200516-no-restart
* 20200518-tuning
* 20200524-dead
* 20200524-handle

Splr-0.4.0以降の分をまとめると

* incremental SATソルバの実装
* stabilizationの解釈と変数選択機構の実装]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[What's Miracle Sudoku?]]></title>
            <link>https://shnarazk.github.io/2020/2020-05-26-MiracleSudoku</link>
            <guid>https://shnarazk.github.io/2020/2020-05-26-MiracleSudoku</guid>
            <pubDate>Mon, 01 Jun 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[25日のHacker Newsで初めて知ったMiracle Sudoku。[ビデオ](https://www.youtube.com/watch?v=cvEq_XkQg8U)の横に書いてあることから判断するに

* Normal Sudoku rules apply.
* ナイトまたはキングが1hopで行ける場所には同じ数は置けない: Any two cells separated by a knight's move or a king's move (in chess) cannot contain the same digit.
* 近接した4近傍には連続する数列は置けない: Any two orthogonally adjacent cells cannot contain consecutive digits.

さあSATソルバの出番。

# 2020-05-30 mokumo]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[LR needs something to explore the world]]></title>
            <link>https://shnarazk.github.io/2020/2020-05-20-LR-needs-something</link>
            <guid>https://shnarazk.github.io/2020/2020-05-20-LR-needs-something</guid>
            <pubDate>Thu, 21 May 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[引き続きよくわかってない人の意見の連投ですが。

## LRのリスタート問題

LR はよさそうなんだけども、そんなにいいならリスタートの立場はどうなる？
矛盾発生率の最適化を達成していて何故リスタートが必要になるのだろうか。

しかし何かそのようなものが必要なことはすぐわかる。
以前も書いたような気がするがリスタートはリスタートであって、決してリセットではないのだ。
EVSIDS も含めた変数選択ヒューリスティックスは割当て後にその使われた変数に値を割り当てるもので、使われてない変数に脚光を当てるものではない。
従って、リスタートを掛けても優先度が高い変数間の順序が変わるだけと書いてもそれほど言い過ぎというわけではないだろう。
もちろん順序を入れ替えることによってリスタート後の伝播の方向がこれまでと違う方向へと向かうことはあるけども、いきなり極端に違う変数が選ばれるものではない（という去]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[What's the difference between EVSIDS and LR?]]></title>
            <link>https://shnarazk.github.io/2020/2020-05-19-two-heuristics</link>
            <guid>https://shnarazk.github.io/2020/2020-05-19-two-heuristics</guid>
            <pubDate>Tue, 19 May 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[よくわかってない人の意見ですが。

最近のSATソルバの注目すべきアイデアの一つにLearning Rate (+ Reason-Side) Rewardingがある。
長らく続いてきたEVSIDS一強時代に対抗できる成果を残している。と言っても完全に上回るのではなく
「タイムアウトを長くした」場合という限定詞付きではあるが、それでも注目すべき技術だろう。
というわけで最近のSplrでもfeatureで切り替えられるようにした。

LRのよさはなんとなくわかる。LRのアイデアは学習率の最適化により矛盾発生頻度を最大化しようとするものである[1]。

> In particular, we model the variable selection optimization problem as an online multi-armed bandit, a special-case of r]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[What's 's-l'?]]></title>
            <link>https://shnarazk.github.io/2020/2020-05-09-Emacs-keybind-s-l</link>
            <guid>https://shnarazk.github.io/2020/2020-05-09-Emacs-keybind-s-l</guid>
            <pubDate>Sat, 09 May 2020 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[[lsp-mode](https://github.com/emacs-lsp/lsp-mode)がプレフィックスとして採用している'`s-l`'とは一体なんなんだ？

'`s`'は`Super`かとも思うのだがだったら大文字ではないのか？　いや、それなら`Shift`になる。。。
`Super`のつもりで`Option`キーを押してみても反応ない。。。

ググってわかった。やはり`Super`だった。macのコンソールに入力できてないだけだった。
と思ったらちゃんと入力方法が用意してあった(https://emacs.stackexchange.com/questions/55199/what-are-these-prefix-commands-that-start-with-s-l)。

> You can simulate these additional keys with som]]></content:encoded>
        </item>
    </channel>
</rss>