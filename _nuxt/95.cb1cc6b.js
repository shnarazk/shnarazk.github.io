(window.webpackJsonp=window.webpackJsonp||[]).push([[95],{572:function(n){n.exports=JSON.parse('{"title":"RustのClone on Writeについて","subtitle":"std::borrow::cow","date":"2020-08-15T00:00:00.000Z","tag":["Rust"],"bodyContent":"自転車本では紹介されてないけれど、Rustならでは必要とされる面白い型、Copy on Writeではなくて、Clone on Writeを意味する`std::borrow::Cow`の紹介です。\\n\\n## 前提知識：`str` と `String`の違い\\n\\n* `str` -- （固定長の）UTF-8文字のスライス\\n* `&str` -- UTF-8文字のスライスへのポインタ\\n* `String` -- ヒープ上に置かれた、追加を含めた変更ができる文字列\\n\\n\\n## 前提知識：文字列定数とその参照\\n\\n#### ローカル変数\\n\\nまず、以下のように関数内のローカルデータとして確保された文字列定数を参照する変数は何型でしょうか。\\n\\n```rust\\nfn f() {\\n  let s = \\"a fixed string\\";\\n  ...\\n```\\n\\nこれは `&str` です。\\n\\n```rust\\nfn f() {\\n  let s: &str = \\"a fixed string\\";\\n  ...\\n```\\n\\n* `\\"a fixed string\\"`はローカル変数なのでヒープに置く必要はありません。\\n* `str`は通常Rustのプログラムには出て来ない。変数`s`はその確保された領域を指すように片付けられます。\\n\\n#### グローバル変数\\n\\nでは`s`がグローバル変数`S`になるとどうなるでしょう。\\n\\n```rust\\nconst S: ??? = \\"a fixed string\\";\\n```\\n\\nグローバル変数も他の言語同様にヒープではなくOSで言うところのデータ領域に置かれるのでやはり`str`であり、\\nその領域を指すので変数`S` は`&str`型になります。\\n\\n## 前提知識：`str`と`String`間の変換\\n\\n### `&str`から`String`へ\\n\\n`&str`型の変数があればその指している対象から`to_string`メソッドを使ってStringを作ることができます。\\n\\n```rust\\nfn f() {\\n  let s: &str = \\"A fixed string\\" \\n  let t = s.to_string();     // ヒープ操作を必要とする\\n  ...\\n```\\n\\nこの時tの実体はヒープ上に置かれたfat pointerです。固定長なのでメモリを大きく消費するわけではありませんが、実体を正しく指すポインタを含む構造体をヒープ上に構成する必要があります。\\n\\n### `String`から`&str`へ\\n\\n逆の操作は`as_str()`です。この操作は`String`を構成するfat pointerの一部を参照すればいいので極めて軽量です。\\nこれは`&srt`から`String`への変換が`to_*`系なのに対し、`String`から`&str`への変換が`as_*`系の命名になっていることからもわかります。\\n\\n```rust\\nfn f() {\\n  let s: String = \\"A fixed string\\".to_string();\\n  let t: &str = s.as_str();    // 軽量な操作\\n  ...\\n```\\n\\nここまでが前提知識でした。\\n\\n# 問題となるシナリオ: `&str` と `String` の混在","bodyHtml":"<p>自転車本では紹介されてないけれど、Rustならでは必要とされる面白い型、Copy on Writeではなくて、Clone on Writeを意味する<code>std::borrow::Cow</code>の紹介です。</p>\\n<h2>前提知識：<code>str</code> と <code>String</code>の違い</h2>\\n<ul>\\n<li><code>str</code> -- （固定長の）UTF-8文字のスライス</li>\\n<li><code>&amp;str</code> -- UTF-8文字のスライスへのポインタ</li>\\n<li><code>String</code> -- ヒープ上に置かれた、追加を含めた変更ができる文字列</li>\\n</ul>\\n<h2>前提知識：文字列定数とその参照</h2>\\n<h4>ローカル変数</h4>\\n<p>まず、以下のように関数内のローカルデータとして確保された文字列定数を参照する変数は何型でしょうか。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">fn</span> <span class=\\"hljs-title\\">f</span></span>() {\\n  <span class=\\"hljs-keyword\\">let</span> s = <span class=\\"hljs-string\\">\\"a fixed string\\"</span>;\\n  ...</code></pre><p>これは <code>&amp;str</code> です。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">fn</span> <span class=\\"hljs-title\\">f</span></span>() {\\n  <span class=\\"hljs-keyword\\">let</span> s: &amp;<span class=\\"hljs-built_in\\">str</span> = <span class=\\"hljs-string\\">\\"a fixed string\\"</span>;\\n  ...</code></pre><ul>\\n<li><code>&quot;a fixed string&quot;</code>はローカル変数なのでヒープに置く必要はありません。</li>\\n<li><code>str</code>は通常Rustのプログラムには出て来ない。変数<code>s</code>はその確保された領域を指すように片付けられます。</li>\\n</ul>\\n<h4>グローバル変数</h4>\\n<p>では<code>s</code>がグローバル変数<code>S</code>になるとどうなるでしょう。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-keyword\\">const</span> S: ??? = <span class=\\"hljs-string\\">\\"a fixed string\\"</span>;</code></pre><p>グローバル変数も他の言語同様にヒープではなくOSで言うところのデータ領域に置かれるのでやはり<code>str</code>であり、\\nその領域を指すので変数<code>S</code> は<code>&amp;str</code>型になります。</p>\\n<h2>前提知識：<code>str</code>と<code>String</code>間の変換</h2>\\n<h3><code>&amp;str</code>から<code>String</code>へ</h3>\\n<p><code>&amp;str</code>型の変数があればその指している対象から<code>to_string</code>メソッドを使ってStringを作ることができます。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">fn</span> <span class=\\"hljs-title\\">f</span></span>() {\\n  <span class=\\"hljs-keyword\\">let</span> s: &amp;<span class=\\"hljs-built_in\\">str</span> = <span class=\\"hljs-string\\">\\"A fixed string\\"</span> \\n  <span class=\\"hljs-keyword\\">let</span> t = s.to_string();     <span class=\\"hljs-comment\\">// ヒープ操作を必要とする</span>\\n  ...</code></pre><p>この時tの実体はヒープ上に置かれたfat pointerです。固定長なのでメモリを大きく消費するわけではありませんが、実体を正しく指すポインタを含む構造体をヒープ上に構成する必要があります。</p>\\n<h3><code>String</code>から<code>&amp;str</code>へ</h3>\\n<p>逆の操作は<code>as_str()</code>です。この操作は<code>String</code>を構成するfat pointerの一部を参照すればいいので極めて軽量です。\\nこれは<code>&amp;srt</code>から<code>String</code>への変換が<code>to_*</code>系なのに対し、<code>String</code>から<code>&amp;str</code>への変換が<code>as_*</code>系の命名になっていることからもわかります。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">fn</span> <span class=\\"hljs-title\\">f</span></span>() {\\n  <span class=\\"hljs-keyword\\">let</span> s: <span class=\\"hljs-built_in\\">String</span> = <span class=\\"hljs-string\\">\\"A fixed string\\"</span>.to_string();\\n  <span class=\\"hljs-keyword\\">let</span> t: &amp;<span class=\\"hljs-built_in\\">str</span> = s.as_str();    <span class=\\"hljs-comment\\">// 軽量な操作</span>\\n  ...</code></pre><p>ここまでが前提知識でした。</p>\\n<h1>問題となるシナリオ: <code>&amp;str</code> と <code>String</code> の混在</h1>\\n","dir":"article/.json/2020","base":"2020-08-15-Cow.json","ext":".json","sourceBase":"2020-08-15-Cow.md","sourceExt":".md"}')}}]);