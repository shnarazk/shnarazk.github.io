(window.webpackJsonp=window.webpackJsonp||[]).push([[83],{555:function(n){n.exports=JSON.parse('{"title":"Vivification","subtitle":"a CNF preprocessor","date":"2020-06-20T00:00:00.000Z","tags":["SAT"],"bodyContent":"Vivification がなんなのか、日本語で探しても出てこないので以下をまとめる。\\n（最新の話かと思っていたけど2008年とは。。。）\\n\\n* C. Piette, Y. Hamadi, and L. Saïs, \\"Vivifying propositional clausal formulae,” *Front. Artif. Intell*. Appl., vol. 178, pp. 525–529, 2008.\\n\\nSplrでいうところの、現在のprocessorが網羅的に節数に対する制約内での全ての変数除去、節包摂(clause subsumption)を実行するのに対し、vivificationは（その節に「対応」する割り当てを仮定して）propagateを行った結果を用いて節の包摂方針を決めるというもの。\\nその分、不要な複雑さの導入を抑えることができるらしい。\\n\\n何も考えずにRustで書いてみるとこんな感じ。\\n\\n```rust\\n/// Vivification of a given CNF formula, returning a vivified CNF formula\\n/// ## Note\\n/// `remove` used here is a non-destructive function (`Fn<T>([T]) -> Vec<T>`).\\nfn vivify(mut sigma: CNF) -> CNF {\\n    let mut testing_cnf;\\n    let mut change: bool = true;\\n    let mut shortened: bool = true;\\n    let mut cb: Vec<Lit> = Vec::new();\\n    while change {\\n        change = false;\\n        for c in sigma {\\n            testing_cnf = sigma.clone();\\n            sigma = sigma.remove(c);\\n            cb.clear();\\n            shortened = false;\\n            while !shortened && c != cb {\\n                l = select_literal(c.remove(cb));\\n                cb.push(l);                               // cb = cb ∪ {l};\\n                testing_cnf.push(vec![!l]);               // Σb ← (Σb ∪ {¬l})\\n                let ls = testing_cnf.propagate();         // returns the conflicting literal\\n                if ls == NULL_CID {                       // ⊥ ∈ UP(Σb)\\n                    cl = conflict_analyze();              // returns a learnt clause\\n                    if c.is_subsumeable(cl) {             // cl ⊂ c\\n                        sigma.push(cl);                   // Σ ← Σ ∪ {cl}\\n                        shortened = true;\\n                    } else {\\n\\t\\t\\tif cl.len() == c.len() {\\n                            sigma.push(cl);               // Σ ←− Σ ∪ { cl }\\n                            cb = c;\\n                        }\\n                        if c != cb {\\n                            sigma.push(cb);               // Σ ← Σ ∪ {cb}\\n                            shortened = true;\\n                        }\\n                    }\\n                } else {\\n                    if c.remove_items(cb).includes(ls) {  // ∃(ls ∈ (c\\\\cb))\\n                        if c.remove(cb) != vec![ls] {     // (c\\\\cb) /= {ls}\\n                            sigma.push(cb.push(ls));      // Σ ← Σ ∪ {cb ∪ {ls}} ;\\n                            shortened = true;\\n                        }\\n                    }\\n                    if c.remove_items(cb).includes(!ls) { // ∃(¬ls ∈ (c\\\\cb))\\n                        sigma.push(c.remove(ls));         // Σ ← Σ ∪ {c\\\\{ls}}\\n                        shortened = true;\\n                    }\\n                }\\n                if !shortened {\\n                    sigma.push(c);                        // Σ ← Σ ∪ {c} ;\\n                } else {\\n                    change = true;\\n                }\\n            }\\n        }\\n    }\\n    return sigma;\\n}\\n```\\n\\nつまり\\n\\n```rust\\nfn vivify(mut sigma: CNF) -> CNF {\\n    let mut testing_cnf;\\n    let mut change: bool = true;          // 変化したかどうか\\n    let mut shortened: bool = true;       // 節cを短い節で置き換えできたかどうか\\n    let mut cb: Vec<Lit> = Vec::new();    // 節cの中で処理した部分\\n    while 不動点になるまで\\n        for sigma中の全ての節cに対して\\n            現在のsigmaのコピーをtesting_cnfとする\\n            sigmaからcを削除する\\n            cb.clear();\\n            shortened = false;\\n            while !shortened && c != cb                   // == until shorten || c == cb { .. }\\n                c\\\\cbから適当に選んだリテラルlを割り当ててみて伝播させる\\n                cbにlを追加する\\n                if 矛盾してないなら\\n                    その学習節をclとする\\n                    if 学習節clが元々の節cを包摂するなら\\n                        clをsigmaに追加; shortened = true;\\n                    else \\n\\t\\t\\tif cとclが同じ長さなら\\n                            clをsigmaに追加; cb = c;      // これは終了条件, cは後でsigmaに追加される\\n                        if c != cb   　　　               // ここが\\n                            sigma.push(cb);              // わからん\\n                            shortened = true;\\n                else\\n                    if cの残り(c.remove(cb))が ls を含むなら\\n                        if cの残りが単位節{ls}になっていたら\\n                            単位節{ls}を sigma に追加; shortened = true;\\n                    if cの残り(c.remove(cb))が !ls を含むなら\\n　　　　　　　　　　　     cからリテラルlsを除いて、sigma に追加; shortened = true;\\n                if !shorted\\n                    sigma.push(c);\\n                else\\n                    change = true;\\n    return sigma;\\n}\\n```\\n\\nうーむ、実装してみなくては。","bodyHtml":"<p>Vivification がなんなのか、日本語で探しても出てこないので以下をまとめる。\\n（最新の話かと思っていたけど2008年とは。。。）</p>\\n<ul>\\n<li>C. Piette, Y. Hamadi, and L. Saïs, &quot;Vivifying propositional clausal formulae,” <em>Front. Artif. Intell</em>. Appl., vol. 178, pp. 525–529, 2008.</li>\\n</ul>\\n<p>Splrでいうところの、現在のprocessorが網羅的に節数に対する制約内での全ての変数除去、節包摂(clause subsumption)を実行するのに対し、vivificationは（その節に「対応」する割り当てを仮定して）propagateを行った結果を用いて節の包摂方針を決めるというもの。\\nその分、不要な複雑さの導入を抑えることができるらしい。</p>\\n<p>何も考えずにRustで書いてみるとこんな感じ。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-comment\\">/// Vivification of a given CNF formula, returning a vivified CNF formula</span>\\n<span class=\\"hljs-comment\\">/// ## Note</span>\\n<span class=\\"hljs-comment\\">/// `remove` used here is a non-destructive function (`Fn&lt;T&gt;([T]) -&gt; Vec&lt;T&gt;`).</span>\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">fn</span> <span class=\\"hljs-title\\">vivify</span></span>(<span class=\\"hljs-keyword\\">mut</span> sigma: CNF) -&gt; CNF {\\n    <span class=\\"hljs-keyword\\">let</span> <span class=\\"hljs-keyword\\">mut</span> testing_cnf;\\n    <span class=\\"hljs-keyword\\">let</span> <span class=\\"hljs-keyword\\">mut</span> change: <span class=\\"hljs-built_in\\">bool</span> = <span class=\\"hljs-literal\\">true</span>;\\n    <span class=\\"hljs-keyword\\">let</span> <span class=\\"hljs-keyword\\">mut</span> shortened: <span class=\\"hljs-built_in\\">bool</span> = <span class=\\"hljs-literal\\">true</span>;\\n    <span class=\\"hljs-keyword\\">let</span> <span class=\\"hljs-keyword\\">mut</span> cb: <span class=\\"hljs-built_in\\">Vec</span>&lt;Lit&gt; = <span class=\\"hljs-built_in\\">Vec</span>::new();\\n    <span class=\\"hljs-keyword\\">while</span> change {\\n        change = <span class=\\"hljs-literal\\">false</span>;\\n        <span class=\\"hljs-keyword\\">for</span> c <span class=\\"hljs-keyword\\">in</span> sigma {\\n            testing_cnf = sigma.clone();\\n            sigma = sigma.remove(c);\\n            cb.clear();\\n            shortened = <span class=\\"hljs-literal\\">false</span>;\\n            <span class=\\"hljs-keyword\\">while</span> !shortened &amp;&amp; c != cb {\\n                l = select_literal(c.remove(cb));\\n                cb.push(l);                               <span class=\\"hljs-comment\\">// cb = cb ∪ {l};</span>\\n                testing_cnf.push(<span class=\\"hljs-built_in\\">vec!</span>[!l]);               <span class=\\"hljs-comment\\">// Σb ← (Σb ∪ {¬l})</span>\\n                <span class=\\"hljs-keyword\\">let</span> ls = testing_cnf.propagate();         <span class=\\"hljs-comment\\">// returns the conflicting literal</span>\\n                <span class=\\"hljs-keyword\\">if</span> ls == NULL_CID {                       <span class=\\"hljs-comment\\">// ⊥ ∈ UP(Σb)</span>\\n                    cl = conflict_analyze();              <span class=\\"hljs-comment\\">// returns a learnt clause</span>\\n                    <span class=\\"hljs-keyword\\">if</span> c.is_subsumeable(cl) {             <span class=\\"hljs-comment\\">// cl ⊂ c</span>\\n                        sigma.push(cl);                   <span class=\\"hljs-comment\\">// Σ ← Σ ∪ {cl}</span>\\n                        shortened = <span class=\\"hljs-literal\\">true</span>;\\n                    } <span class=\\"hljs-keyword\\">else</span> {\\n\\t\\t\\t<span class=\\"hljs-keyword\\">if</span> cl.len() == c.len() {\\n                            sigma.push(cl);               <span class=\\"hljs-comment\\">// Σ ←− Σ ∪ { cl }</span>\\n                            cb = c;\\n                        }\\n                        <span class=\\"hljs-keyword\\">if</span> c != cb {\\n                            sigma.push(cb);               <span class=\\"hljs-comment\\">// Σ ← Σ ∪ {cb}</span>\\n                            shortened = <span class=\\"hljs-literal\\">true</span>;\\n                        }\\n                    }\\n                } <span class=\\"hljs-keyword\\">else</span> {\\n                    <span class=\\"hljs-keyword\\">if</span> c.remove_items(cb).includes(ls) {  <span class=\\"hljs-comment\\">// ∃(ls ∈ (c\\\\cb))</span>\\n                        <span class=\\"hljs-keyword\\">if</span> c.remove(cb) != <span class=\\"hljs-built_in\\">vec!</span>[ls] {     <span class=\\"hljs-comment\\">// (c\\\\cb) /= {ls}</span>\\n                            sigma.push(cb.push(ls));      <span class=\\"hljs-comment\\">// Σ ← Σ ∪ {cb ∪ {ls}} ;</span>\\n                            shortened = <span class=\\"hljs-literal\\">true</span>;\\n                        }\\n                    }\\n                    <span class=\\"hljs-keyword\\">if</span> c.remove_items(cb).includes(!ls) { <span class=\\"hljs-comment\\">// ∃(¬ls ∈ (c\\\\cb))</span>\\n                        sigma.push(c.remove(ls));         <span class=\\"hljs-comment\\">// Σ ← Σ ∪ {c\\\\{ls}}</span>\\n                        shortened = <span class=\\"hljs-literal\\">true</span>;\\n                    }\\n                }\\n                <span class=\\"hljs-keyword\\">if</span> !shortened {\\n                    sigma.push(c);                        <span class=\\"hljs-comment\\">// Σ ← Σ ∪ {c} ;</span>\\n                } <span class=\\"hljs-keyword\\">else</span> {\\n                    change = <span class=\\"hljs-literal\\">true</span>;\\n                }\\n            }\\n        }\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> sigma;\\n}</code></pre><p>つまり</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">fn</span> <span class=\\"hljs-title\\">vivify</span></span>(<span class=\\"hljs-keyword\\">mut</span> sigma: CNF) -&gt; CNF {\\n    <span class=\\"hljs-keyword\\">let</span> <span class=\\"hljs-keyword\\">mut</span> testing_cnf;\\n    <span class=\\"hljs-keyword\\">let</span> <span class=\\"hljs-keyword\\">mut</span> change: <span class=\\"hljs-built_in\\">bool</span> = <span class=\\"hljs-literal\\">true</span>;          <span class=\\"hljs-comment\\">// 変化したかどうか</span>\\n    <span class=\\"hljs-keyword\\">let</span> <span class=\\"hljs-keyword\\">mut</span> shortened: <span class=\\"hljs-built_in\\">bool</span> = <span class=\\"hljs-literal\\">true</span>;       <span class=\\"hljs-comment\\">// 節cを短い節で置き換えできたかどうか</span>\\n    <span class=\\"hljs-keyword\\">let</span> <span class=\\"hljs-keyword\\">mut</span> cb: <span class=\\"hljs-built_in\\">Vec</span>&lt;Lit&gt; = <span class=\\"hljs-built_in\\">Vec</span>::new();    <span class=\\"hljs-comment\\">// 節cの中で処理した部分</span>\\n    <span class=\\"hljs-keyword\\">while</span> 不動点になるまで\\n        <span class=\\"hljs-keyword\\">for</span> sigma中の全ての節cに対して\\n            現在のsigmaのコピーをtesting_cnfとする\\n            sigmaからcを削除する\\n            cb.clear();\\n            shortened = <span class=\\"hljs-literal\\">false</span>;\\n            <span class=\\"hljs-keyword\\">while</span> !shortened &amp;&amp; c != cb                   <span class=\\"hljs-comment\\">// == until shorten || c == cb { .. }</span>\\n                c\\\\cbから適当に選んだリテラルlを割り当ててみて伝播させる\\n                cbにlを追加する\\n                <span class=\\"hljs-keyword\\">if</span> 矛盾してないなら\\n                    その学習節をclとする\\n                    <span class=\\"hljs-keyword\\">if</span> 学習節clが元々の節cを包摂するなら\\n                        clをsigmaに追加; shortened = <span class=\\"hljs-literal\\">true</span>;\\n                    <span class=\\"hljs-keyword\\">else</span> \\n\\t\\t\\t<span class=\\"hljs-keyword\\">if</span> cとclが同じ長さなら\\n                            clをsigmaに追加; cb = c;      <span class=\\"hljs-comment\\">// これは終了条件, cは後でsigmaに追加される</span>\\n                        <span class=\\"hljs-keyword\\">if</span> c != cb   　　　               <span class=\\"hljs-comment\\">// ここが</span>\\n                            sigma.push(cb);              <span class=\\"hljs-comment\\">// わからん</span>\\n                            shortened = <span class=\\"hljs-literal\\">true</span>;\\n                <span class=\\"hljs-keyword\\">else</span>\\n                    <span class=\\"hljs-keyword\\">if</span> cの残り(c.remove(cb))が ls を含むなら\\n                        <span class=\\"hljs-keyword\\">if</span> cの残りが単位節{ls}になっていたら\\n                            単位節{ls}を sigma に追加; shortened = <span class=\\"hljs-literal\\">true</span>;\\n                    <span class=\\"hljs-keyword\\">if</span> cの残り(c.remove(cb))が !ls を含むなら\\n　　　　　　　　　　　     cからリテラルlsを除いて、sigma に追加; shortened = <span class=\\"hljs-literal\\">true</span>;\\n                <span class=\\"hljs-keyword\\">if</span> !shorted\\n                    sigma.push(c);\\n                <span class=\\"hljs-keyword\\">else</span>\\n                    change = <span class=\\"hljs-literal\\">true</span>;\\n    <span class=\\"hljs-keyword\\">return</span> sigma;\\n}</code></pre><p>うーむ、実装してみなくては。</p>\\n","dir":"article/.json/2020","base":"2020-06-20-vivification.json","ext":".json","sourceBase":"2020-06-20-vivification.md","sourceExt":".md"}')}}]);