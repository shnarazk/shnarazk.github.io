(window.webpackJsonp=window.webpackJsonp||[]).push([[86],{559:function(n){n.exports=JSON.parse('{"title":"Clause Vivification updated 2020","subtitle":"vivification part 2","date":"2020-07-05T00:00:00.000Z","tags":["SAT","vivification","splr"],"banner":"https://images.unsplash.com/photo-1586508217007-6e8b3151a6f2?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1950&q=80","bodyContent":"cover image: https://unsplash.com/photos/tYs9rjaT8Vc\\n\\nVivification についての第2弾、2018年投稿2020年公開（？）の論文をまとめてみた。\\n\\n* Chu-Min Li *et al.*, \\"Clause vivification by unit propagation in CDCL SAT solvers,”*Artif. Intell.*, vol. 279, 2020.\\n\\n### Outline\\n\\n主な主張はどのタイミングで、どの節を、どのリテラルからvivifyするかについて。\\n以前のvivificationは計算量の問題によりSAT competitionに提出されたソルバに導入されてもその後、削除されてきた歴史が語られている。\\nさらに以下のようにin-processor向けに `vivify` のアルゴリズムが変更されている。\\n\\n![](/img/2020/07-05/vivi-algo3.jpg)\\n\\n* 何にせよ最初に存在した節は17行目で必ず削除される。\\n* 17行目は一つ内側のループに含まれるはずですけど。\\n\\n### Splr approach\\n\\n```rust\\npub fn vivify(asg: &mut AssignStack, cdb: &mut ClauseDB, state: &mut State) {\\n    \'next_clause: for ci in clauses.iter() {\\n        let c: &Clause = &cdb[ci];\\n        if c.is(Flag::DEAD) {\\n            continue;\\n        }\\n        let mut v: Vec<Lit> = Vec::new();\\n        let mut vivified: Vec<Lit> = Vec::new();\\n        for (_i, l) in c.lits.clone().iter().enumerate() {\\n            match asg.assigned(*l) {\\n                Some(true) => continue \'next_clause,\\n                Some(false) => v.push(!*l),                 // Rule 4\\n                None => {\\n                    let cid: Option<ClauseId> = match v.len() {\\n                        0 => None,\\n                        1 => { asg.assign_by_decision(v[0]); None }\\n                        _ => Some(cdb.new_clause(asg, &mut v.clone(), false, false)), // L.12\\n                    };\\n                    asg.assign_by_decision(!*l);\\n                    let confl = asg.propagate(cdb);\\n                    if confl != ClauseId::default() {\\n                        vivified = asg.remove_redundant(cdb, &v, &cdb[confl].lits); // Rule 3\\n                    }\\n                    if let Some(cj) = cid {\\n                        cdb.remove_clause(cj);\\n                    }\\n                    asg.cancel_until_sandbox(asg.root_level);\\n                    if confl == ClauseId::default() {\\n                        break;\\n                    }\\n                    v.push(!*l);\\n                }\\n            }\\n        }\\n        if vivified.is_empty() {\\n            for l in &mut v {\\n                *l = !*l;\\n            }\\n            std::mem::swap(&mut vivified, &mut v);\\n        }\\n        match vivified.len() {\\n            0 => break \'next_clause,\\n            1 => {\\n                asg.assign_at_rootlevel(vivified[0]).expect(\\"impossible\\");\\n                assert!(asg.propagate(cdb) == ClauseId::default(), \\"UNSAT\\");\\n            }\\n            _ => cdb.new_clause(asg, &mut vivified),\\n        }\\n        cdb.detach(*ci);\\n        cdb.garbage_collect();\\n    }\\n}\\n```","bodyHtml":"<p>cover image: https://unsplash.com/photos/tYs9rjaT8Vc</p>\\n<p>Vivification についての第2弾、2018年投稿2020年公開（？）の論文をまとめてみた。</p>\\n<ul>\\n<li>Chu-Min Li <em>et al.</em>, &quot;Clause vivification by unit propagation in CDCL SAT solvers,”<em>Artif. Intell.</em>, vol. 279, 2020.</li>\\n</ul>\\n<h3>Outline</h3>\\n<p>主な主張はどのタイミングで、どの節を、どのリテラルからvivifyするかについて。\\n以前のvivificationは計算量の問題によりSAT competitionに提出されたソルバに導入されてもその後、削除されてきた歴史が語られている。\\nさらに以下のようにin-processor向けに <code>vivify</code> のアルゴリズムが変更されている。</p>\\n<p><img src=\\"/img/2020/07-05/vivi-algo3.jpg\\" alt=\\"\\"></p>\\n<ul>\\n<li>何にせよ最初に存在した節は17行目で必ず削除される。</li>\\n<li>17行目は一つ内側のループに含まれるはずですけど。</li>\\n</ul>\\n<h3>Splr approach</h3>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-keyword\\">pub</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">fn</span> <span class=\\"hljs-title\\">vivify</span></span>(asg: &amp;<span class=\\"hljs-keyword\\">mut</span> AssignStack, cdb: &amp;<span class=\\"hljs-keyword\\">mut</span> ClauseDB, state: &amp;<span class=\\"hljs-keyword\\">mut</span> State) {\\n    <span class=\\"hljs-symbol\\">\'next_clause</span>: <span class=\\"hljs-keyword\\">for</span> ci <span class=\\"hljs-keyword\\">in</span> clauses.iter() {\\n        <span class=\\"hljs-keyword\\">let</span> c: &amp;Clause = &amp;cdb[ci];\\n        <span class=\\"hljs-keyword\\">if</span> c.is(Flag::DEAD) {\\n            <span class=\\"hljs-keyword\\">continue</span>;\\n        }\\n        <span class=\\"hljs-keyword\\">let</span> <span class=\\"hljs-keyword\\">mut</span> v: <span class=\\"hljs-built_in\\">Vec</span>&lt;Lit&gt; = <span class=\\"hljs-built_in\\">Vec</span>::new();\\n        <span class=\\"hljs-keyword\\">let</span> <span class=\\"hljs-keyword\\">mut</span> vivified: <span class=\\"hljs-built_in\\">Vec</span>&lt;Lit&gt; = <span class=\\"hljs-built_in\\">Vec</span>::new();\\n        <span class=\\"hljs-keyword\\">for</span> (_i, l) <span class=\\"hljs-keyword\\">in</span> c.lits.clone().iter().enumerate() {\\n            <span class=\\"hljs-keyword\\">match</span> asg.assigned(*l) {\\n                <span class=\\"hljs-literal\\">Some</span>(<span class=\\"hljs-literal\\">true</span>) =&gt; <span class=\\"hljs-keyword\\">continue</span> <span class=\\"hljs-symbol\\">\'next_clause</span>,\\n                <span class=\\"hljs-literal\\">Some</span>(<span class=\\"hljs-literal\\">false</span>) =&gt; v.push(!*l),                 <span class=\\"hljs-comment\\">// Rule 4</span>\\n                <span class=\\"hljs-literal\\">None</span> =&gt; {\\n                    <span class=\\"hljs-keyword\\">let</span> cid: <span class=\\"hljs-built_in\\">Option</span>&lt;ClauseId&gt; = <span class=\\"hljs-keyword\\">match</span> v.len() {\\n                        <span class=\\"hljs-number\\">0</span> =&gt; <span class=\\"hljs-literal\\">None</span>,\\n                        <span class=\\"hljs-number\\">1</span> =&gt; { asg.assign_by_decision(v[<span class=\\"hljs-number\\">0</span>]); <span class=\\"hljs-literal\\">None</span> }\\n                        _ =&gt; <span class=\\"hljs-literal\\">Some</span>(cdb.new_clause(asg, &amp;<span class=\\"hljs-keyword\\">mut</span> v.clone(), <span class=\\"hljs-literal\\">false</span>, <span class=\\"hljs-literal\\">false</span>)), <span class=\\"hljs-comment\\">// L.12</span>\\n                    };\\n                    asg.assign_by_decision(!*l);\\n                    <span class=\\"hljs-keyword\\">let</span> confl = asg.propagate(cdb);\\n                    <span class=\\"hljs-keyword\\">if</span> confl != ClauseId::<span class=\\"hljs-keyword\\">default</span>() {\\n                        vivified = asg.remove_redundant(cdb, &amp;v, &amp;cdb[confl].lits); <span class=\\"hljs-comment\\">// Rule 3</span>\\n                    }\\n                    <span class=\\"hljs-keyword\\">if</span> <span class=\\"hljs-keyword\\">let</span> <span class=\\"hljs-literal\\">Some</span>(cj) = cid {\\n                        cdb.remove_clause(cj);\\n                    }\\n                    asg.cancel_until_sandbox(asg.root_level);\\n                    <span class=\\"hljs-keyword\\">if</span> confl == ClauseId::<span class=\\"hljs-keyword\\">default</span>() {\\n                        <span class=\\"hljs-keyword\\">break</span>;\\n                    }\\n                    v.push(!*l);\\n                }\\n            }\\n        }\\n        <span class=\\"hljs-keyword\\">if</span> vivified.is_empty() {\\n            <span class=\\"hljs-keyword\\">for</span> l <span class=\\"hljs-keyword\\">in</span> &amp;<span class=\\"hljs-keyword\\">mut</span> v {\\n                *l = !*l;\\n            }\\n            std::mem::swap(&amp;<span class=\\"hljs-keyword\\">mut</span> vivified, &amp;<span class=\\"hljs-keyword\\">mut</span> v);\\n        }\\n        <span class=\\"hljs-keyword\\">match</span> vivified.len() {\\n            <span class=\\"hljs-number\\">0</span> =&gt; <span class=\\"hljs-keyword\\">break</span> <span class=\\"hljs-symbol\\">\'next_clause</span>,\\n            <span class=\\"hljs-number\\">1</span> =&gt; {\\n                asg.assign_at_rootlevel(vivified[<span class=\\"hljs-number\\">0</span>]).expect(<span class=\\"hljs-string\\">\\"impossible\\"</span>);\\n                <span class=\\"hljs-built_in\\">assert!</span>(asg.propagate(cdb) == ClauseId::<span class=\\"hljs-keyword\\">default</span>(), <span class=\\"hljs-string\\">\\"UNSAT\\"</span>);\\n            }\\n            _ =&gt; cdb.new_clause(asg, &amp;<span class=\\"hljs-keyword\\">mut</span> vivified),\\n        }\\n        cdb.detach(*ci);\\n        cdb.garbage_collect();\\n    }\\n}</code></pre>","dir":"article/.json/2020","base":"2020-07-05-vivification2.json","ext":".json","sourceBase":"2020-07-05-vivification2.md","sourceExt":".md"}')}}]);