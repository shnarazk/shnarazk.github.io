(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{524:function(n){n.exports=JSON.parse('{"title":"Make Vec from HashMap in Rust","subtitle":"関数型プログラミング的にHashMapからVecを作る","date":"2019-02-20T00:00:00.000Z","tags":["rust"],"bodyContent":"Think about [HashMap](https://doc.rust-lang.org/std/collections/struct.HashMap.html)\\n\\n```rust\\nStruct std::collections::HashMap\\n\\n    pub fn insert(&mut self, k: K, v: V) -> Option<V>\\n        Inserts a key-value pair into the map.\\n\\n    pub fn keys(&self) -> Keys<K, V>[src]\\n        An iterator visiting all keys in arbitrary order. The iterator element type is &\'a K.\\n```\\n\\nAs a straight application of `insert`, the following code seems to work well.\\n\\n```rust\\n// collect keys of a HashMap into a Vec\\nlet h: HashMap<K, V>;\\nlet v: Vec<_> = h.keys().collect();\\n```\\n\\nBut in some case this is troublesome. For example,\\n\\n```rust\\n// key is String\\nlet h: HashMap<String, V>;\\nreturn h.keys().collect::<Vec<String>>();\\n```\\n\\nis a type mismatch because the return type of `keys` is the reference to key:\\n\\n```\\nerror[E0277]: a collection of type `std::vec::Vec<std::string::String>` cannot be built from an iterator over elements of type `&std::string::String`\\n```\\n\\nTo fix it, make `hash` hold `&String` as *key*:\\n\\n```rust\\n// change the key\'s type\\nlet h: HashMap<&String, V>;\\nreturn h.keys().collect::<Vec<&String>>();\\n```\\n\\nit emits another error in this case:\\n\\n```\\nerror[E0515]: cannot return value referencing local variable `h`\\n```\\n\\nHow about dereferencing and *injecting* them to the return value?\\n\\n```rust\\n// &String to String\\nlet h: HashMap<&String, V>;\\nlet v: Vec<String> = h.keys().map(|k| *k).collect();\\n```\\n\\nIt can\'t work (we can\'t destruct data in order to make a return value):\\n\\n```\\nerror[E0507]: cannot move out of borrowed content\\n```\\n\\nSo we need to copy them explicitly, if `K` doesn\'t have `Copy` trait.\\n\\n```rust\\nlet hash: HashMap<String, V>;\\nreturn hash.keys().map(|k| k.to_string()).collect::<Vec<String>>();\\n```\\n\\nBut this code may contain unwanted memory copy. So make `hash` hold the reference.\\n\\n\\n```rust\\n// `hash` points the original data to avoid double allocation\\nlet hash: HashMap<&String, V>;\\nreturn hash.keys().map(|k| k.to_string()).collect::<Vec<String>>();\\n```\\n\\nThat\'s it.","bodyHtml":"<p>Think about <a href=\\"https://doc.rust-lang.org/std/collections/struct.HashMap.html\\">HashMap</a></p>\\n<pre><code class=\\"hljs\\">Struct std::collections::HashMap\\n\\n    <span class=\\"hljs-keyword\\">pub</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">fn</span> <span class=\\"hljs-title\\">insert</span></span>(&amp;<span class=\\"hljs-keyword\\">mut</span> <span class=\\"hljs-keyword\\">self</span>, k: K, v: V) -&gt; <span class=\\"hljs-built_in\\">Option</span>&lt;V&gt;\\n        Inserts a key-value pair into the map.\\n\\n    <span class=\\"hljs-keyword\\">pub</span> <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">fn</span> <span class=\\"hljs-title\\">keys</span></span>(&amp;<span class=\\"hljs-keyword\\">self</span>) -&gt; Keys&lt;K, V&gt;[src]\\n        An iterator visiting all keys <span class=\\"hljs-keyword\\">in</span> arbitrary order. The iterator element <span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">type</span> <span class=\\"hljs-title\\">is</span></span> &amp;<span class=\\"hljs-symbol\\">&#x27;a</span> K.</code></pre><p>As a straight application of <code>insert</code>, the following code seems to work well.</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-comment\\">// collect keys of a HashMap into a Vec</span>\\n<span class=\\"hljs-keyword\\">let</span> h: HashMap&lt;K, V&gt;;\\n<span class=\\"hljs-keyword\\">let</span> v: <span class=\\"hljs-built_in\\">Vec</span>&lt;_&gt; = h.keys().collect();</code></pre><p>But in some case this is troublesome. For example,</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-comment\\">// key is String</span>\\n<span class=\\"hljs-keyword\\">let</span> h: HashMap&lt;<span class=\\"hljs-built_in\\">String</span>, V&gt;;\\n<span class=\\"hljs-keyword\\">return</span> h.keys().collect::&lt;<span class=\\"hljs-built_in\\">Vec</span>&lt;<span class=\\"hljs-built_in\\">String</span>&gt;&gt;();</code></pre><p>is a type mismatch because the return type of <code>keys</code> is the reference to key:</p>\\n<pre><code>error[E0277]: a collection of type `std::vec::Vec&lt;std::string::String&gt;` cannot be built from an iterator over elements of type `&amp;std::string::String`\\n</code></pre>\\n<p>To fix it, make <code>hash</code> hold <code>&amp;String</code> as <em>key</em>:</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-comment\\">// change the key&#x27;s type</span>\\n<span class=\\"hljs-keyword\\">let</span> h: HashMap&lt;&amp;<span class=\\"hljs-built_in\\">String</span>, V&gt;;\\n<span class=\\"hljs-keyword\\">return</span> h.keys().collect::&lt;<span class=\\"hljs-built_in\\">Vec</span>&lt;&amp;<span class=\\"hljs-built_in\\">String</span>&gt;&gt;();</code></pre><p>it emits another error in this case:</p>\\n<pre><code>error[E0515]: cannot return value referencing local variable `h`\\n</code></pre>\\n<p>How about dereferencing and <em>injecting</em> them to the return value?</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-comment\\">// &amp;String to String</span>\\n<span class=\\"hljs-keyword\\">let</span> h: HashMap&lt;&amp;<span class=\\"hljs-built_in\\">String</span>, V&gt;;\\n<span class=\\"hljs-keyword\\">let</span> v: <span class=\\"hljs-built_in\\">Vec</span>&lt;<span class=\\"hljs-built_in\\">String</span>&gt; = h.keys().map(|k| *k).collect();</code></pre><p>It can\'t work (we can\'t destruct data in order to make a return value):</p>\\n<pre><code>error[E0507]: cannot move out of borrowed content\\n</code></pre>\\n<p>So we need to copy them explicitly, if <code>K</code> doesn\'t have <code>Copy</code> trait.</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-keyword\\">let</span> hash: HashMap&lt;<span class=\\"hljs-built_in\\">String</span>, V&gt;;\\n<span class=\\"hljs-keyword\\">return</span> hash.keys().map(|k| k.to_string()).collect::&lt;<span class=\\"hljs-built_in\\">Vec</span>&lt;<span class=\\"hljs-built_in\\">String</span>&gt;&gt;();</code></pre><p>But this code may contain unwanted memory copy. So make <code>hash</code> hold the reference.</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-comment\\">// `hash` points the original data to avoid double allocation</span>\\n<span class=\\"hljs-keyword\\">let</span> hash: HashMap&lt;&amp;<span class=\\"hljs-built_in\\">String</span>, V&gt;;\\n<span class=\\"hljs-keyword\\">return</span> hash.keys().map(|k| k.to_string()).collect::&lt;<span class=\\"hljs-built_in\\">Vec</span>&lt;<span class=\\"hljs-built_in\\">String</span>&gt;&gt;();</code></pre><p>That\'s it.</p>\\n","dir":"article/.json/2019","base":"2019-02-20-hashmap-to-vec.json","ext":".json","sourceBase":"2019-02-20-hashmap-to-vec.md","sourceExt":".md"}')}}]);