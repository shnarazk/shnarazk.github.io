(window.webpackJsonp=window.webpackJsonp||[]).push([[83],{555:function(n){n.exports=JSON.parse('{"title":"Vivification","subtitle":"a CNF preprocessor","date":"2020-06-20T00:00:00.000Z","tags":["SAT"],"bodyContent":"Vivification がなんなのか、日本語で探しても出てこないので以下をまとめる。\\n（最新の話かと思っていたけど2008年とは。。。）\\n\\n* C. Piette, Y. Hamadi, and L. Saïs, \\"Vivifying propositional clausal formulae,”*Front. Artif. Intell*. Appl., vol. 178, pp. 525–529, 2008.\\n\\nSplrでいうところの、現在のprocessorが網羅的に節数に対する制約内での全ての変数除去、節包摂(clause\\nsubsumption)を実行するのに対し、vivificationは（その節に「対応」する割り当てを仮定して）propagateを\\n行った結果を用いて節の包摂方針を決めるというもの。その分、不要な複雑さの導入を抑えることができるらし\\nい。\\n何も考えずにRustで書いてみるとこんな感じ。\\n\\n```rust\\n/// Vivification of a given CNF formula, returning a vivified CNF formula\\nfn vivify(mut sigma: CNF) -> CNF {\\n    let mut sigmab = CNF::new();\\n    let mut change: bool = true;\\n    let mut shortened: bool = true;\\n    let cb: Vec<Lit> = Vec::new();\\n    while change {\\n        change = false;\\n        foreach c in sigma {\\n            given_cnf = sigma.clone();\\n            sigma = sigma.remove(c);   // Note: remove here is a non-destructive function.\\n            cb.clear();\\n            shortened = false;\\n            while !shortened && c != cb {\\n                l = select_literal(c.remove(cb));\\n                cb.push(l);                               // cb = cb ∪ {l};\\n                given_cnf.push(!l);                       // given_cnf ← (given_cnf ∪ {¬l}) \\n                let ls = given_cnf.propagate(); \\n\\t        if ls == NULL_CID  {                      // ⊥ ∈ UP(given_cnf)\\n\\t\\t    cl = conflict_analyze();              // returns a learnt clause\\n\\t\\t    if c.is_subsumeable(cl) {             // cl ⊂ c\\n\\t\\t        sigma.push(cl);                   // Σ ← Σ ∪ {cl} \\n\\t\\t        shortened = true;\\n                    } else if cl.len() == c.len() then {\\n                        sigma.push(cl);                   // Σ ←− Σ ∪ { cl } \\n                        cb = c;\\n                    }\\n                    if c != cb then {\\n                        sigma.push(cb);                   // Σ ← Σ ∪ {cb}\\n                        shortned = true;\\n                    }\\n                } else {\\n                    if c.remove(cb).includes(vec![ls]) {  // ∃(ls ∈ (c\\\\cb))\\n                        if c.remove(cb) != vec![ls] {     // (c\\\\cb) /= {ls}\\n                            sigma.push(cd.push(ls));      // Σ ← Σ ∪ {cb ∪ {ls}} ;\\n                            shortened = true;\\n                        }\\n                    }\\n                    if c.remove(cb).includes(!ls) {       // ∃(¬ls ∈ (c\\\\cb))\\n                        sigma.push(c.remove(vec![ls]));   // Σ ← Σ ∪ {c\\\\{ls}}\\n                        shortened = true;\\n                    }\\n                }\\n                if !shortened {\\n                    sigma.push(vec![c]);                  // Σ ← Σ ∪ {c} ;\\n                } else {\\n                    change = true;\\n                }\\n            }\\n        }\\n    }\\n    return sigma;\\n}\\n```\\n\\nうーむ、実装してみなくては。","bodyHtml":"<p>Vivification がなんなのか、日本語で探しても出てこないので以下をまとめる。\\n（最新の話かと思っていたけど2008年とは。。。）</p>\\n<ul>\\n<li>C. Piette, Y. Hamadi, and L. Saïs, &quot;Vivifying propositional clausal formulae,”<em>Front. Artif. Intell</em>. Appl., vol. 178, pp. 525–529, 2008.</li>\\n</ul>\\n<p>Splrでいうところの、現在のprocessorが網羅的に節数に対する制約内での全ての変数除去、節包摂(clause\\nsubsumption)を実行するのに対し、vivificationは（その節に「対応」する割り当てを仮定して）propagateを\\n行った結果を用いて節の包摂方針を決めるというもの。その分、不要な複雑さの導入を抑えることができるらし\\nい。\\n何も考えずにRustで書いてみるとこんな感じ。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-comment\\">/// Vivification of a given CNF formula, returning a vivified CNF formula</span>\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">fn</span> <span class=\\"hljs-title\\">vivify</span></span>(<span class=\\"hljs-keyword\\">mut</span> sigma: CNF) -&gt; CNF {\\n    <span class=\\"hljs-keyword\\">let</span> <span class=\\"hljs-keyword\\">mut</span> sigmab = CNF::new();\\n    <span class=\\"hljs-keyword\\">let</span> <span class=\\"hljs-keyword\\">mut</span> change: <span class=\\"hljs-built_in\\">bool</span> = <span class=\\"hljs-literal\\">true</span>;\\n    <span class=\\"hljs-keyword\\">let</span> <span class=\\"hljs-keyword\\">mut</span> shortened: <span class=\\"hljs-built_in\\">bool</span> = <span class=\\"hljs-literal\\">true</span>;\\n    <span class=\\"hljs-keyword\\">let</span> cb: <span class=\\"hljs-built_in\\">Vec</span>&lt;Lit&gt; = <span class=\\"hljs-built_in\\">Vec</span>::new();\\n    <span class=\\"hljs-keyword\\">while</span> change {\\n        change = <span class=\\"hljs-literal\\">false</span>;\\n        foreach c <span class=\\"hljs-keyword\\">in</span> sigma {\\n            given_cnf = sigma.clone();\\n            sigma = sigma.remove(c);   <span class=\\"hljs-comment\\">// Note: remove here is a non-destructive function.</span>\\n            cb.clear();\\n            shortened = <span class=\\"hljs-literal\\">false</span>;\\n            <span class=\\"hljs-keyword\\">while</span> !shortened &amp;&amp; c != cb {\\n                l = select_literal(c.remove(cb));\\n                cb.push(l);                               <span class=\\"hljs-comment\\">// cb = cb ∪ {l};</span>\\n                given_cnf.push(!l);                       <span class=\\"hljs-comment\\">// given_cnf ← (given_cnf ∪ {¬l}) </span>\\n                <span class=\\"hljs-keyword\\">let</span> ls = given_cnf.propagate(); \\n\\t        <span class=\\"hljs-keyword\\">if</span> ls == NULL_CID  {                      <span class=\\"hljs-comment\\">// ⊥ ∈ UP(given_cnf)</span>\\n\\t\\t    cl = conflict_analyze();              <span class=\\"hljs-comment\\">// returns a learnt clause</span>\\n\\t\\t    <span class=\\"hljs-keyword\\">if</span> c.is_subsumeable(cl) {             <span class=\\"hljs-comment\\">// cl ⊂ c</span>\\n\\t\\t        sigma.push(cl);                   <span class=\\"hljs-comment\\">// Σ ← Σ ∪ {cl} </span>\\n\\t\\t        shortened = <span class=\\"hljs-literal\\">true</span>;\\n                    } <span class=\\"hljs-keyword\\">else</span> <span class=\\"hljs-keyword\\">if</span> cl.len() == c.len() then {\\n                        sigma.push(cl);                   <span class=\\"hljs-comment\\">// Σ ←− Σ ∪ { cl } </span>\\n                        cb = c;\\n                    }\\n                    <span class=\\"hljs-keyword\\">if</span> c != cb then {\\n                        sigma.push(cb);                   <span class=\\"hljs-comment\\">// Σ ← Σ ∪ {cb}</span>\\n                        shortned = <span class=\\"hljs-literal\\">true</span>;\\n                    }\\n                } <span class=\\"hljs-keyword\\">else</span> {\\n                    <span class=\\"hljs-keyword\\">if</span> c.remove(cb).includes(<span class=\\"hljs-built_in\\">vec!</span>[ls]) {  <span class=\\"hljs-comment\\">// ∃(ls ∈ (c\\\\cb))</span>\\n                        <span class=\\"hljs-keyword\\">if</span> c.remove(cb) != <span class=\\"hljs-built_in\\">vec!</span>[ls] {     <span class=\\"hljs-comment\\">// (c\\\\cb) /= {ls}</span>\\n                            sigma.push(cd.push(ls));      <span class=\\"hljs-comment\\">// Σ ← Σ ∪ {cb ∪ {ls}} ;</span>\\n                            shortened = <span class=\\"hljs-literal\\">true</span>;\\n                        }\\n                    }\\n                    <span class=\\"hljs-keyword\\">if</span> c.remove(cb).includes(!ls) {       <span class=\\"hljs-comment\\">// ∃(¬ls ∈ (c\\\\cb))</span>\\n                        sigma.push(c.remove(<span class=\\"hljs-built_in\\">vec!</span>[ls]));   <span class=\\"hljs-comment\\">// Σ ← Σ ∪ {c\\\\{ls}}</span>\\n                        shortened = <span class=\\"hljs-literal\\">true</span>;\\n                    }\\n                }\\n                <span class=\\"hljs-keyword\\">if</span> !shortened {\\n                    sigma.push(<span class=\\"hljs-built_in\\">vec!</span>[c]);                  <span class=\\"hljs-comment\\">// Σ ← Σ ∪ {c} ;</span>\\n                } <span class=\\"hljs-keyword\\">else</span> {\\n                    change = <span class=\\"hljs-literal\\">true</span>;\\n                }\\n            }\\n        }\\n    }\\n    <span class=\\"hljs-keyword\\">return</span> sigma;\\n}</code></pre><p>うーむ、実装してみなくては。</p>\\n","dir":"article/.json/2020","base":"2020-06-20-vivification.json","ext":".json","sourceBase":"2020-06-20-vivification.md","sourceExt":".md"}')}}]);