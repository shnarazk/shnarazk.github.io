__NUXT_JSONP__("/2020/2020-08-19-splr-with-vivification", {data:[{article:Object.create(null,{default:{writable:true,enumerable:true,value:{title:"Implementing clause vivification on Splr",subtitle:"vivification part 3",date:"2020-08-23T00:00:00.000Z",tags:["SAT","vivification","splr"],banner:"https:\u002F\u002Fimages.unsplash.com\u002Fphoto-1503803548695-c2a7b4a5b875?ixlib=rb-1.2.1&auto=format&fit=crop&w=1950&q=80",bodyContent:"**cover image: https:\u002F\u002Funsplash.com\u002Fphotos\u002F-IMlv9Jlb24**\n\nVersion 0.4.2 リリース直前のSplr、性能的には妥協できるものが出来たので次の課題は妥当性。\nSAT問題はいいのだけど、UNSAT問題に対する certification がおかしなものになっているとか。\nvivification を切ると問題が解消するので、vivify時の節の追加削除が正しくcertification に反映されてないようだ。\n\n## 1. gratgenのこういうメッセージがどうやっても解消できない\n\n```text\nc Ignoring deletion of non-existent clause (pos 30441)\nc Ignoring deletion of non-existent clause (pos 30441)\nc Ignoring deletion of non-existent clause (pos 30441)\n```\n\nうーん、そんなはずはないのだが。。。\n\n理由：節内リテラルの順序とcertificateに書き出されたものでの順序とが一致していなかった。\n\n## 2. なぜかAssignStack中に未割り当てリテラルが出現する\n\n理由：変数への仮割り当ての前提条件の検査が不十分だった。\n\n## 3. 2020-08-21 記号の読み間違え判明\n\n[Clause Vivification updated 2020](\u002F2020\u002F2020-07-05-vivification2\u002F)に記載の通り。\n\n## 4. vivify中に決定による割り当てを行っただけでcertificateが不当なものになってしまう\n\n理由：Eliminatorがバグってた！\n\n## 5. Eliminatorを直しても以下省略\n\n理由：`cdb.detach(); cdb.garbage_collect();` が非常に怪しい。\n\n## 6. `propagate`しなくてもおかしくなる\n\n理由：節の追加削除しか原因はない。\n\n## 7. Rule. 3の解釈が怪しい\n\n\u003E **Rule_3**: If $\\text{UP}(\\phi \\cup \\{\\neg l_1, \\ldots, \\neg l_i \\}) = \\Box$, then $\\phi \\cup \\{\\neg l_1, \\ldots, \\neg l_i \\}$ is unsatisfiable and clause $l_1 \\vee \\cdots \\vee l_i$ is a logical consequence of $\\phi$ and could replace $C$. However, as before, let $R$ be the set of literals of the falsified clause, $conflAnalysis(\\phi, \\neg C' \\cup \\{\\neg l_i \\}, R)$, which is a sub-clause of $l_1 \\vee \\cdots \\vee l_i$ .\n\nそもそも`conflict_analysis`の引数の解釈は大丈夫だろうか。なぜ3引数なのか。ということで論文より引用し直し。\n\n![](\u002Fimg\u002F2020\u002F08-19\u002FAlgorithm4_conflAnalysis.jpg)\n\n![](\u002Fimg\u002F2020\u002F07-05\u002Fvivi-algo3.jpg)\n\n大丈夫なようだ。矛盾しているリテラルを拾うためにリテラルベースではなく、変数ベースでアクセスしている。\n特に問題はない。例えば節長が1の学習節をcertificateに含めても問題は発生しない。\n\n## 8. しかし生成された節を certificate に含めると証明にならない\n\n理由：**Algorithm 4**は間違い。もし最上位レベルでの含意によって割り当てられるリテラルだけからなる節によって矛盾が発生したとする。この場合**Algorithm 4**では決定変数が学習節に含まれない。なので**Algorithm 4**は以下であるべき。\n\n```diff\n  fn analyze(asg: &AssignStack, cdb: &ClauseDB, lits: &[Lit], reason: &[Lit], ...) -\u003E Vec\u003CLit\u003E {\n       let mut res: Vec\u003CLit\u003E = Vec::new();\n       for l in reason { seen[l.vi()] = key; }\n       for l in asg.stack_iter().rev() {\n           if seen[l.vi()] != key { continue; }\n           if lits.contains(l) {\n               res.push(!*l);\n-              continue;\n           } else if lits.contains(&!*l) {\n               res.push(*l);\n-              continue;\n           }\n           for r in asg.reason_literals(cdb, *l).iter() { seen[r.vi()] = key; }\n       }\n       res\n  }\n```\n\n**2020-08-23: これでバグが取れた！**\n\n# 最終版\n\n```rust\npub fn vivify(asg: &mut AssignStack, cdb: &mut ClauseDB) -\u003E MaybeInconsistent {\n    while let Some(ci) = clauses.pop() {\n        let c: &mut Clause = &mut cdb[ci];\n        let clits = c.lits.clone();\n        let mut copied: Vec\u003CLit\u003E = Vec::new();\n        let mut flipped = true;\n        'this_clause: for l in clits.iter() {\n            match asg.assigned(*l) {\n                Some(false) =\u003E continue 'this_clause, \u002F\u002F Rule 1\n                Some(true) =\u003E {\n                    \u002F\u002F This path is optimized for the case the decision level is zero.\n                    copied.clear();\n                    flipped = false;\n                    break 'this_clause;\n                }\n                None =\u003E {\n                    let cid: Option\u003CClauseId\u003E = match copied.len() {\n                        0 =\u003E None,\n                        1 =\u003E {\n                            asg.assign_by_decision(copied[0]);\n                            None\n                        }\n                        _ =\u003E Some(cdb.new_clause(asg, &mut copied.clone(), true, false)),\n                    };\n                    asg.assign_by_decision(!*l);\n                    let cc = asg.propagate(cdb);\n                    if !cc.is_none() {\n                        copied.push(!*l);\n                        let r = cdb[cc].lits.clone(); \u002F\u002F Rule 3\n                        copied = asg.analyze(cdb, &copied, &r, &mut seen);\n                        if !copied.is_empty() { flipped = false; }\n                    }\n                    asg.cancel_until(asg.root_level);\n                    if let Some(cj) = cid { cdb.detach(cj); }\n                    if !cc.is_none() { break 'this_clause; }\n                    copied.push(!*l); \u002F\u002F Rule 4\n                }\n            }\n        }\n        if flipped { flip(&mut copied); }\n        match copied.len() {\n            0 if flipped =\u003E return Err(SolverError::Inconsistent),\n            0 =\u003E cdb.detach(ci),\n            1 =\u003E {\n                let l0 = copied[0];\n                cdb.certificate_add(&copied);\n                if asg.assigned(l0) == None {\n                    asg.assign_at_rootlevel(l0)?;\n                    if !asg.propagate(cdb).is_none() {\n                        return Err(SolverError::Inconsistent);\n                    }\n                }\n                cdb.detach(ci);\n            }\n            n if n == clits.len() =\u003E (),\n            n =\u003E {\n                cdb.new_clause(asg, &mut copied);\n                cdb.detach(ci);\n            }\n        }\n        clauses.retain(|ci| !cdb[ci].is(Flag::DEAD));\n    }\n    Ok(())\n}\n```",bodyHtml:"\u003Cp\u003E\u003Cstrong\u003Ecover image: https:\u002F\u002Funsplash.com\u002Fphotos\u002F-IMlv9Jlb24\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EVersion 0.4.2 リリース直前のSplr、性能的には妥協できるものが出来たので次の課題は妥当性。\nSAT問題はいいのだけど、UNSAT問題に対する certification がおかしなものになっているとか。\nvivification を切ると問題が解消するので、vivify時の節の追加削除が正しくcertification に反映されてないようだ。\u003C\u002Fp\u003E\n\u003Ch2\u003E1. gratgenのこういうメッセージがどうやっても解消できない\u003C\u002Fh2\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003Ec Ignoring deletion of non-existent clause (pos 30441)\nc Ignoring deletion of non-existent clause (pos 30441)\nc Ignoring deletion of non-existent clause (pos 30441)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eうーん、そんなはずはないのだが。。。\u003C\u002Fp\u003E\n\u003Cp\u003E理由：節内リテラルの順序とcertificateに書き出されたものでの順序とが一致していなかった。\u003C\u002Fp\u003E\n\u003Ch2\u003E2. なぜかAssignStack中に未割り当てリテラルが出現する\u003C\u002Fh2\u003E\n\u003Cp\u003E理由：変数への仮割り当ての前提条件の検査が不十分だった。\u003C\u002Fp\u003E\n\u003Ch2\u003E3. 2020-08-21 記号の読み間違え判明\u003C\u002Fh2\u003E\n\u003Cp\u003E\u003Ca href=\"\u002F2020\u002F2020-07-05-vivification2\u002F\"\u003EClause Vivification updated 2020\u003C\u002Fa\u003Eに記載の通り。\u003C\u002Fp\u003E\n\u003Ch2\u003E4. vivify中に決定による割り当てを行っただけでcertificateが不当なものになってしまう\u003C\u002Fh2\u003E\n\u003Cp\u003E理由：Eliminatorがバグってた！\u003C\u002Fp\u003E\n\u003Ch2\u003E5. Eliminatorを直しても以下省略\u003C\u002Fh2\u003E\n\u003Cp\u003E理由：\u003Ccode\u003Ecdb.detach(); cdb.garbage_collect();\u003C\u002Fcode\u003E が非常に怪しい。\u003C\u002Fp\u003E\n\u003Ch2\u003E6. \u003Ccode\u003Epropagate\u003C\u002Fcode\u003Eしなくてもおかしくなる\u003C\u002Fh2\u003E\n\u003Cp\u003E理由：節の追加削除しか原因はない。\u003C\u002Fp\u003E\n\u003Ch2\u003E7. Rule. 3の解釈が怪しい\u003C\u002Fh2\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E\u003Cstrong\u003ERule_3\u003C\u002Fstrong\u003E: If $\\text{UP}(\\phi \\cup {\\neg l_1, \\ldots, \\neg l_i }) = \\Box$, then $\\phi \\cup {\\neg l_1, \\ldots, \\neg l_i }$ is unsatisfiable and clause $l_1 \\vee \\cdots \\vee l_i$ is a logical consequence of $\\phi$ and could replace $C$. However, as before, let $R$ be the set of literals of the falsified clause, $conflAnalysis(\\phi, \\neg C' \\cup {\\neg l_i }, R)$, which is a sub-clause of $l_1 \\vee \\cdots \\vee l_i$ .\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003Eそもそも\u003Ccode\u003Econflict_analysis\u003C\u002Fcode\u003Eの引数の解釈は大丈夫だろうか。なぜ3引数なのか。ということで論文より引用し直し。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"\u002Fimg\u002F2020\u002F08-19\u002FAlgorithm4_conflAnalysis.jpg\" alt=\"\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"\u002Fimg\u002F2020\u002F07-05\u002Fvivi-algo3.jpg\" alt=\"\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E大丈夫なようだ。矛盾しているリテラルを拾うためにリテラルベースではなく、変数ベースでアクセスしている。\n特に問題はない。例えば節長が1の学習節をcertificateに含めても問題は発生しない。\u003C\u002Fp\u003E\n\u003Ch2\u003E8. しかし生成された節を certificate に含めると証明にならない\u003C\u002Fh2\u003E\n\u003Cp\u003E理由：\u003Cstrong\u003EAlgorithm 4\u003C\u002Fstrong\u003Eは間違い。もし最上位レベルでの含意によって割り当てられるリテラルだけからなる節によって矛盾が発生したとする。この場合\u003Cstrong\u003EAlgorithm 4\u003C\u002Fstrong\u003Eでは決定変数が学習節に含まれない。なので\u003Cstrong\u003EAlgorithm 4\u003C\u002Fstrong\u003Eは以下であるべき。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003Efn analyze(asg: &amp;AssignStack, cdb: &amp;ClauseDB, lits: &amp;[Lit], reason: &amp;[Lit], ...) -&gt; Vec&lt;Lit&gt; {\n       let mut res: Vec&lt;Lit&gt; = Vec::new();\n       for l in reason { seen[l.vi()] = key; }\n       for l in asg.stack_iter().rev() {\n           if seen[l.vi()] != key { continue; }\n           if lits.contains(l) {\n               res.push(!*l);\n\u003Cspan class=\"hljs-deletion\"\u003E-              continue;\u003C\u002Fspan\u003E\n           } else if lits.contains(&amp;!*l) {\n               res.push(*l);\n\u003Cspan class=\"hljs-deletion\"\u003E-              continue;\u003C\u002Fspan\u003E\n           }\n           for r in asg.reason_literals(cdb, *l).iter() { seen[r.vi()] = key; }\n       }\n       res\n  }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cstrong\u003E2020-08-23: これでバグが取れた！\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Ch1\u003E最終版\u003C\u002Fh1\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Epub\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Evivify\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(asg: &amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E AssignStack, cdb: &amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E ClauseDB) -&gt; MaybeInconsistent {\n    \u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003ESome\u003C\u002Fspan\u003E(ci) = clauses.pop() {\n        \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E c: &amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E Clause = &amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E cdb[ci];\n        \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E clits = c.lits.clone();\n        \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E copied: \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;Lit&gt; = \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E::new();\n        \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E flipped = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n        \u003Cspan class=\"hljs-symbol\"\u003E&#x27;this_clause\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E l \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E clits.iter() {\n            \u003Cspan class=\"hljs-keyword\"\u003Ematch\u003C\u002Fspan\u003E asg.assigned(*l) {\n                \u003Cspan class=\"hljs-literal\"\u003ESome\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E) =&gt; \u003Cspan class=\"hljs-keyword\"\u003Econtinue\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-symbol\"\u003E&#x27;this_clause\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Rule 1\u003C\u002Fspan\u003E\n                \u003Cspan class=\"hljs-literal\"\u003ESome\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E) =&gt; {\n                    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F This path is optimized for the case the decision level is zero.\u003C\u002Fspan\u003E\n                    copied.clear();\n                    flipped = \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E;\n                    \u003Cspan class=\"hljs-keyword\"\u003Ebreak\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-symbol\"\u003E&#x27;this_clause\u003C\u002Fspan\u003E;\n                }\n                \u003Cspan class=\"hljs-literal\"\u003ENone\u003C\u002Fspan\u003E =&gt; {\n                    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E cid: \u003Cspan class=\"hljs-built_in\"\u003EOption\u003C\u002Fspan\u003E&lt;ClauseId&gt; = \u003Cspan class=\"hljs-keyword\"\u003Ematch\u003C\u002Fspan\u003E copied.len() {\n                        \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E =&gt; \u003Cspan class=\"hljs-literal\"\u003ENone\u003C\u002Fspan\u003E,\n                        \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E =&gt; {\n                            asg.assign_by_decision(copied[\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E]);\n                            \u003Cspan class=\"hljs-literal\"\u003ENone\u003C\u002Fspan\u003E\n                        }\n                        _ =&gt; \u003Cspan class=\"hljs-literal\"\u003ESome\u003C\u002Fspan\u003E(cdb.new_clause(asg, &amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E copied.clone(), \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E)),\n                    };\n                    asg.assign_by_decision(!*l);\n                    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E cc = asg.propagate(cdb);\n                    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E !cc.is_none() {\n                        copied.push(!*l);\n                        \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E r = cdb[cc].lits.clone(); \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Rule 3\u003C\u002Fspan\u003E\n                        copied = asg.analyze(cdb, &amp;copied, &amp;r, &amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E seen);\n                        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E !copied.is_empty() { flipped = \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E; }\n                    }\n                    asg.cancel_until(asg.root_level);\n                    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003ESome\u003C\u002Fspan\u003E(cj) = cid { cdb.detach(cj); }\n                    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E !cc.is_none() { \u003Cspan class=\"hljs-keyword\"\u003Ebreak\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-symbol\"\u003E&#x27;this_clause\u003C\u002Fspan\u003E; }\n                    copied.push(!*l); \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Rule 4\u003C\u002Fspan\u003E\n                }\n            }\n        }\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E flipped { flip(&amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E copied); }\n        \u003Cspan class=\"hljs-keyword\"\u003Ematch\u003C\u002Fspan\u003E copied.len() {\n            \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E flipped =&gt; \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003EErr\u003C\u002Fspan\u003E(SolverError::Inconsistent),\n            \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E =&gt; cdb.detach(ci),\n            \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E =&gt; {\n                \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E l0 = copied[\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E];\n                cdb.certificate_add(&amp;copied);\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E asg.assigned(l0) == \u003Cspan class=\"hljs-literal\"\u003ENone\u003C\u002Fspan\u003E {\n                    asg.assign_at_rootlevel(l0)?;\n                    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E !asg.propagate(cdb).is_none() {\n                        \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003EErr\u003C\u002Fspan\u003E(SolverError::Inconsistent);\n                    }\n                }\n                cdb.detach(ci);\n            }\n            n \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E n == clits.len() =&gt; (),\n            n =&gt; {\n                cdb.new_clause(asg, &amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E copied);\n                cdb.detach(ci);\n            }\n        }\n        clauses.retain(|ci| !cdb[ci].is(Flag::DEAD));\n    }\n    \u003Cspan class=\"hljs-literal\"\u003EOk\u003C\u002Fspan\u003E(())\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E",dir:"article\u002F.json\u002F2020",base:"2020-08-19-splr-with-vivification.json",ext:".json",sourceBase:"2020-08-19-splr-with-vivification.md",sourceExt:".md"}},title:{writable:true,enumerable:true,value:"Implementing clause vivification on Splr"},subtitle:{writable:true,enumerable:true,value:"vivification part 3"},date:{writable:true,enumerable:true,value:"2020-08-23T00:00:00.000Z"},tags:{writable:true,enumerable:true,value:["SAT","vivification","splr"]},banner:{writable:true,enumerable:true,value:"https:\u002F\u002Fimages.unsplash.com\u002Fphoto-1503803548695-c2a7b4a5b875?ixlib=rb-1.2.1&auto=format&fit=crop&w=1950&q=80"},bodyContent:{writable:true,enumerable:true,value:"**cover image: https:\u002F\u002Funsplash.com\u002Fphotos\u002F-IMlv9Jlb24**\n\nVersion 0.4.2 リリース直前のSplr、性能的には妥協できるものが出来たので次の課題は妥当性。\nSAT問題はいいのだけど、UNSAT問題に対する certification がおかしなものになっているとか。\nvivification を切ると問題が解消するので、vivify時の節の追加削除が正しくcertification に反映されてないようだ。\n\n## 1. gratgenのこういうメッセージがどうやっても解消できない\n\n```text\nc Ignoring deletion of non-existent clause (pos 30441)\nc Ignoring deletion of non-existent clause (pos 30441)\nc Ignoring deletion of non-existent clause (pos 30441)\n```\n\nうーん、そんなはずはないのだが。。。\n\n理由：節内リテラルの順序とcertificateに書き出されたものでの順序とが一致していなかった。\n\n## 2. なぜかAssignStack中に未割り当てリテラルが出現する\n\n理由：変数への仮割り当ての前提条件の検査が不十分だった。\n\n## 3. 2020-08-21 記号の読み間違え判明\n\n[Clause Vivification updated 2020](\u002F2020\u002F2020-07-05-vivification2\u002F)に記載の通り。\n\n## 4. vivify中に決定による割り当てを行っただけでcertificateが不当なものになってしまう\n\n理由：Eliminatorがバグってた！\n\n## 5. Eliminatorを直しても以下省略\n\n理由：`cdb.detach(); cdb.garbage_collect();` が非常に怪しい。\n\n## 6. `propagate`しなくてもおかしくなる\n\n理由：節の追加削除しか原因はない。\n\n## 7. Rule. 3の解釈が怪しい\n\n\u003E **Rule_3**: If $\\text{UP}(\\phi \\cup \\{\\neg l_1, \\ldots, \\neg l_i \\}) = \\Box$, then $\\phi \\cup \\{\\neg l_1, \\ldots, \\neg l_i \\}$ is unsatisfiable and clause $l_1 \\vee \\cdots \\vee l_i$ is a logical consequence of $\\phi$ and could replace $C$. However, as before, let $R$ be the set of literals of the falsified clause, $conflAnalysis(\\phi, \\neg C' \\cup \\{\\neg l_i \\}, R)$, which is a sub-clause of $l_1 \\vee \\cdots \\vee l_i$ .\n\nそもそも`conflict_analysis`の引数の解釈は大丈夫だろうか。なぜ3引数なのか。ということで論文より引用し直し。\n\n![](\u002Fimg\u002F2020\u002F08-19\u002FAlgorithm4_conflAnalysis.jpg)\n\n![](\u002Fimg\u002F2020\u002F07-05\u002Fvivi-algo3.jpg)\n\n大丈夫なようだ。矛盾しているリテラルを拾うためにリテラルベースではなく、変数ベースでアクセスしている。\n特に問題はない。例えば節長が1の学習節をcertificateに含めても問題は発生しない。\n\n## 8. しかし生成された節を certificate に含めると証明にならない\n\n理由：**Algorithm 4**は間違い。もし最上位レベルでの含意によって割り当てられるリテラルだけからなる節によって矛盾が発生したとする。この場合**Algorithm 4**では決定変数が学習節に含まれない。なので**Algorithm 4**は以下であるべき。\n\n```diff\n  fn analyze(asg: &AssignStack, cdb: &ClauseDB, lits: &[Lit], reason: &[Lit], ...) -\u003E Vec\u003CLit\u003E {\n       let mut res: Vec\u003CLit\u003E = Vec::new();\n       for l in reason { seen[l.vi()] = key; }\n       for l in asg.stack_iter().rev() {\n           if seen[l.vi()] != key { continue; }\n           if lits.contains(l) {\n               res.push(!*l);\n-              continue;\n           } else if lits.contains(&!*l) {\n               res.push(*l);\n-              continue;\n           }\n           for r in asg.reason_literals(cdb, *l).iter() { seen[r.vi()] = key; }\n       }\n       res\n  }\n```\n\n**2020-08-23: これでバグが取れた！**\n\n# 最終版\n\n```rust\npub fn vivify(asg: &mut AssignStack, cdb: &mut ClauseDB) -\u003E MaybeInconsistent {\n    while let Some(ci) = clauses.pop() {\n        let c: &mut Clause = &mut cdb[ci];\n        let clits = c.lits.clone();\n        let mut copied: Vec\u003CLit\u003E = Vec::new();\n        let mut flipped = true;\n        'this_clause: for l in clits.iter() {\n            match asg.assigned(*l) {\n                Some(false) =\u003E continue 'this_clause, \u002F\u002F Rule 1\n                Some(true) =\u003E {\n                    \u002F\u002F This path is optimized for the case the decision level is zero.\n                    copied.clear();\n                    flipped = false;\n                    break 'this_clause;\n                }\n                None =\u003E {\n                    let cid: Option\u003CClauseId\u003E = match copied.len() {\n                        0 =\u003E None,\n                        1 =\u003E {\n                            asg.assign_by_decision(copied[0]);\n                            None\n                        }\n                        _ =\u003E Some(cdb.new_clause(asg, &mut copied.clone(), true, false)),\n                    };\n                    asg.assign_by_decision(!*l);\n                    let cc = asg.propagate(cdb);\n                    if !cc.is_none() {\n                        copied.push(!*l);\n                        let r = cdb[cc].lits.clone(); \u002F\u002F Rule 3\n                        copied = asg.analyze(cdb, &copied, &r, &mut seen);\n                        if !copied.is_empty() { flipped = false; }\n                    }\n                    asg.cancel_until(asg.root_level);\n                    if let Some(cj) = cid { cdb.detach(cj); }\n                    if !cc.is_none() { break 'this_clause; }\n                    copied.push(!*l); \u002F\u002F Rule 4\n                }\n            }\n        }\n        if flipped { flip(&mut copied); }\n        match copied.len() {\n            0 if flipped =\u003E return Err(SolverError::Inconsistent),\n            0 =\u003E cdb.detach(ci),\n            1 =\u003E {\n                let l0 = copied[0];\n                cdb.certificate_add(&copied);\n                if asg.assigned(l0) == None {\n                    asg.assign_at_rootlevel(l0)?;\n                    if !asg.propagate(cdb).is_none() {\n                        return Err(SolverError::Inconsistent);\n                    }\n                }\n                cdb.detach(ci);\n            }\n            n if n == clits.len() =\u003E (),\n            n =\u003E {\n                cdb.new_clause(asg, &mut copied);\n                cdb.detach(ci);\n            }\n        }\n        clauses.retain(|ci| !cdb[ci].is(Flag::DEAD));\n    }\n    Ok(())\n}\n```"},bodyHtml:{writable:true,enumerable:true,value:"\u003Cp\u003E\u003Cstrong\u003Ecover image: https:\u002F\u002Funsplash.com\u002Fphotos\u002F-IMlv9Jlb24\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EVersion 0.4.2 リリース直前のSplr、性能的には妥協できるものが出来たので次の課題は妥当性。\nSAT問題はいいのだけど、UNSAT問題に対する certification がおかしなものになっているとか。\nvivification を切ると問題が解消するので、vivify時の節の追加削除が正しくcertification に反映されてないようだ。\u003C\u002Fp\u003E\n\u003Ch2\u003E1. gratgenのこういうメッセージがどうやっても解消できない\u003C\u002Fh2\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003Ec Ignoring deletion of non-existent clause (pos 30441)\nc Ignoring deletion of non-existent clause (pos 30441)\nc Ignoring deletion of non-existent clause (pos 30441)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eうーん、そんなはずはないのだが。。。\u003C\u002Fp\u003E\n\u003Cp\u003E理由：節内リテラルの順序とcertificateに書き出されたものでの順序とが一致していなかった。\u003C\u002Fp\u003E\n\u003Ch2\u003E2. なぜかAssignStack中に未割り当てリテラルが出現する\u003C\u002Fh2\u003E\n\u003Cp\u003E理由：変数への仮割り当ての前提条件の検査が不十分だった。\u003C\u002Fp\u003E\n\u003Ch2\u003E3. 2020-08-21 記号の読み間違え判明\u003C\u002Fh2\u003E\n\u003Cp\u003E\u003Ca href=\"\u002F2020\u002F2020-07-05-vivification2\u002F\"\u003EClause Vivification updated 2020\u003C\u002Fa\u003Eに記載の通り。\u003C\u002Fp\u003E\n\u003Ch2\u003E4. vivify中に決定による割り当てを行っただけでcertificateが不当なものになってしまう\u003C\u002Fh2\u003E\n\u003Cp\u003E理由：Eliminatorがバグってた！\u003C\u002Fp\u003E\n\u003Ch2\u003E5. Eliminatorを直しても以下省略\u003C\u002Fh2\u003E\n\u003Cp\u003E理由：\u003Ccode\u003Ecdb.detach(); cdb.garbage_collect();\u003C\u002Fcode\u003E が非常に怪しい。\u003C\u002Fp\u003E\n\u003Ch2\u003E6. \u003Ccode\u003Epropagate\u003C\u002Fcode\u003Eしなくてもおかしくなる\u003C\u002Fh2\u003E\n\u003Cp\u003E理由：節の追加削除しか原因はない。\u003C\u002Fp\u003E\n\u003Ch2\u003E7. Rule. 3の解釈が怪しい\u003C\u002Fh2\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E\u003Cstrong\u003ERule_3\u003C\u002Fstrong\u003E: If $\\text{UP}(\\phi \\cup {\\neg l_1, \\ldots, \\neg l_i }) = \\Box$, then $\\phi \\cup {\\neg l_1, \\ldots, \\neg l_i }$ is unsatisfiable and clause $l_1 \\vee \\cdots \\vee l_i$ is a logical consequence of $\\phi$ and could replace $C$. However, as before, let $R$ be the set of literals of the falsified clause, $conflAnalysis(\\phi, \\neg C' \\cup {\\neg l_i }, R)$, which is a sub-clause of $l_1 \\vee \\cdots \\vee l_i$ .\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003Eそもそも\u003Ccode\u003Econflict_analysis\u003C\u002Fcode\u003Eの引数の解釈は大丈夫だろうか。なぜ3引数なのか。ということで論文より引用し直し。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"\u002Fimg\u002F2020\u002F08-19\u002FAlgorithm4_conflAnalysis.jpg\" alt=\"\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"\u002Fimg\u002F2020\u002F07-05\u002Fvivi-algo3.jpg\" alt=\"\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E大丈夫なようだ。矛盾しているリテラルを拾うためにリテラルベースではなく、変数ベースでアクセスしている。\n特に問題はない。例えば節長が1の学習節をcertificateに含めても問題は発生しない。\u003C\u002Fp\u003E\n\u003Ch2\u003E8. しかし生成された節を certificate に含めると証明にならない\u003C\u002Fh2\u003E\n\u003Cp\u003E理由：\u003Cstrong\u003EAlgorithm 4\u003C\u002Fstrong\u003Eは間違い。もし最上位レベルでの含意によって割り当てられるリテラルだけからなる節によって矛盾が発生したとする。この場合\u003Cstrong\u003EAlgorithm 4\u003C\u002Fstrong\u003Eでは決定変数が学習節に含まれない。なので\u003Cstrong\u003EAlgorithm 4\u003C\u002Fstrong\u003Eは以下であるべき。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003Efn analyze(asg: &amp;AssignStack, cdb: &amp;ClauseDB, lits: &amp;[Lit], reason: &amp;[Lit], ...) -&gt; Vec&lt;Lit&gt; {\n       let mut res: Vec&lt;Lit&gt; = Vec::new();\n       for l in reason { seen[l.vi()] = key; }\n       for l in asg.stack_iter().rev() {\n           if seen[l.vi()] != key { continue; }\n           if lits.contains(l) {\n               res.push(!*l);\n\u003Cspan class=\"hljs-deletion\"\u003E-              continue;\u003C\u002Fspan\u003E\n           } else if lits.contains(&amp;!*l) {\n               res.push(*l);\n\u003Cspan class=\"hljs-deletion\"\u003E-              continue;\u003C\u002Fspan\u003E\n           }\n           for r in asg.reason_literals(cdb, *l).iter() { seen[r.vi()] = key; }\n       }\n       res\n  }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Cstrong\u003E2020-08-23: これでバグが取れた！\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Ch1\u003E最終版\u003C\u002Fh1\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Epub\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Evivify\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(asg: &amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E AssignStack, cdb: &amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E ClauseDB) -&gt; MaybeInconsistent {\n    \u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003ESome\u003C\u002Fspan\u003E(ci) = clauses.pop() {\n        \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E c: &amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E Clause = &amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E cdb[ci];\n        \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E clits = c.lits.clone();\n        \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E copied: \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;Lit&gt; = \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E::new();\n        \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E flipped = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n        \u003Cspan class=\"hljs-symbol\"\u003E&#x27;this_clause\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E l \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E clits.iter() {\n            \u003Cspan class=\"hljs-keyword\"\u003Ematch\u003C\u002Fspan\u003E asg.assigned(*l) {\n                \u003Cspan class=\"hljs-literal\"\u003ESome\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E) =&gt; \u003Cspan class=\"hljs-keyword\"\u003Econtinue\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-symbol\"\u003E&#x27;this_clause\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Rule 1\u003C\u002Fspan\u003E\n                \u003Cspan class=\"hljs-literal\"\u003ESome\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E) =&gt; {\n                    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F This path is optimized for the case the decision level is zero.\u003C\u002Fspan\u003E\n                    copied.clear();\n                    flipped = \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E;\n                    \u003Cspan class=\"hljs-keyword\"\u003Ebreak\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-symbol\"\u003E&#x27;this_clause\u003C\u002Fspan\u003E;\n                }\n                \u003Cspan class=\"hljs-literal\"\u003ENone\u003C\u002Fspan\u003E =&gt; {\n                    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E cid: \u003Cspan class=\"hljs-built_in\"\u003EOption\u003C\u002Fspan\u003E&lt;ClauseId&gt; = \u003Cspan class=\"hljs-keyword\"\u003Ematch\u003C\u002Fspan\u003E copied.len() {\n                        \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E =&gt; \u003Cspan class=\"hljs-literal\"\u003ENone\u003C\u002Fspan\u003E,\n                        \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E =&gt; {\n                            asg.assign_by_decision(copied[\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E]);\n                            \u003Cspan class=\"hljs-literal\"\u003ENone\u003C\u002Fspan\u003E\n                        }\n                        _ =&gt; \u003Cspan class=\"hljs-literal\"\u003ESome\u003C\u002Fspan\u003E(cdb.new_clause(asg, &amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E copied.clone(), \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E)),\n                    };\n                    asg.assign_by_decision(!*l);\n                    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E cc = asg.propagate(cdb);\n                    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E !cc.is_none() {\n                        copied.push(!*l);\n                        \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E r = cdb[cc].lits.clone(); \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Rule 3\u003C\u002Fspan\u003E\n                        copied = asg.analyze(cdb, &amp;copied, &amp;r, &amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E seen);\n                        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E !copied.is_empty() { flipped = \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E; }\n                    }\n                    asg.cancel_until(asg.root_level);\n                    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003ESome\u003C\u002Fspan\u003E(cj) = cid { cdb.detach(cj); }\n                    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E !cc.is_none() { \u003Cspan class=\"hljs-keyword\"\u003Ebreak\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-symbol\"\u003E&#x27;this_clause\u003C\u002Fspan\u003E; }\n                    copied.push(!*l); \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Rule 4\u003C\u002Fspan\u003E\n                }\n            }\n        }\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E flipped { flip(&amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E copied); }\n        \u003Cspan class=\"hljs-keyword\"\u003Ematch\u003C\u002Fspan\u003E copied.len() {\n            \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E flipped =&gt; \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003EErr\u003C\u002Fspan\u003E(SolverError::Inconsistent),\n            \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E =&gt; cdb.detach(ci),\n            \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E =&gt; {\n                \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E l0 = copied[\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E];\n                cdb.certificate_add(&amp;copied);\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E asg.assigned(l0) == \u003Cspan class=\"hljs-literal\"\u003ENone\u003C\u002Fspan\u003E {\n                    asg.assign_at_rootlevel(l0)?;\n                    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E !asg.propagate(cdb).is_none() {\n                        \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003EErr\u003C\u002Fspan\u003E(SolverError::Inconsistent);\n                    }\n                }\n                cdb.detach(ci);\n            }\n            n \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E n == clits.len() =&gt; (),\n            n =&gt; {\n                cdb.new_clause(asg, &amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E copied);\n                cdb.detach(ci);\n            }\n        }\n        clauses.retain(|ci| !cdb[ci].is(Flag::DEAD));\n    }\n    \u003Cspan class=\"hljs-literal\"\u003EOk\u003C\u002Fspan\u003E(())\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E"},dir:{writable:true,enumerable:true,value:"article\u002F.json\u002F2020"},base:{writable:true,enumerable:true,value:"2020-08-19-splr-with-vivification.json"},ext:{writable:true,enumerable:true,value:".json"},sourceBase:{writable:true,enumerable:true,value:"2020-08-19-splr-with-vivification.md"},sourceExt:{writable:true,enumerable:true,value:".md"}})}],fetch:[],mutations:[]});