__NUXT_JSONP__("/2020/2020-06-20-vivification", {data:[{article:Object.create(null,{default:{writable:true,enumerable:true,value:{title:"Vivification of a CNF formula",subtitle:"as a SAT solver's preprocessor",date:"2020-07-05T00:00:00.000Z",tags:["SAT","vivification","splr"],banner:"https:\u002F\u002Fimages.unsplash.com\u002Fphoto-1506884403171-cdb32baec15f?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1655&q=80",bodyContent:"Vivification がなんなのか、日本語で探しても出てこないので以下の論文をまとめてみた。\n（最新の話かと思っていたけど2008年とは。。。）\n\n* C. Piette, Y. Hamadi, and L. Saïs, \"Vivifying propositional clausal formulae,” *Front. Artif. Intell*. Appl., vol. 178, pp. 525–529, 2008.\n\nSplr でいうところの `processor` が節数に対する制約内での網羅的な変数除去と節包摂(clause subsumption)とを実行するのに対し、vivification は（その節に「対応」する割り当てを仮定して）propagateを行った結果を用いて節の包摂方針を決めるというもの。\n節長を減らす方向でのみ置換するので、（節数の増加と引き換えに）不要な複雑さの導入を抑えることができるらしい。\n効果は1割程度のようである。\n\nちなみに 'vivify' は論文では'shorten existing clauses'の意味で使われているが、辞書で引くと：\n\n\u003E verb: enliven or animate: outings vivify learning for children.\n\nとのこと。ぼやけていた制約の強化ということで、日本語になっているビビッドからも想像できる感じなんだろう。\n\n**cover image: https:\u002F\u002Fimages.unsplash.com\u002Fphoto-1506884403171-cdb32baec15f**\n\n# アルゴリズム（上記論文より引用）\n\n![](\u002Fimg\u002F2020\u002F06-20\u002Falgorithm1.jpg)\n\n* 6行目で $c$ を $\\Sigma$ から削除して、30行目で戻している。しかし $\\Sigma$ に対する伝播は行わないので、30行目まで残しておいても構わない。\n* 20行目の解釈： 節 $c$ が存在しない $\\Sigma_b$ において、リテラル $l$ に対して決定による割当てを行うと矛盾した（11行目）。しかし、学習節 $c_l$ は節 $c$ に含まれないなら（16行目）。これは矛盾は別の節集合によって生じたことを意味する。従ってこの節は冗長かもしれない。もし学習節 $c_l$ が節 $c$ より小さいなら（17行目）、これは節 $c$ より強い制約であるので $\\Sigma_b$ に追加する。そして節 $c$ 自身も $\\Sigma_b$ に戻した上で、節 $c$ に対する検査を終了させる（矛盾節を含む式と学習節を含む式とは充足可能性において等価である（矛盾の回避は割当て列に関する枝刈であって論理式の等価変換であることには違いない））。そうでないなら（19行目）、つまり節 $c$ （に含まれるリテラル集合）は今回の矛盾とは関係ないが今回の矛盾によって吸収できるとは言い切れない場合には、節 $c$ に含まれていたリテラル集合 $c_b$ を $\\Sigma_b$ に追加し（代わりに $c$ を削除し）て節 $c$ に対する処理を終了する（より強い制約に置き換えている？？）。\n\n\u003E 1. $\\exists i \\in \\{1, \\cdots, n-1\\}\\; s.t.\\; \\Sigma\\backslash\\{c\\} \\cup \\{\\neg l_1, \\cdots, \\neg l_i\\} \\models_{UP} \\bot$\u003Cbr\u003E In this case, we have $\\Sigma\\backslash\\{c\\} \\models_{UP} c'$ with $c' = (l_1 \\vee \\cdots \\vee l_i)$. This new clause $c'$ strictly subsumes $c$. Hence, the original clause can be substituted by the new deduced one. Obviously, $c'$ is not necessarily minimally redundant modulo UP. Indeed, another ordering on the literals $\\{l_1, l_2, \\cdots, l_i\\}$ might lead to an even shorter sub-clause. Thanks to a conflict analysis, the deduced sub-clause $c'$ could be shortened again leading to an even smaller sub-clause. Indeed, a new clause η can be generated by a complete traversal of the implication graph associated to $\\Sigma$ and to the assignments of the literals $\\{\\neg l_1, \\cdots, \\neg l_i\\}$. The complete traversal of the implication graph ensure that the clause η contains only literals from $c'$. Thereby, η is a sub-clause of $(l_1 \\vee \\cdots \\vee l_i)$.\n\n* 23, 27行目の型が合わないんだけどなあ。念のためもう一本読んでおいた方がよさそうだ。\n* $A \\leftarrow A \\cup B$ は `A.push(B);` ではなく `if !A.contains(&B) { A.push(B); }` であることに注意。\n\nもう少し説明を加えるとこういう感じ。\n\n```rust\nwhile 不動点になるまで\n    for sigma中の全ての節cに対して\n        現在のsigmaのコピーをenvとする\n        cb.clear();\n        shortened = false;\n        while !shortened && c != cb                             \u002F\u002F == until shorten || c == cb { .. }\n            c\\cbから適当にリテラルlを選ぶ\n            cbにlを追加する\n            !lを割当て伝播させる\n            if 矛盾しているなら\n                その学習節をclとする\n                if 学習節clが元々の節cを包摂するなら\n                    clをsigmaに追加; shortened = true;\n                else\n                    if cよりclの方が節長が短いなら\n                        clをsigmaに追加; cb = c;                \u002F\u002F これは終了条件, cは後でsigmaに追加される\n                    if c != cb   　　　                         \u002F\u002F ここがわからない\n                        cbをsigmaに追加; shortened = true;\n            else\n                if cの残りに含まれるリテラルlsの中で、env中に含まれるものがあるなら\n                    if cの残りがls以外のリテラルを含んでいたら\n                        cbにlsだけを追加した節を sigma に追加; shortened = true;\n                if cの残りに含まれるリテラルlsの中で、env中にその反リテラルが含まれるものがあるなら\n　　　　　　　     cからリテラルlsを除いてsigma に追加; shortened = true;\n            if shorted\n                sigma.remove(c);\n                change = true;\n```\n\n# Splr実装案\n\nこれを何も考えずにRustで書いてみるとこんな感じだろうか。\nSplr だと単位節は `cdb` に入れられないので CNF というよりも`(asg, cdb)` を持ち回るとした方が現実的かも。\n\n```rust\n\u002F\u002F\u002F Vivification of a given CNF formula, returning a vivified CNF formula\n\u002F\u002F\u002F Note: `remove` used here is a non-destructive function (`Fn\u003CT\u003E([T]) -\u003E Vec\u003CT\u003E`).\nfn vivify(mut sigma: (AssginStack, ClauseDB)) {\n    let mut env: (AssignStack, ClauseDB);\n    let mut change: bool = true;\n    let mut shortened: bool = true;\n    let mut cb: Vec\u003CLit\u003E = Vec::new();\n    let mut ci: usize;\n    while change {\n        change = false;\n        ci = 0;\n        while ci \u003C sigma.len() {\n            let mut c = &mut sigma[ci];\n            let c_len = c.len();\n            ci += 1;\n            env = sigma.clone();\n            env.remove_clause(ci);\n            cb.clear();\n            shortened = false;\n            while !shortened && c != cb {\n                let cx = c.remove_items(cb);\n                l = select_literal(cx);\n                cb.push(l);                                     \u002F\u002F cb = cb ∪ {l};\n                env.add_assignment(!l);                         \u002F\u002F Σb ← (Σb ∪ {¬l})\n                if let Some(ls) = env.propagate() {             \u002F\u002F ⊥ ∈ UP(Σb)\n                    let learnt = conflict_analyze();            \u002F\u002F returns a learnt clause\n                    if learnt.iter().all(|l| c.includes(l)) {   \u002F\u002F cl ⊂ c\n                        sigma.new_clause(learnt);               \u002F\u002F Σ ← Σ ∪ {cl}\n                        shortened = true;\n                    } else {\n                        if learnt.len() == c_len {\n                            sigma.new_clause(learnt);           \u002F\u002F Σ ← Σ ∪ {cl}\n                            cb = c;\n                        }\n                        if c != cb {\n                            sigma.new_clause(cb);               \u002F\u002F Σ ← Σ ∪ {cb}\n                            shortened = true;\n                        }\n                    }\n                } else {\n                    if let Some(ls) = cx.iter().find(|l| env.contains(l)) { \u002F\u002F ∃(ls ∈ (c\\cb))\n                        if 1 \u003C cx.len() {                       \u002F\u002F (c\\cb) \u002F= {ls}\n                            sigma.new_clause(cb.push(ls));      \u002F\u002F Σ ← Σ ∪ {cb ∪ {ls}} ;\n                            shortened = true;\n                        }\n                    }\n                    if let Some(ls) = cx.iter().find(|l| env.contains(!l)) { \u002F\u002F ∃(¬ls ∈ (c\\cb))\n                        sigma.new_clause(c.remove(ls));         \u002F\u002F Σ ← Σ ∪ {c\\{ls}}\n                        shortened = true;\n                    }\n                }\n                if shortened {\n                    sigma.kill(c);\n                    change = true;\n                }\n            }\n        }\n    }\n    \u002F\u002F return sigma;\n}\n```\n\n## 2020-06-23\n\n`AssignStack` や `ClauseDB` のコピーはコストが大きいので $\\Sigma$ だけで対応したい。\n\n* $\\Sigma$ と `env` の違いは$l$の割り当てをもつかどうか。これは割り当てをキャンセルできればいいはず。\n* 内側のwhile文中で $\\Sigma$ に対して節や割り当てを追加しているので、これを遅延させる。\n* `assign`, `conflict_analysis`, `cancel_until`を呼び出すので変数および節の活性度が影響を受ける。どうしたものか。\n\n```rust\nfn vivify(mut sigma: (AssginStack, ClauseDB)) {\n    let mut change: bool = true;\n    while change {\n        change = false;\n        let mut ci: usize = 0;\n        let mut clauses: Vec\u003CVec\u003CLit\u003E\u003E = Vec::new();\n        while ci \u003C sigma.len() {\n            let mut c = &mut sigma[ci];\n            let c_lits = c.lits.clone();\n            let c_len = c.len();\n            let dl = sigma.decision_level();\n            i += 1;\n            sigma.remove_clause(ci);\n            let mut cb: Vec\u003CLit\u003E = Vec::new();\n            let mut shortened = false;\n            while !shortened && c != cb {\n                let cx = c.remove_items(cb);\n                l = select_literal(cx);\n                cb.push(l);                                     \u002F\u002F cb = cb ∪ {l};\n                sigma.assign_by_decision(!l);                   \u002F\u002F Σb ← (Σb ∪ {¬l})\n                if let Some(ls) = sigma.propagate() {           \u002F\u002F ⊥ ∈ UP(Σb)\n                    let learnt = conflict_analyze();            \u002F\u002F returns a learnt clause\n                    if learnt.iter().all(|l| c.includes(l)) {   \u002F\u002F cl ⊂ c\n                        clauses.push(learnt);                   \u002F\u002F MODIFIED: Σ ← Σ ∪ {cl}\n                        shortened = true;\n                    } else {\n                        if learnt.len() == c_len {\n                            clauses.push(learnt);               \u002F\u002F MODIFIED: Σ ← Σ ∪ {cl}\n                            cb = c;\n                        }\n                        if c != cb {\n                            clauses.push(cb);                   \u002F\u002F MODIFIED: Σ ← Σ ∪ {cb}\n                            shortened = true;\n                        }\n                    }\n                } else {\n                    if let Some(ls) = cx.iter().find(|l| sigma.contains(l)) { \u002F\u002F ∃(ls ∈ (c\\cb))\n                        if 1 \u003C cx.len() {                       \u002F\u002F (c\\cb) \u002F= {ls}\n                            clauses.push(cb.push(ls));          \u002F\u002F MODIFIED: Σ ← Σ ∪ {cb ∪ {ls}} ;\n                            shortened = true;\n                        }\n                    }\n                    if let Some(ls) = cx.iter().find(|l| sigma.contains(!l)) { \u002F\u002F ∃(¬ls ∈ (c\\cb))\n                        clauses.push(c.remove(ls));             \u002F\u002F MODIFIED: Σ ← Σ ∪ {c\\{ls}}\n                        shortened = true;\n                    }\n                }\n                if !shortened {\n                    sigma.new_clause(c_lits);\n                } else {\n                    change = true;\n                }\n                sigma.cancel_until(dl);\n            }\n            for c in &clauses {\n                if c.len() == 1 {\n                    sigma.new_assignment(c[0]);\n                } else {\n                    sigma.new_clause(c);\n                }\n            }\n        }\n    }\n}\n```\n\nこれでどうだろうか。実装してみなくては。\n\nこうしてみると、統計的ソルバの手法みたい。\n\n\n## 2020-06-24\n\nめちゃくちゃ重い！ vivifyに10000秒くらい掛かりそうだ。\n節に含まれるリテラル全てに対して伝播検査をしているのだから当然ではある。\nとりあえず先頭のリテラルだけの伝播にしてみたのだが、それでも論外。\n`propagate`で矛盾が検出されたときの依存グラフをキャッシュに残すようにするとどうだろうか。。。\n\n* `conflict_analyze`のカスタムバージョンが必要 -- TODO\n* cidが GCで変わってしまう -- しかしこれは `shortened` の時にpurgeすればいい。\n* purgeされるリテラルが多すぎてヒット率が低いのではないか -- no idea\n* 矛盾が発生する場合は結果をキャッシュできるが、そうでない場合は有用ではないのでは -- うーむ\n\n```rust\ntype ConflictDep = HashMap\u003CLit, (bool, HashSet\u003CClauseId\u003E, Vec\u003CLit\u003E)\u003E\n\nimpl ConflictDep {\n    fn clear(&mut self, l: Lit) { ... }\n    fn put(&mut self, l: Lit, ...) { ... }\n    fn purge(&mut self, l: Lit) { ... }\n}\n```\n\n## 2020-06-26\n\nもう少し軽いキャッシュを実装してみた。\n無矛盾時の処理をサボっても論理的には間違いではないので、一度調べたリテラルの伝播結果をキャッシュすると(assign $\\to$ propagate $\\to$ cancel_until)の一連の処理が減らせる。\nとにかく網羅速度を上げなければ。\n\n## 2020-06-27\n\nvivificationは`propagate`や`cancel_until`など多くの機能を流用しているが、sandbox化しなくていいだろうか。\n\n* 各種計数カウンタは切り離すべき\n* 変数活性度は取り込むべき。理由はどうであれ伝播の結果わかった統計情報なのだから。\n* ただし変数活性度の計算にはいくつかのカウンタは正しく動いている（更新される）ことが必要なので、計数カウンタを止めたサンドボックスを作るよりもvivify後に増分をキャンセルすることが必要かも。\n\n## 2020-06-29\n\nアルゴリズムの理解進展。いろいろ突っ込みどころを見つけて、反映したバージョンがこちら。\n\n* 23行目と27行目が同時に成立することはない\n* 30行目はwhileの中に入れる必要はない\n* キャッシュは意味がない。多くの場合すぐに`break`しているから。\n\n```rust\nfn vivify(asg: &mut AssignStack, cdb: &mut ClauseDB) {\n    let mut changed: bool = true;\n    while changed {\n        changed = false;\n        for c in &clauses {\n            let clits = c.lits.clone();\n            let mut shortened = false;\n            let mut new_clause: Vec\u003CLit\u003E = Vec::new();\n            cdb.delete_clause(c);\n            for (i, l) in clits.iter().enumerate() {\n                asg.assign_by_decision(!*l);\n                if asg.propagate(cdb) == ⊥ {\n                    let learnt = conflict_analyze_and_learnt(asg, cdb);\n                    if learnt.iter().all(|l| clits.contains(l)) {\n                        new_clause = learnt.clone();\n                        shortened = true;\n                    } else {\n                        if learnt.len() \u003C clits.len() {\n                            asg.cancel_until(asg.root_level);\n                            break;\n                        }\n                        if i \u003C clits.len() - 1 {\n                            new_clause = clits[..=i].to_vec();\n                            shortened = true;\n                        }\n                    }\n                } else if let Some(ls) = clits[i + 1..].iter().find(|l| asg.assigned(**l) == Some(true)) {\n                    if i \u003C clits.len() - 1 {\n                        new_clause = clits[..=i].to_vec();\n                        new_clause.push(*ls);\n                        shortened = true;\n                    }\n                } else if let Some(ls) = clits[i + 1..].iter().find(|l| asg.assigned(!**l) == Some(true)) {\n                    new_clause = clits.iter().copied().filter(|l| l != ls).collect::\u003CVec\u003C_\u003E\u003E();\n                    shortened = true;\n                }\n                asg.cancel_until(asg.root_level);\n                if shortened {\n                    break;\n                }\n            }\n            if shortened {\n                if new_clause.len() == 1 {\n                    asg.assign_at_rootlevel(new_clause[0]);\n                } else {\n                    cdb.new_clause(asg, new_clause);\n                }\n                changed = true;\n            } else {\n                cdb.new_clause(asg, clits);\n            }\n        }\n    }\n}\n```\n\n## 2020-07-01\n\nやはり、vivification中の活性度修正はしない方がよさそうだ。確かに外乱ではある。\nそして、短くなった節にはrewardを受け継がせなければ。。。\n\n## 2020-07-04\n\n`cancel_until`を呼び出す場所を間違っていた。今のままだと、新しい節は空節から始まってだんだん長くなっていくのではなく、常に単位節ということになる。正しいように修正したら遅くなった。\nまあ確かにヒューリスティックスとして全てのリテラルを確かめるというのはあるかもしれないが、論文通りにすべきではなかろうか。。。\n\n## 2020-07-05\n\nベンチマークを実行してみると少しは効果がありました。\nしかし、そろそろ新しい論文の方を読んで検討すべき頃合いだろう（もっと早く読めって）。\n長さ的にもいい頃合いなので、[項を改めて](\u002F2020\u002F2020-07-05-vivification2\u002F)検討を続けることにします。",bodyHtml:"\u003Cp\u003EVivification がなんなのか、日本語で探しても出てこないので以下の論文をまとめてみた。\n（最新の話かと思っていたけど2008年とは。。。）\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EC. Piette, Y. Hamadi, and L. Saïs, &quot;Vivifying propositional clausal formulae,” \u003Cem\u003EFront. Artif. Intell\u003C\u002Fem\u003E. Appl., vol. 178, pp. 525–529, 2008.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003ESplr でいうところの \u003Ccode\u003Eprocessor\u003C\u002Fcode\u003E が節数に対する制約内での網羅的な変数除去と節包摂(clause subsumption)とを実行するのに対し、vivification は（その節に「対応」する割り当てを仮定して）propagateを行った結果を用いて節の包摂方針を決めるというもの。\n節長を減らす方向でのみ置換するので、（節数の増加と引き換えに）不要な複雑さの導入を抑えることができるらしい。\n効果は1割程度のようである。\u003C\u002Fp\u003E\n\u003Cp\u003Eちなみに 'vivify' は論文では'shorten existing clauses'の意味で使われているが、辞書で引くと：\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003Everb: enliven or animate: outings vivify learning for children.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003Eとのこと。ぼやけていた制約の強化ということで、日本語になっているビビッドからも想像できる感じなんだろう。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003Ecover image: https:\u002F\u002Fimages.unsplash.com\u002Fphoto-1506884403171-cdb32baec15f\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Ch1\u003Eアルゴリズム（上記論文より引用）\u003C\u002Fh1\u003E\n\u003Cp\u003E\u003Cimg src=\"\u002Fimg\u002F2020\u002F06-20\u002Falgorithm1.jpg\" alt=\"\"\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E6行目で $c$ を $\\Sigma$ から削除して、30行目で戻している。しかし $\\Sigma$ に対する伝播は行わないので、30行目まで残しておいても構わない。\u003C\u002Fli\u003E\n\u003Cli\u003E20行目の解釈： 節 $c$ が存在しない $\\Sigma_b$ において、リテラル $l$ に対して決定による割当てを行うと矛盾した（11行目）。しかし、学習節 $c_l$ は節 $c$ に含まれないなら（16行目）。これは矛盾は別の節集合によって生じたことを意味する。従ってこの節は冗長かもしれない。もし学習節 $c_l$ が節 $c$ より小さいなら（17行目）、これは節 $c$ より強い制約であるので $\\Sigma_b$ に追加する。そして節 $c$ 自身も $\\Sigma_b$ に戻した上で、節 $c$ に対する検査を終了させる（矛盾節を含む式と学習節を含む式とは充足可能性において等価である（矛盾の回避は割当て列に関する枝刈であって論理式の等価変換であることには違いない））。そうでないなら（19行目）、つまり節 $c$ （に含まれるリテラル集合）は今回の矛盾とは関係ないが今回の矛盾によって吸収できるとは言い切れない場合には、節 $c$ に含まれていたリテラル集合 $c_b$ を $\\Sigma_b$ に追加し（代わりに $c$ を削除し）て節 $c$ に対する処理を終了する（より強い制約に置き換えている？？）。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cblockquote\u003E\n\u003Col\u003E\n\u003Cli\u003E$\\exists i \\in {1, \\cdots, n-1}; s.t.; \\Sigma\\backslash{c} \\cup {\\neg l_1, \\cdots, \\neg l_i} \\models_{UP} \\bot$&lt;br&gt; In this case, we have $\\Sigma\\backslash{c} \\models_{UP} c'$ with $c' = (l_1 \\vee \\cdots \\vee l_i)$. This new clause $c'$ strictly subsumes $c$. Hence, the original clause can be substituted by the new deduced one. Obviously, $c'$ is not necessarily minimally redundant modulo UP. Indeed, another ordering on the literals ${l_1, l_2, \\cdots, l_i}$ might lead to an even shorter sub-clause. Thanks to a conflict analysis, the deduced sub-clause $c'$ could be shortened again leading to an even smaller sub-clause. Indeed, a new clause η can be generated by a complete traversal of the implication graph associated to $\\Sigma$ and to the assignments of the literals ${\\neg l_1, \\cdots, \\neg l_i}$. The complete traversal of the implication graph ensure that the clause η contains only literals from $c'$. Thereby, η is a sub-clause of $(l_1 \\vee \\cdots \\vee l_i)$.\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cul\u003E\n\u003Cli\u003E23, 27行目の型が合わないんだけどなあ。念のためもう一本読んでおいた方がよさそうだ。\u003C\u002Fli\u003E\n\u003Cli\u003E$A \\leftarrow A \\cup B$ は \u003Ccode\u003EA.push(B);\u003C\u002Fcode\u003E ではなく \u003Ccode\u003Eif !A.contains(&amp;B) { A.push(B); }\u003C\u002Fcode\u003E であることに注意。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003Eもう少し説明を加えるとこういう感じ。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E 不動点になるまで\n    \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E sigma中の全ての節cに対して\n        現在のsigmaのコピーをenvとする\n        cb.clear();\n        shortened = \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E;\n        \u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E !shortened &amp;&amp; c != cb                             \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F == until shorten || c == cb { .. }\u003C\u002Fspan\u003E\n            c\\cbから適当にリテラルlを選ぶ\n            cbにlを追加する\n            !lを割当て伝播させる\n            \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E 矛盾しているなら\n                その学習節をclとする\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E 学習節clが元々の節cを包摂するなら\n                    clをsigmaに追加; shortened = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n                \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E\n                    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E cよりclの方が節長が短いなら\n                        clをsigmaに追加; cb = c;                \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F これは終了条件, cは後でsigmaに追加される\u003C\u002Fspan\u003E\n                    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E c != cb   　　　                         \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F ここがわからない\u003C\u002Fspan\u003E\n                        cbをsigmaに追加; shortened = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n            \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E cの残りに含まれるリテラルlsの中で、env中に含まれるものがあるなら\n                    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E cの残りがls以外のリテラルを含んでいたら\n                        cbにlsだけを追加した節を sigma に追加; shortened = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E cの残りに含まれるリテラルlsの中で、env中にその反リテラルが含まれるものがあるなら\n　　　　　　　     cからリテラルlsを除いてsigma に追加; shortened = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n            \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E shorted\n                sigma.remove(c);\n                change = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch1\u003ESplr実装案\u003C\u002Fh1\u003E\n\u003Cp\u003Eこれを何も考えずにRustで書いてみるとこんな感じだろうか。\nSplr だと単位節は \u003Ccode\u003Ecdb\u003C\u002Fcode\u003E に入れられないので CNF というよりも\u003Ccode\u003E(asg, cdb)\u003C\u002Fcode\u003E を持ち回るとした方が現実的かも。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F\u002F Vivification of a given CNF formula, returning a vivified CNF formula\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F\u002F Note: `remove` used here is a non-destructive function (`Fn&lt;T&gt;([T]) -&gt; Vec&lt;T&gt;`).\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Evivify\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E sigma: (AssginStack, ClauseDB)) {\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E env: (AssignStack, ClauseDB);\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E change: \u003Cspan class=\"hljs-built_in\"\u003Ebool\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E shortened: \u003Cspan class=\"hljs-built_in\"\u003Ebool\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E cb: \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;Lit&gt; = \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E::new();\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E ci: \u003Cspan class=\"hljs-built_in\"\u003Eusize\u003C\u002Fspan\u003E;\n    \u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E change {\n        change = \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E;\n        ci = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E;\n        \u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E ci &lt; sigma.len() {\n            \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E c = &amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E sigma[ci];\n            \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E c_len = c.len();\n            ci += \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E;\n            env = sigma.clone();\n            env.remove_clause(ci);\n            cb.clear();\n            shortened = \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E;\n            \u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E !shortened &amp;&amp; c != cb {\n                \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E cx = c.remove_items(cb);\n                l = select_literal(cx);\n                cb.push(l);                                     \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F cb = cb ∪ {l};\u003C\u002Fspan\u003E\n                env.add_assignment(!l);                         \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Σb ← (Σb ∪ {¬l})\u003C\u002Fspan\u003E\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003ESome\u003C\u002Fspan\u003E(ls) = env.propagate() {             \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F ⊥ ∈ UP(Σb)\u003C\u002Fspan\u003E\n                    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E learnt = conflict_analyze();            \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F returns a learnt clause\u003C\u002Fspan\u003E\n                    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E learnt.iter().all(|l| c.includes(l)) {   \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F cl ⊂ c\u003C\u002Fspan\u003E\n                        sigma.new_clause(learnt);               \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Σ ← Σ ∪ {cl}\u003C\u002Fspan\u003E\n                        shortened = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n                    } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n                        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E learnt.len() == c_len {\n                            sigma.new_clause(learnt);           \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Σ ← Σ ∪ {cl}\u003C\u002Fspan\u003E\n                            cb = c;\n                        }\n                        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E c != cb {\n                            sigma.new_clause(cb);               \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Σ ← Σ ∪ {cb}\u003C\u002Fspan\u003E\n                            shortened = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n                        }\n                    }\n                } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n                    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003ESome\u003C\u002Fspan\u003E(ls) = cx.iter().find(|l| env.contains(l)) { \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F ∃(ls ∈ (c\\cb))\u003C\u002Fspan\u003E\n                        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E &lt; cx.len() {                       \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F (c\\cb) \u002F= {ls}\u003C\u002Fspan\u003E\n                            sigma.new_clause(cb.push(ls));      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Σ ← Σ ∪ {cb ∪ {ls}} ;\u003C\u002Fspan\u003E\n                            shortened = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n                        }\n                    }\n                    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003ESome\u003C\u002Fspan\u003E(ls) = cx.iter().find(|l| env.contains(!l)) { \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F ∃(¬ls ∈ (c\\cb))\u003C\u002Fspan\u003E\n                        sigma.new_clause(c.remove(ls));         \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Σ ← Σ ∪ {c\\{ls}}\u003C\u002Fspan\u003E\n                        shortened = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n                    }\n                }\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E shortened {\n                    sigma.kill(c);\n                    change = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n                }\n            }\n        }\n    }\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F return sigma;\u003C\u002Fspan\u003E\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch2\u003E2020-06-23\u003C\u002Fh2\u003E\n\u003Cp\u003E\u003Ccode\u003EAssignStack\u003C\u002Fcode\u003E や \u003Ccode\u003EClauseDB\u003C\u002Fcode\u003E のコピーはコストが大きいので $\\Sigma$ だけで対応したい。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E$\\Sigma$ と \u003Ccode\u003Eenv\u003C\u002Fcode\u003E の違いは$l$の割り当てをもつかどうか。これは割り当てをキャンセルできればいいはず。\u003C\u002Fli\u003E\n\u003Cli\u003E内側のwhile文中で $\\Sigma$ に対して節や割り当てを追加しているので、これを遅延させる。\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eassign\u003C\u002Fcode\u003E, \u003Ccode\u003Econflict_analysis\u003C\u002Fcode\u003E, \u003Ccode\u003Ecancel_until\u003C\u002Fcode\u003Eを呼び出すので変数および節の活性度が影響を受ける。どうしたものか。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Evivify\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E sigma: (AssginStack, ClauseDB)) {\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E change: \u003Cspan class=\"hljs-built_in\"\u003Ebool\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n    \u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E change {\n        change = \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E;\n        \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E ci: \u003Cspan class=\"hljs-built_in\"\u003Eusize\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E;\n        \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E clauses: \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;\u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;Lit&gt;&gt; = \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E::new();\n        \u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E ci &lt; sigma.len() {\n            \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E c = &amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E sigma[ci];\n            \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E c_lits = c.lits.clone();\n            \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E c_len = c.len();\n            \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E dl = sigma.decision_level();\n            i += \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E;\n            sigma.remove_clause(ci);\n            \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E cb: \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;Lit&gt; = \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E::new();\n            \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E shortened = \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E;\n            \u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E !shortened &amp;&amp; c != cb {\n                \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E cx = c.remove_items(cb);\n                l = select_literal(cx);\n                cb.push(l);                                     \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F cb = cb ∪ {l};\u003C\u002Fspan\u003E\n                sigma.assign_by_decision(!l);                   \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Σb ← (Σb ∪ {¬l})\u003C\u002Fspan\u003E\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003ESome\u003C\u002Fspan\u003E(ls) = sigma.propagate() {           \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F ⊥ ∈ UP(Σb)\u003C\u002Fspan\u003E\n                    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E learnt = conflict_analyze();            \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F returns a learnt clause\u003C\u002Fspan\u003E\n                    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E learnt.iter().all(|l| c.includes(l)) {   \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F cl ⊂ c\u003C\u002Fspan\u003E\n                        clauses.push(learnt);                   \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F MODIFIED: Σ ← Σ ∪ {cl}\u003C\u002Fspan\u003E\n                        shortened = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n                    } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n                        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E learnt.len() == c_len {\n                            clauses.push(learnt);               \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F MODIFIED: Σ ← Σ ∪ {cl}\u003C\u002Fspan\u003E\n                            cb = c;\n                        }\n                        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E c != cb {\n                            clauses.push(cb);                   \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F MODIFIED: Σ ← Σ ∪ {cb}\u003C\u002Fspan\u003E\n                            shortened = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n                        }\n                    }\n                } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n                    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003ESome\u003C\u002Fspan\u003E(ls) = cx.iter().find(|l| sigma.contains(l)) { \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F ∃(ls ∈ (c\\cb))\u003C\u002Fspan\u003E\n                        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E &lt; cx.len() {                       \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F (c\\cb) \u002F= {ls}\u003C\u002Fspan\u003E\n                            clauses.push(cb.push(ls));          \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F MODIFIED: Σ ← Σ ∪ {cb ∪ {ls}} ;\u003C\u002Fspan\u003E\n                            shortened = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n                        }\n                    }\n                    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003ESome\u003C\u002Fspan\u003E(ls) = cx.iter().find(|l| sigma.contains(!l)) { \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F ∃(¬ls ∈ (c\\cb))\u003C\u002Fspan\u003E\n                        clauses.push(c.remove(ls));             \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F MODIFIED: Σ ← Σ ∪ {c\\{ls}}\u003C\u002Fspan\u003E\n                        shortened = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n                    }\n                }\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E !shortened {\n                    sigma.new_clause(c_lits);\n                } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n                    change = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n                }\n                sigma.cancel_until(dl);\n            }\n            \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E c \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E &amp;clauses {\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E c.len() == \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E {\n                    sigma.new_assignment(c[\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E]);\n                } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n                    sigma.new_clause(c);\n                }\n            }\n        }\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eこれでどうだろうか。実装してみなくては。\u003C\u002Fp\u003E\n\u003Cp\u003Eこうしてみると、統計的ソルバの手法みたい。\u003C\u002Fp\u003E\n\u003Ch2\u003E2020-06-24\u003C\u002Fh2\u003E\n\u003Cp\u003Eめちゃくちゃ重い！ vivifyに10000秒くらい掛かりそうだ。\n節に含まれるリテラル全てに対して伝播検査をしているのだから当然ではある。\nとりあえず先頭のリテラルだけの伝播にしてみたのだが、それでも論外。\n\u003Ccode\u003Epropagate\u003C\u002Fcode\u003Eで矛盾が検出されたときの依存グラフをキャッシュに残すようにするとどうだろうか。。。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003Econflict_analyze\u003C\u002Fcode\u003Eのカスタムバージョンが必要 -- TODO\u003C\u002Fli\u003E\n\u003Cli\u003Ecidが GCで変わってしまう -- しかしこれは \u003Ccode\u003Eshortened\u003C\u002Fcode\u003E の時にpurgeすればいい。\u003C\u002Fli\u003E\n\u003Cli\u003Epurgeされるリテラルが多すぎてヒット率が低いのではないか -- no idea\u003C\u002Fli\u003E\n\u003Cli\u003E矛盾が発生する場合は結果をキャッシュできるが、そうでない場合は有用ではないのでは -- うーむ\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Etype\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EConflictDep\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E = HashMap&lt;Lit, (\u003Cspan class=\"hljs-built_in\"\u003Ebool\u003C\u002Fspan\u003E, HashSet&lt;ClauseId&gt;, \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;Lit&gt;)&gt;\n\n\u003Cspan class=\"hljs-keyword\"\u003Eimpl\u003C\u002Fspan\u003E ConflictDep {\n    \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eclear\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E, l: Lit) { ... }\n    \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eput\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E, l: Lit, ...) { ... }\n    \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Epurge\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E, l: Lit) { ... }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch2\u003E2020-06-26\u003C\u002Fh2\u003E\n\u003Cp\u003Eもう少し軽いキャッシュを実装してみた。\n無矛盾時の処理をサボっても論理的には間違いではないので、一度調べたリテラルの伝播結果をキャッシュすると(assign $\\to$ propagate $\\to$ cancel_until)の一連の処理が減らせる。\nとにかく網羅速度を上げなければ。\u003C\u002Fp\u003E\n\u003Ch2\u003E2020-06-27\u003C\u002Fh2\u003E\n\u003Cp\u003Evivificationは\u003Ccode\u003Epropagate\u003C\u002Fcode\u003Eや\u003Ccode\u003Ecancel_until\u003C\u002Fcode\u003Eなど多くの機能を流用しているが、sandbox化しなくていいだろうか。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E各種計数カウンタは切り離すべき\u003C\u002Fli\u003E\n\u003Cli\u003E変数活性度は取り込むべき。理由はどうであれ伝播の結果わかった統計情報なのだから。\u003C\u002Fli\u003E\n\u003Cli\u003Eただし変数活性度の計算にはいくつかのカウンタは正しく動いている（更新される）ことが必要なので、計数カウンタを止めたサンドボックスを作るよりもvivify後に増分をキャンセルすることが必要かも。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch2\u003E2020-06-29\u003C\u002Fh2\u003E\n\u003Cp\u003Eアルゴリズムの理解進展。いろいろ突っ込みどころを見つけて、反映したバージョンがこちら。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E23行目と27行目が同時に成立することはない\u003C\u002Fli\u003E\n\u003Cli\u003E30行目はwhileの中に入れる必要はない\u003C\u002Fli\u003E\n\u003Cli\u003Eキャッシュは意味がない。多くの場合すぐに\u003Ccode\u003Ebreak\u003C\u002Fcode\u003Eしているから。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Evivify\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(asg: &amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E AssignStack, cdb: &amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E ClauseDB) {\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E changed: \u003Cspan class=\"hljs-built_in\"\u003Ebool\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n    \u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E changed {\n        changed = \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E;\n        \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E c \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E &amp;clauses {\n            \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E clits = c.lits.clone();\n            \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E shortened = \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E;\n            \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E new_clause: \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;Lit&gt; = \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E::new();\n            cdb.delete_clause(c);\n            \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E (i, l) \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E clits.iter().enumerate() {\n                asg.assign_by_decision(!*l);\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E asg.propagate(cdb) == ⊥ {\n                    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E learnt = conflict_analyze_and_learnt(asg, cdb);\n                    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E learnt.iter().all(|l| clits.contains(l)) {\n                        new_clause = learnt.clone();\n                        shortened = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n                    } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n                        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E learnt.len() &lt; clits.len() {\n                            asg.cancel_until(asg.root_level);\n                            \u003Cspan class=\"hljs-keyword\"\u003Ebreak\u003C\u002Fspan\u003E;\n                        }\n                        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E i &lt; clits.len() - \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E {\n                            new_clause = clits[..=i].to_vec();\n                            shortened = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n                        }\n                    }\n                } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003ESome\u003C\u002Fspan\u003E(ls) = clits[i + \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E..].iter().find(|l| asg.assigned(**l) == \u003Cspan class=\"hljs-literal\"\u003ESome\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E)) {\n                    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E i &lt; clits.len() - \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E {\n                        new_clause = clits[..=i].to_vec();\n                        new_clause.push(*ls);\n                        shortened = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n                    }\n                } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003ESome\u003C\u002Fspan\u003E(ls) = clits[i + \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E..].iter().find(|l| asg.assigned(!**l) == \u003Cspan class=\"hljs-literal\"\u003ESome\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E)) {\n                    new_clause = clits.iter().copied().filter(|l| l != ls).collect::&lt;\u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;_&gt;&gt;();\n                    shortened = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n                }\n                asg.cancel_until(asg.root_level);\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E shortened {\n                    \u003Cspan class=\"hljs-keyword\"\u003Ebreak\u003C\u002Fspan\u003E;\n                }\n            }\n            \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E shortened {\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E new_clause.len() == \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E {\n                    asg.assign_at_rootlevel(new_clause[\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E]);\n                } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n                    cdb.new_clause(asg, new_clause);\n                }\n                changed = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n            } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n                cdb.new_clause(asg, clits);\n            }\n        }\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch2\u003E2020-07-01\u003C\u002Fh2\u003E\n\u003Cp\u003Eやはり、vivification中の活性度修正はしない方がよさそうだ。確かに外乱ではある。\nそして、短くなった節にはrewardを受け継がせなければ。。。\u003C\u002Fp\u003E\n\u003Ch2\u003E2020-07-04\u003C\u002Fh2\u003E\n\u003Cp\u003E\u003Ccode\u003Ecancel_until\u003C\u002Fcode\u003Eを呼び出す場所を間違っていた。今のままだと、新しい節は空節から始まってだんだん長くなっていくのではなく、常に単位節ということになる。正しいように修正したら遅くなった。\nまあ確かにヒューリスティックスとして全てのリテラルを確かめるというのはあるかもしれないが、論文通りにすべきではなかろうか。。。\u003C\u002Fp\u003E\n\u003Ch2\u003E2020-07-05\u003C\u002Fh2\u003E\n\u003Cp\u003Eベンチマークを実行してみると少しは効果がありました。\nしかし、そろそろ新しい論文の方を読んで検討すべき頃合いだろう（もっと早く読めって）。\n長さ的にもいい頃合いなので、\u003Ca href=\"\u002F2020\u002F2020-07-05-vivification2\u002F\"\u003E項を改めて\u003C\u002Fa\u003E検討を続けることにします。\u003C\u002Fp\u003E\n",dir:"article\u002F.json\u002F2020",base:"2020-06-20-vivification.json",ext:".json",sourceBase:"2020-06-20-vivification.md",sourceExt:".md"}},title:{writable:true,enumerable:true,value:"Vivification of a CNF formula"},subtitle:{writable:true,enumerable:true,value:"as a SAT solver's preprocessor"},date:{writable:true,enumerable:true,value:"2020-07-05T00:00:00.000Z"},tags:{writable:true,enumerable:true,value:["SAT","vivification","splr"]},banner:{writable:true,enumerable:true,value:"https:\u002F\u002Fimages.unsplash.com\u002Fphoto-1506884403171-cdb32baec15f?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1655&q=80"},bodyContent:{writable:true,enumerable:true,value:"Vivification がなんなのか、日本語で探しても出てこないので以下の論文をまとめてみた。\n（最新の話かと思っていたけど2008年とは。。。）\n\n* C. Piette, Y. Hamadi, and L. Saïs, \"Vivifying propositional clausal formulae,” *Front. Artif. Intell*. Appl., vol. 178, pp. 525–529, 2008.\n\nSplr でいうところの `processor` が節数に対する制約内での網羅的な変数除去と節包摂(clause subsumption)とを実行するのに対し、vivification は（その節に「対応」する割り当てを仮定して）propagateを行った結果を用いて節の包摂方針を決めるというもの。\n節長を減らす方向でのみ置換するので、（節数の増加と引き換えに）不要な複雑さの導入を抑えることができるらしい。\n効果は1割程度のようである。\n\nちなみに 'vivify' は論文では'shorten existing clauses'の意味で使われているが、辞書で引くと：\n\n\u003E verb: enliven or animate: outings vivify learning for children.\n\nとのこと。ぼやけていた制約の強化ということで、日本語になっているビビッドからも想像できる感じなんだろう。\n\n**cover image: https:\u002F\u002Fimages.unsplash.com\u002Fphoto-1506884403171-cdb32baec15f**\n\n# アルゴリズム（上記論文より引用）\n\n![](\u002Fimg\u002F2020\u002F06-20\u002Falgorithm1.jpg)\n\n* 6行目で $c$ を $\\Sigma$ から削除して、30行目で戻している。しかし $\\Sigma$ に対する伝播は行わないので、30行目まで残しておいても構わない。\n* 20行目の解釈： 節 $c$ が存在しない $\\Sigma_b$ において、リテラル $l$ に対して決定による割当てを行うと矛盾した（11行目）。しかし、学習節 $c_l$ は節 $c$ に含まれないなら（16行目）。これは矛盾は別の節集合によって生じたことを意味する。従ってこの節は冗長かもしれない。もし学習節 $c_l$ が節 $c$ より小さいなら（17行目）、これは節 $c$ より強い制約であるので $\\Sigma_b$ に追加する。そして節 $c$ 自身も $\\Sigma_b$ に戻した上で、節 $c$ に対する検査を終了させる（矛盾節を含む式と学習節を含む式とは充足可能性において等価である（矛盾の回避は割当て列に関する枝刈であって論理式の等価変換であることには違いない））。そうでないなら（19行目）、つまり節 $c$ （に含まれるリテラル集合）は今回の矛盾とは関係ないが今回の矛盾によって吸収できるとは言い切れない場合には、節 $c$ に含まれていたリテラル集合 $c_b$ を $\\Sigma_b$ に追加し（代わりに $c$ を削除し）て節 $c$ に対する処理を終了する（より強い制約に置き換えている？？）。\n\n\u003E 1. $\\exists i \\in \\{1, \\cdots, n-1\\}\\; s.t.\\; \\Sigma\\backslash\\{c\\} \\cup \\{\\neg l_1, \\cdots, \\neg l_i\\} \\models_{UP} \\bot$\u003Cbr\u003E In this case, we have $\\Sigma\\backslash\\{c\\} \\models_{UP} c'$ with $c' = (l_1 \\vee \\cdots \\vee l_i)$. This new clause $c'$ strictly subsumes $c$. Hence, the original clause can be substituted by the new deduced one. Obviously, $c'$ is not necessarily minimally redundant modulo UP. Indeed, another ordering on the literals $\\{l_1, l_2, \\cdots, l_i\\}$ might lead to an even shorter sub-clause. Thanks to a conflict analysis, the deduced sub-clause $c'$ could be shortened again leading to an even smaller sub-clause. Indeed, a new clause η can be generated by a complete traversal of the implication graph associated to $\\Sigma$ and to the assignments of the literals $\\{\\neg l_1, \\cdots, \\neg l_i\\}$. The complete traversal of the implication graph ensure that the clause η contains only literals from $c'$. Thereby, η is a sub-clause of $(l_1 \\vee \\cdots \\vee l_i)$.\n\n* 23, 27行目の型が合わないんだけどなあ。念のためもう一本読んでおいた方がよさそうだ。\n* $A \\leftarrow A \\cup B$ は `A.push(B);` ではなく `if !A.contains(&B) { A.push(B); }` であることに注意。\n\nもう少し説明を加えるとこういう感じ。\n\n```rust\nwhile 不動点になるまで\n    for sigma中の全ての節cに対して\n        現在のsigmaのコピーをenvとする\n        cb.clear();\n        shortened = false;\n        while !shortened && c != cb                             \u002F\u002F == until shorten || c == cb { .. }\n            c\\cbから適当にリテラルlを選ぶ\n            cbにlを追加する\n            !lを割当て伝播させる\n            if 矛盾しているなら\n                その学習節をclとする\n                if 学習節clが元々の節cを包摂するなら\n                    clをsigmaに追加; shortened = true;\n                else\n                    if cよりclの方が節長が短いなら\n                        clをsigmaに追加; cb = c;                \u002F\u002F これは終了条件, cは後でsigmaに追加される\n                    if c != cb   　　　                         \u002F\u002F ここがわからない\n                        cbをsigmaに追加; shortened = true;\n            else\n                if cの残りに含まれるリテラルlsの中で、env中に含まれるものがあるなら\n                    if cの残りがls以外のリテラルを含んでいたら\n                        cbにlsだけを追加した節を sigma に追加; shortened = true;\n                if cの残りに含まれるリテラルlsの中で、env中にその反リテラルが含まれるものがあるなら\n　　　　　　　     cからリテラルlsを除いてsigma に追加; shortened = true;\n            if shorted\n                sigma.remove(c);\n                change = true;\n```\n\n# Splr実装案\n\nこれを何も考えずにRustで書いてみるとこんな感じだろうか。\nSplr だと単位節は `cdb` に入れられないので CNF というよりも`(asg, cdb)` を持ち回るとした方が現実的かも。\n\n```rust\n\u002F\u002F\u002F Vivification of a given CNF formula, returning a vivified CNF formula\n\u002F\u002F\u002F Note: `remove` used here is a non-destructive function (`Fn\u003CT\u003E([T]) -\u003E Vec\u003CT\u003E`).\nfn vivify(mut sigma: (AssginStack, ClauseDB)) {\n    let mut env: (AssignStack, ClauseDB);\n    let mut change: bool = true;\n    let mut shortened: bool = true;\n    let mut cb: Vec\u003CLit\u003E = Vec::new();\n    let mut ci: usize;\n    while change {\n        change = false;\n        ci = 0;\n        while ci \u003C sigma.len() {\n            let mut c = &mut sigma[ci];\n            let c_len = c.len();\n            ci += 1;\n            env = sigma.clone();\n            env.remove_clause(ci);\n            cb.clear();\n            shortened = false;\n            while !shortened && c != cb {\n                let cx = c.remove_items(cb);\n                l = select_literal(cx);\n                cb.push(l);                                     \u002F\u002F cb = cb ∪ {l};\n                env.add_assignment(!l);                         \u002F\u002F Σb ← (Σb ∪ {¬l})\n                if let Some(ls) = env.propagate() {             \u002F\u002F ⊥ ∈ UP(Σb)\n                    let learnt = conflict_analyze();            \u002F\u002F returns a learnt clause\n                    if learnt.iter().all(|l| c.includes(l)) {   \u002F\u002F cl ⊂ c\n                        sigma.new_clause(learnt);               \u002F\u002F Σ ← Σ ∪ {cl}\n                        shortened = true;\n                    } else {\n                        if learnt.len() == c_len {\n                            sigma.new_clause(learnt);           \u002F\u002F Σ ← Σ ∪ {cl}\n                            cb = c;\n                        }\n                        if c != cb {\n                            sigma.new_clause(cb);               \u002F\u002F Σ ← Σ ∪ {cb}\n                            shortened = true;\n                        }\n                    }\n                } else {\n                    if let Some(ls) = cx.iter().find(|l| env.contains(l)) { \u002F\u002F ∃(ls ∈ (c\\cb))\n                        if 1 \u003C cx.len() {                       \u002F\u002F (c\\cb) \u002F= {ls}\n                            sigma.new_clause(cb.push(ls));      \u002F\u002F Σ ← Σ ∪ {cb ∪ {ls}} ;\n                            shortened = true;\n                        }\n                    }\n                    if let Some(ls) = cx.iter().find(|l| env.contains(!l)) { \u002F\u002F ∃(¬ls ∈ (c\\cb))\n                        sigma.new_clause(c.remove(ls));         \u002F\u002F Σ ← Σ ∪ {c\\{ls}}\n                        shortened = true;\n                    }\n                }\n                if shortened {\n                    sigma.kill(c);\n                    change = true;\n                }\n            }\n        }\n    }\n    \u002F\u002F return sigma;\n}\n```\n\n## 2020-06-23\n\n`AssignStack` や `ClauseDB` のコピーはコストが大きいので $\\Sigma$ だけで対応したい。\n\n* $\\Sigma$ と `env` の違いは$l$の割り当てをもつかどうか。これは割り当てをキャンセルできればいいはず。\n* 内側のwhile文中で $\\Sigma$ に対して節や割り当てを追加しているので、これを遅延させる。\n* `assign`, `conflict_analysis`, `cancel_until`を呼び出すので変数および節の活性度が影響を受ける。どうしたものか。\n\n```rust\nfn vivify(mut sigma: (AssginStack, ClauseDB)) {\n    let mut change: bool = true;\n    while change {\n        change = false;\n        let mut ci: usize = 0;\n        let mut clauses: Vec\u003CVec\u003CLit\u003E\u003E = Vec::new();\n        while ci \u003C sigma.len() {\n            let mut c = &mut sigma[ci];\n            let c_lits = c.lits.clone();\n            let c_len = c.len();\n            let dl = sigma.decision_level();\n            i += 1;\n            sigma.remove_clause(ci);\n            let mut cb: Vec\u003CLit\u003E = Vec::new();\n            let mut shortened = false;\n            while !shortened && c != cb {\n                let cx = c.remove_items(cb);\n                l = select_literal(cx);\n                cb.push(l);                                     \u002F\u002F cb = cb ∪ {l};\n                sigma.assign_by_decision(!l);                   \u002F\u002F Σb ← (Σb ∪ {¬l})\n                if let Some(ls) = sigma.propagate() {           \u002F\u002F ⊥ ∈ UP(Σb)\n                    let learnt = conflict_analyze();            \u002F\u002F returns a learnt clause\n                    if learnt.iter().all(|l| c.includes(l)) {   \u002F\u002F cl ⊂ c\n                        clauses.push(learnt);                   \u002F\u002F MODIFIED: Σ ← Σ ∪ {cl}\n                        shortened = true;\n                    } else {\n                        if learnt.len() == c_len {\n                            clauses.push(learnt);               \u002F\u002F MODIFIED: Σ ← Σ ∪ {cl}\n                            cb = c;\n                        }\n                        if c != cb {\n                            clauses.push(cb);                   \u002F\u002F MODIFIED: Σ ← Σ ∪ {cb}\n                            shortened = true;\n                        }\n                    }\n                } else {\n                    if let Some(ls) = cx.iter().find(|l| sigma.contains(l)) { \u002F\u002F ∃(ls ∈ (c\\cb))\n                        if 1 \u003C cx.len() {                       \u002F\u002F (c\\cb) \u002F= {ls}\n                            clauses.push(cb.push(ls));          \u002F\u002F MODIFIED: Σ ← Σ ∪ {cb ∪ {ls}} ;\n                            shortened = true;\n                        }\n                    }\n                    if let Some(ls) = cx.iter().find(|l| sigma.contains(!l)) { \u002F\u002F ∃(¬ls ∈ (c\\cb))\n                        clauses.push(c.remove(ls));             \u002F\u002F MODIFIED: Σ ← Σ ∪ {c\\{ls}}\n                        shortened = true;\n                    }\n                }\n                if !shortened {\n                    sigma.new_clause(c_lits);\n                } else {\n                    change = true;\n                }\n                sigma.cancel_until(dl);\n            }\n            for c in &clauses {\n                if c.len() == 1 {\n                    sigma.new_assignment(c[0]);\n                } else {\n                    sigma.new_clause(c);\n                }\n            }\n        }\n    }\n}\n```\n\nこれでどうだろうか。実装してみなくては。\n\nこうしてみると、統計的ソルバの手法みたい。\n\n\n## 2020-06-24\n\nめちゃくちゃ重い！ vivifyに10000秒くらい掛かりそうだ。\n節に含まれるリテラル全てに対して伝播検査をしているのだから当然ではある。\nとりあえず先頭のリテラルだけの伝播にしてみたのだが、それでも論外。\n`propagate`で矛盾が検出されたときの依存グラフをキャッシュに残すようにするとどうだろうか。。。\n\n* `conflict_analyze`のカスタムバージョンが必要 -- TODO\n* cidが GCで変わってしまう -- しかしこれは `shortened` の時にpurgeすればいい。\n* purgeされるリテラルが多すぎてヒット率が低いのではないか -- no idea\n* 矛盾が発生する場合は結果をキャッシュできるが、そうでない場合は有用ではないのでは -- うーむ\n\n```rust\ntype ConflictDep = HashMap\u003CLit, (bool, HashSet\u003CClauseId\u003E, Vec\u003CLit\u003E)\u003E\n\nimpl ConflictDep {\n    fn clear(&mut self, l: Lit) { ... }\n    fn put(&mut self, l: Lit, ...) { ... }\n    fn purge(&mut self, l: Lit) { ... }\n}\n```\n\n## 2020-06-26\n\nもう少し軽いキャッシュを実装してみた。\n無矛盾時の処理をサボっても論理的には間違いではないので、一度調べたリテラルの伝播結果をキャッシュすると(assign $\\to$ propagate $\\to$ cancel_until)の一連の処理が減らせる。\nとにかく網羅速度を上げなければ。\n\n## 2020-06-27\n\nvivificationは`propagate`や`cancel_until`など多くの機能を流用しているが、sandbox化しなくていいだろうか。\n\n* 各種計数カウンタは切り離すべき\n* 変数活性度は取り込むべき。理由はどうであれ伝播の結果わかった統計情報なのだから。\n* ただし変数活性度の計算にはいくつかのカウンタは正しく動いている（更新される）ことが必要なので、計数カウンタを止めたサンドボックスを作るよりもvivify後に増分をキャンセルすることが必要かも。\n\n## 2020-06-29\n\nアルゴリズムの理解進展。いろいろ突っ込みどころを見つけて、反映したバージョンがこちら。\n\n* 23行目と27行目が同時に成立することはない\n* 30行目はwhileの中に入れる必要はない\n* キャッシュは意味がない。多くの場合すぐに`break`しているから。\n\n```rust\nfn vivify(asg: &mut AssignStack, cdb: &mut ClauseDB) {\n    let mut changed: bool = true;\n    while changed {\n        changed = false;\n        for c in &clauses {\n            let clits = c.lits.clone();\n            let mut shortened = false;\n            let mut new_clause: Vec\u003CLit\u003E = Vec::new();\n            cdb.delete_clause(c);\n            for (i, l) in clits.iter().enumerate() {\n                asg.assign_by_decision(!*l);\n                if asg.propagate(cdb) == ⊥ {\n                    let learnt = conflict_analyze_and_learnt(asg, cdb);\n                    if learnt.iter().all(|l| clits.contains(l)) {\n                        new_clause = learnt.clone();\n                        shortened = true;\n                    } else {\n                        if learnt.len() \u003C clits.len() {\n                            asg.cancel_until(asg.root_level);\n                            break;\n                        }\n                        if i \u003C clits.len() - 1 {\n                            new_clause = clits[..=i].to_vec();\n                            shortened = true;\n                        }\n                    }\n                } else if let Some(ls) = clits[i + 1..].iter().find(|l| asg.assigned(**l) == Some(true)) {\n                    if i \u003C clits.len() - 1 {\n                        new_clause = clits[..=i].to_vec();\n                        new_clause.push(*ls);\n                        shortened = true;\n                    }\n                } else if let Some(ls) = clits[i + 1..].iter().find(|l| asg.assigned(!**l) == Some(true)) {\n                    new_clause = clits.iter().copied().filter(|l| l != ls).collect::\u003CVec\u003C_\u003E\u003E();\n                    shortened = true;\n                }\n                asg.cancel_until(asg.root_level);\n                if shortened {\n                    break;\n                }\n            }\n            if shortened {\n                if new_clause.len() == 1 {\n                    asg.assign_at_rootlevel(new_clause[0]);\n                } else {\n                    cdb.new_clause(asg, new_clause);\n                }\n                changed = true;\n            } else {\n                cdb.new_clause(asg, clits);\n            }\n        }\n    }\n}\n```\n\n## 2020-07-01\n\nやはり、vivification中の活性度修正はしない方がよさそうだ。確かに外乱ではある。\nそして、短くなった節にはrewardを受け継がせなければ。。。\n\n## 2020-07-04\n\n`cancel_until`を呼び出す場所を間違っていた。今のままだと、新しい節は空節から始まってだんだん長くなっていくのではなく、常に単位節ということになる。正しいように修正したら遅くなった。\nまあ確かにヒューリスティックスとして全てのリテラルを確かめるというのはあるかもしれないが、論文通りにすべきではなかろうか。。。\n\n## 2020-07-05\n\nベンチマークを実行してみると少しは効果がありました。\nしかし、そろそろ新しい論文の方を読んで検討すべき頃合いだろう（もっと早く読めって）。\n長さ的にもいい頃合いなので、[項を改めて](\u002F2020\u002F2020-07-05-vivification2\u002F)検討を続けることにします。"},bodyHtml:{writable:true,enumerable:true,value:"\u003Cp\u003EVivification がなんなのか、日本語で探しても出てこないので以下の論文をまとめてみた。\n（最新の話かと思っていたけど2008年とは。。。）\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EC. Piette, Y. Hamadi, and L. Saïs, &quot;Vivifying propositional clausal formulae,” \u003Cem\u003EFront. Artif. Intell\u003C\u002Fem\u003E. Appl., vol. 178, pp. 525–529, 2008.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003ESplr でいうところの \u003Ccode\u003Eprocessor\u003C\u002Fcode\u003E が節数に対する制約内での網羅的な変数除去と節包摂(clause subsumption)とを実行するのに対し、vivification は（その節に「対応」する割り当てを仮定して）propagateを行った結果を用いて節の包摂方針を決めるというもの。\n節長を減らす方向でのみ置換するので、（節数の増加と引き換えに）不要な複雑さの導入を抑えることができるらしい。\n効果は1割程度のようである。\u003C\u002Fp\u003E\n\u003Cp\u003Eちなみに 'vivify' は論文では'shorten existing clauses'の意味で使われているが、辞書で引くと：\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003Everb: enliven or animate: outings vivify learning for children.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003Eとのこと。ぼやけていた制約の強化ということで、日本語になっているビビッドからも想像できる感じなんだろう。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003Ecover image: https:\u002F\u002Fimages.unsplash.com\u002Fphoto-1506884403171-cdb32baec15f\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Ch1\u003Eアルゴリズム（上記論文より引用）\u003C\u002Fh1\u003E\n\u003Cp\u003E\u003Cimg src=\"\u002Fimg\u002F2020\u002F06-20\u002Falgorithm1.jpg\" alt=\"\"\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E6行目で $c$ を $\\Sigma$ から削除して、30行目で戻している。しかし $\\Sigma$ に対する伝播は行わないので、30行目まで残しておいても構わない。\u003C\u002Fli\u003E\n\u003Cli\u003E20行目の解釈： 節 $c$ が存在しない $\\Sigma_b$ において、リテラル $l$ に対して決定による割当てを行うと矛盾した（11行目）。しかし、学習節 $c_l$ は節 $c$ に含まれないなら（16行目）。これは矛盾は別の節集合によって生じたことを意味する。従ってこの節は冗長かもしれない。もし学習節 $c_l$ が節 $c$ より小さいなら（17行目）、これは節 $c$ より強い制約であるので $\\Sigma_b$ に追加する。そして節 $c$ 自身も $\\Sigma_b$ に戻した上で、節 $c$ に対する検査を終了させる（矛盾節を含む式と学習節を含む式とは充足可能性において等価である（矛盾の回避は割当て列に関する枝刈であって論理式の等価変換であることには違いない））。そうでないなら（19行目）、つまり節 $c$ （に含まれるリテラル集合）は今回の矛盾とは関係ないが今回の矛盾によって吸収できるとは言い切れない場合には、節 $c$ に含まれていたリテラル集合 $c_b$ を $\\Sigma_b$ に追加し（代わりに $c$ を削除し）て節 $c$ に対する処理を終了する（より強い制約に置き換えている？？）。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cblockquote\u003E\n\u003Col\u003E\n\u003Cli\u003E$\\exists i \\in {1, \\cdots, n-1}; s.t.; \\Sigma\\backslash{c} \\cup {\\neg l_1, \\cdots, \\neg l_i} \\models_{UP} \\bot$&lt;br&gt; In this case, we have $\\Sigma\\backslash{c} \\models_{UP} c'$ with $c' = (l_1 \\vee \\cdots \\vee l_i)$. This new clause $c'$ strictly subsumes $c$. Hence, the original clause can be substituted by the new deduced one. Obviously, $c'$ is not necessarily minimally redundant modulo UP. Indeed, another ordering on the literals ${l_1, l_2, \\cdots, l_i}$ might lead to an even shorter sub-clause. Thanks to a conflict analysis, the deduced sub-clause $c'$ could be shortened again leading to an even smaller sub-clause. Indeed, a new clause η can be generated by a complete traversal of the implication graph associated to $\\Sigma$ and to the assignments of the literals ${\\neg l_1, \\cdots, \\neg l_i}$. The complete traversal of the implication graph ensure that the clause η contains only literals from $c'$. Thereby, η is a sub-clause of $(l_1 \\vee \\cdots \\vee l_i)$.\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cul\u003E\n\u003Cli\u003E23, 27行目の型が合わないんだけどなあ。念のためもう一本読んでおいた方がよさそうだ。\u003C\u002Fli\u003E\n\u003Cli\u003E$A \\leftarrow A \\cup B$ は \u003Ccode\u003EA.push(B);\u003C\u002Fcode\u003E ではなく \u003Ccode\u003Eif !A.contains(&amp;B) { A.push(B); }\u003C\u002Fcode\u003E であることに注意。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003Eもう少し説明を加えるとこういう感じ。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E 不動点になるまで\n    \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E sigma中の全ての節cに対して\n        現在のsigmaのコピーをenvとする\n        cb.clear();\n        shortened = \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E;\n        \u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E !shortened &amp;&amp; c != cb                             \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F == until shorten || c == cb { .. }\u003C\u002Fspan\u003E\n            c\\cbから適当にリテラルlを選ぶ\n            cbにlを追加する\n            !lを割当て伝播させる\n            \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E 矛盾しているなら\n                その学習節をclとする\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E 学習節clが元々の節cを包摂するなら\n                    clをsigmaに追加; shortened = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n                \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E\n                    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E cよりclの方が節長が短いなら\n                        clをsigmaに追加; cb = c;                \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F これは終了条件, cは後でsigmaに追加される\u003C\u002Fspan\u003E\n                    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E c != cb   　　　                         \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F ここがわからない\u003C\u002Fspan\u003E\n                        cbをsigmaに追加; shortened = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n            \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E cの残りに含まれるリテラルlsの中で、env中に含まれるものがあるなら\n                    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E cの残りがls以外のリテラルを含んでいたら\n                        cbにlsだけを追加した節を sigma に追加; shortened = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E cの残りに含まれるリテラルlsの中で、env中にその反リテラルが含まれるものがあるなら\n　　　　　　　     cからリテラルlsを除いてsigma に追加; shortened = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n            \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E shorted\n                sigma.remove(c);\n                change = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch1\u003ESplr実装案\u003C\u002Fh1\u003E\n\u003Cp\u003Eこれを何も考えずにRustで書いてみるとこんな感じだろうか。\nSplr だと単位節は \u003Ccode\u003Ecdb\u003C\u002Fcode\u003E に入れられないので CNF というよりも\u003Ccode\u003E(asg, cdb)\u003C\u002Fcode\u003E を持ち回るとした方が現実的かも。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F\u002F Vivification of a given CNF formula, returning a vivified CNF formula\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F\u002F Note: `remove` used here is a non-destructive function (`Fn&lt;T&gt;([T]) -&gt; Vec&lt;T&gt;`).\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Evivify\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E sigma: (AssginStack, ClauseDB)) {\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E env: (AssignStack, ClauseDB);\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E change: \u003Cspan class=\"hljs-built_in\"\u003Ebool\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E shortened: \u003Cspan class=\"hljs-built_in\"\u003Ebool\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E cb: \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;Lit&gt; = \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E::new();\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E ci: \u003Cspan class=\"hljs-built_in\"\u003Eusize\u003C\u002Fspan\u003E;\n    \u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E change {\n        change = \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E;\n        ci = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E;\n        \u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E ci &lt; sigma.len() {\n            \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E c = &amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E sigma[ci];\n            \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E c_len = c.len();\n            ci += \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E;\n            env = sigma.clone();\n            env.remove_clause(ci);\n            cb.clear();\n            shortened = \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E;\n            \u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E !shortened &amp;&amp; c != cb {\n                \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E cx = c.remove_items(cb);\n                l = select_literal(cx);\n                cb.push(l);                                     \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F cb = cb ∪ {l};\u003C\u002Fspan\u003E\n                env.add_assignment(!l);                         \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Σb ← (Σb ∪ {¬l})\u003C\u002Fspan\u003E\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003ESome\u003C\u002Fspan\u003E(ls) = env.propagate() {             \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F ⊥ ∈ UP(Σb)\u003C\u002Fspan\u003E\n                    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E learnt = conflict_analyze();            \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F returns a learnt clause\u003C\u002Fspan\u003E\n                    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E learnt.iter().all(|l| c.includes(l)) {   \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F cl ⊂ c\u003C\u002Fspan\u003E\n                        sigma.new_clause(learnt);               \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Σ ← Σ ∪ {cl}\u003C\u002Fspan\u003E\n                        shortened = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n                    } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n                        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E learnt.len() == c_len {\n                            sigma.new_clause(learnt);           \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Σ ← Σ ∪ {cl}\u003C\u002Fspan\u003E\n                            cb = c;\n                        }\n                        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E c != cb {\n                            sigma.new_clause(cb);               \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Σ ← Σ ∪ {cb}\u003C\u002Fspan\u003E\n                            shortened = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n                        }\n                    }\n                } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n                    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003ESome\u003C\u002Fspan\u003E(ls) = cx.iter().find(|l| env.contains(l)) { \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F ∃(ls ∈ (c\\cb))\u003C\u002Fspan\u003E\n                        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E &lt; cx.len() {                       \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F (c\\cb) \u002F= {ls}\u003C\u002Fspan\u003E\n                            sigma.new_clause(cb.push(ls));      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Σ ← Σ ∪ {cb ∪ {ls}} ;\u003C\u002Fspan\u003E\n                            shortened = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n                        }\n                    }\n                    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003ESome\u003C\u002Fspan\u003E(ls) = cx.iter().find(|l| env.contains(!l)) { \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F ∃(¬ls ∈ (c\\cb))\u003C\u002Fspan\u003E\n                        sigma.new_clause(c.remove(ls));         \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Σ ← Σ ∪ {c\\{ls}}\u003C\u002Fspan\u003E\n                        shortened = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n                    }\n                }\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E shortened {\n                    sigma.kill(c);\n                    change = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n                }\n            }\n        }\n    }\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F return sigma;\u003C\u002Fspan\u003E\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch2\u003E2020-06-23\u003C\u002Fh2\u003E\n\u003Cp\u003E\u003Ccode\u003EAssignStack\u003C\u002Fcode\u003E や \u003Ccode\u003EClauseDB\u003C\u002Fcode\u003E のコピーはコストが大きいので $\\Sigma$ だけで対応したい。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E$\\Sigma$ と \u003Ccode\u003Eenv\u003C\u002Fcode\u003E の違いは$l$の割り当てをもつかどうか。これは割り当てをキャンセルできればいいはず。\u003C\u002Fli\u003E\n\u003Cli\u003E内側のwhile文中で $\\Sigma$ に対して節や割り当てを追加しているので、これを遅延させる。\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eassign\u003C\u002Fcode\u003E, \u003Ccode\u003Econflict_analysis\u003C\u002Fcode\u003E, \u003Ccode\u003Ecancel_until\u003C\u002Fcode\u003Eを呼び出すので変数および節の活性度が影響を受ける。どうしたものか。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Evivify\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E sigma: (AssginStack, ClauseDB)) {\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E change: \u003Cspan class=\"hljs-built_in\"\u003Ebool\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n    \u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E change {\n        change = \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E;\n        \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E ci: \u003Cspan class=\"hljs-built_in\"\u003Eusize\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E;\n        \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E clauses: \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;\u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;Lit&gt;&gt; = \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E::new();\n        \u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E ci &lt; sigma.len() {\n            \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E c = &amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E sigma[ci];\n            \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E c_lits = c.lits.clone();\n            \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E c_len = c.len();\n            \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E dl = sigma.decision_level();\n            i += \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E;\n            sigma.remove_clause(ci);\n            \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E cb: \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;Lit&gt; = \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E::new();\n            \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E shortened = \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E;\n            \u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E !shortened &amp;&amp; c != cb {\n                \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E cx = c.remove_items(cb);\n                l = select_literal(cx);\n                cb.push(l);                                     \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F cb = cb ∪ {l};\u003C\u002Fspan\u003E\n                sigma.assign_by_decision(!l);                   \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Σb ← (Σb ∪ {¬l})\u003C\u002Fspan\u003E\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003ESome\u003C\u002Fspan\u003E(ls) = sigma.propagate() {           \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F ⊥ ∈ UP(Σb)\u003C\u002Fspan\u003E\n                    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E learnt = conflict_analyze();            \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F returns a learnt clause\u003C\u002Fspan\u003E\n                    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E learnt.iter().all(|l| c.includes(l)) {   \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F cl ⊂ c\u003C\u002Fspan\u003E\n                        clauses.push(learnt);                   \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F MODIFIED: Σ ← Σ ∪ {cl}\u003C\u002Fspan\u003E\n                        shortened = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n                    } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n                        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E learnt.len() == c_len {\n                            clauses.push(learnt);               \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F MODIFIED: Σ ← Σ ∪ {cl}\u003C\u002Fspan\u003E\n                            cb = c;\n                        }\n                        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E c != cb {\n                            clauses.push(cb);                   \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F MODIFIED: Σ ← Σ ∪ {cb}\u003C\u002Fspan\u003E\n                            shortened = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n                        }\n                    }\n                } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n                    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003ESome\u003C\u002Fspan\u003E(ls) = cx.iter().find(|l| sigma.contains(l)) { \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F ∃(ls ∈ (c\\cb))\u003C\u002Fspan\u003E\n                        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E &lt; cx.len() {                       \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F (c\\cb) \u002F= {ls}\u003C\u002Fspan\u003E\n                            clauses.push(cb.push(ls));          \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F MODIFIED: Σ ← Σ ∪ {cb ∪ {ls}} ;\u003C\u002Fspan\u003E\n                            shortened = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n                        }\n                    }\n                    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003ESome\u003C\u002Fspan\u003E(ls) = cx.iter().find(|l| sigma.contains(!l)) { \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F ∃(¬ls ∈ (c\\cb))\u003C\u002Fspan\u003E\n                        clauses.push(c.remove(ls));             \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F MODIFIED: Σ ← Σ ∪ {c\\{ls}}\u003C\u002Fspan\u003E\n                        shortened = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n                    }\n                }\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E !shortened {\n                    sigma.new_clause(c_lits);\n                } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n                    change = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n                }\n                sigma.cancel_until(dl);\n            }\n            \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E c \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E &amp;clauses {\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E c.len() == \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E {\n                    sigma.new_assignment(c[\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E]);\n                } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n                    sigma.new_clause(c);\n                }\n            }\n        }\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eこれでどうだろうか。実装してみなくては。\u003C\u002Fp\u003E\n\u003Cp\u003Eこうしてみると、統計的ソルバの手法みたい。\u003C\u002Fp\u003E\n\u003Ch2\u003E2020-06-24\u003C\u002Fh2\u003E\n\u003Cp\u003Eめちゃくちゃ重い！ vivifyに10000秒くらい掛かりそうだ。\n節に含まれるリテラル全てに対して伝播検査をしているのだから当然ではある。\nとりあえず先頭のリテラルだけの伝播にしてみたのだが、それでも論外。\n\u003Ccode\u003Epropagate\u003C\u002Fcode\u003Eで矛盾が検出されたときの依存グラフをキャッシュに残すようにするとどうだろうか。。。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003Econflict_analyze\u003C\u002Fcode\u003Eのカスタムバージョンが必要 -- TODO\u003C\u002Fli\u003E\n\u003Cli\u003Ecidが GCで変わってしまう -- しかしこれは \u003Ccode\u003Eshortened\u003C\u002Fcode\u003E の時にpurgeすればいい。\u003C\u002Fli\u003E\n\u003Cli\u003Epurgeされるリテラルが多すぎてヒット率が低いのではないか -- no idea\u003C\u002Fli\u003E\n\u003Cli\u003E矛盾が発生する場合は結果をキャッシュできるが、そうでない場合は有用ではないのでは -- うーむ\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Etype\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EConflictDep\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E = HashMap&lt;Lit, (\u003Cspan class=\"hljs-built_in\"\u003Ebool\u003C\u002Fspan\u003E, HashSet&lt;ClauseId&gt;, \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;Lit&gt;)&gt;\n\n\u003Cspan class=\"hljs-keyword\"\u003Eimpl\u003C\u002Fspan\u003E ConflictDep {\n    \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eclear\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E, l: Lit) { ... }\n    \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eput\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E, l: Lit, ...) { ... }\n    \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Epurge\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E, l: Lit) { ... }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch2\u003E2020-06-26\u003C\u002Fh2\u003E\n\u003Cp\u003Eもう少し軽いキャッシュを実装してみた。\n無矛盾時の処理をサボっても論理的には間違いではないので、一度調べたリテラルの伝播結果をキャッシュすると(assign $\\to$ propagate $\\to$ cancel_until)の一連の処理が減らせる。\nとにかく網羅速度を上げなければ。\u003C\u002Fp\u003E\n\u003Ch2\u003E2020-06-27\u003C\u002Fh2\u003E\n\u003Cp\u003Evivificationは\u003Ccode\u003Epropagate\u003C\u002Fcode\u003Eや\u003Ccode\u003Ecancel_until\u003C\u002Fcode\u003Eなど多くの機能を流用しているが、sandbox化しなくていいだろうか。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E各種計数カウンタは切り離すべき\u003C\u002Fli\u003E\n\u003Cli\u003E変数活性度は取り込むべき。理由はどうであれ伝播の結果わかった統計情報なのだから。\u003C\u002Fli\u003E\n\u003Cli\u003Eただし変数活性度の計算にはいくつかのカウンタは正しく動いている（更新される）ことが必要なので、計数カウンタを止めたサンドボックスを作るよりもvivify後に増分をキャンセルすることが必要かも。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch2\u003E2020-06-29\u003C\u002Fh2\u003E\n\u003Cp\u003Eアルゴリズムの理解進展。いろいろ突っ込みどころを見つけて、反映したバージョンがこちら。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E23行目と27行目が同時に成立することはない\u003C\u002Fli\u003E\n\u003Cli\u003E30行目はwhileの中に入れる必要はない\u003C\u002Fli\u003E\n\u003Cli\u003Eキャッシュは意味がない。多くの場合すぐに\u003Ccode\u003Ebreak\u003C\u002Fcode\u003Eしているから。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Evivify\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(asg: &amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E AssignStack, cdb: &amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E ClauseDB) {\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E changed: \u003Cspan class=\"hljs-built_in\"\u003Ebool\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n    \u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E changed {\n        changed = \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E;\n        \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E c \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E &amp;clauses {\n            \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E clits = c.lits.clone();\n            \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E shortened = \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E;\n            \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E new_clause: \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;Lit&gt; = \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E::new();\n            cdb.delete_clause(c);\n            \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E (i, l) \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E clits.iter().enumerate() {\n                asg.assign_by_decision(!*l);\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E asg.propagate(cdb) == ⊥ {\n                    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E learnt = conflict_analyze_and_learnt(asg, cdb);\n                    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E learnt.iter().all(|l| clits.contains(l)) {\n                        new_clause = learnt.clone();\n                        shortened = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n                    } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n                        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E learnt.len() &lt; clits.len() {\n                            asg.cancel_until(asg.root_level);\n                            \u003Cspan class=\"hljs-keyword\"\u003Ebreak\u003C\u002Fspan\u003E;\n                        }\n                        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E i &lt; clits.len() - \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E {\n                            new_clause = clits[..=i].to_vec();\n                            shortened = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n                        }\n                    }\n                } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003ESome\u003C\u002Fspan\u003E(ls) = clits[i + \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E..].iter().find(|l| asg.assigned(**l) == \u003Cspan class=\"hljs-literal\"\u003ESome\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E)) {\n                    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E i &lt; clits.len() - \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E {\n                        new_clause = clits[..=i].to_vec();\n                        new_clause.push(*ls);\n                        shortened = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n                    }\n                } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003ESome\u003C\u002Fspan\u003E(ls) = clits[i + \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E..].iter().find(|l| asg.assigned(!**l) == \u003Cspan class=\"hljs-literal\"\u003ESome\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E)) {\n                    new_clause = clits.iter().copied().filter(|l| l != ls).collect::&lt;\u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;_&gt;&gt;();\n                    shortened = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n                }\n                asg.cancel_until(asg.root_level);\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E shortened {\n                    \u003Cspan class=\"hljs-keyword\"\u003Ebreak\u003C\u002Fspan\u003E;\n                }\n            }\n            \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E shortened {\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E new_clause.len() == \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E {\n                    asg.assign_at_rootlevel(new_clause[\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E]);\n                } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n                    cdb.new_clause(asg, new_clause);\n                }\n                changed = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E;\n            } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n                cdb.new_clause(asg, clits);\n            }\n        }\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch2\u003E2020-07-01\u003C\u002Fh2\u003E\n\u003Cp\u003Eやはり、vivification中の活性度修正はしない方がよさそうだ。確かに外乱ではある。\nそして、短くなった節にはrewardを受け継がせなければ。。。\u003C\u002Fp\u003E\n\u003Ch2\u003E2020-07-04\u003C\u002Fh2\u003E\n\u003Cp\u003E\u003Ccode\u003Ecancel_until\u003C\u002Fcode\u003Eを呼び出す場所を間違っていた。今のままだと、新しい節は空節から始まってだんだん長くなっていくのではなく、常に単位節ということになる。正しいように修正したら遅くなった。\nまあ確かにヒューリスティックスとして全てのリテラルを確かめるというのはあるかもしれないが、論文通りにすべきではなかろうか。。。\u003C\u002Fp\u003E\n\u003Ch2\u003E2020-07-05\u003C\u002Fh2\u003E\n\u003Cp\u003Eベンチマークを実行してみると少しは効果がありました。\nしかし、そろそろ新しい論文の方を読んで検討すべき頃合いだろう（もっと早く読めって）。\n長さ的にもいい頃合いなので、\u003Ca href=\"\u002F2020\u002F2020-07-05-vivification2\u002F\"\u003E項を改めて\u003C\u002Fa\u003E検討を続けることにします。\u003C\u002Fp\u003E\n"},dir:{writable:true,enumerable:true,value:"article\u002F.json\u002F2020"},base:{writable:true,enumerable:true,value:"2020-06-20-vivification.json"},ext:{writable:true,enumerable:true,value:".json"},sourceBase:{writable:true,enumerable:true,value:"2020-06-20-vivification.md"},sourceExt:{writable:true,enumerable:true,value:".md"}})}],fetch:[],mutations:[]});