__NUXT_JSONP__("/2020/2020-08-15-Cow", {data:[{article:Object.create(null,{default:{writable:true,enumerable:true,value:{title:"RustのClone on Writeについて",subtitle:"std::borrow::cow",date:"2020-08-15T00:00:00.000Z",tags:["Rust"],banner:"\u002Fimg\u002F2020\u002F08-15\u002Fbanner.jpg",bodyContent:"自転車本では紹介されてないけれど、Rustならでは必要とされる面白い型、Copy on Writeではなくて、Clone on Writeを意味する[`std::borrow::Cow`](https:\u002F\u002Fdoc.rust-lang.org\u002Fstd\u002Fborrow\u002Fenum.Cow.html) の紹介です。\n\n## 前提知識：`str` と `String`の違い\n\n* `str` -- （固定長の）UTF-8文字のスライス\n* `&str` -- UTF-8文字のスライスへのポインタ\n* `String` -- ヒープ上に置かれた、追加を含めた変更ができる文字列\n\n\n## 前提知識：文字列定数とその参照\n\n#### ローカル変数\n\nまず、以下のように関数内のローカルデータとして確保された文字列定数を参照する変数の型を確認しておきます。\n\n```rust\n\u002F\u002F\u002F コンパイルできる\nfn f() {\n  let s = \"a fixed string\";\n  ...\n```\n\nこれは `&str` です。\n\n```rust\n\u002F\u002F\u002F コンパイルできる\nfn f() {\n  let s: &str = \"a fixed string\";\n  ...\n```\n\n* `\"a fixed string\"`はローカルなデータなので（Boxも使ってないし）ヒープに置く必要はありません。\n* 変数`s`はその確保された領域を指すように型付けられます。\n* `str`は通常Rustのプログラムには出てきません。\n\nちなみに`s`がグローバル変数`S`になるとどうなるでしょう。\n\n```rust\n\u002F\u002F\u002F 設計中\nconst S: ??? = \"a fixed string\";\n```\n\nグローバル変数も他の言語同様にヒープではなくOSで言うところのデータ領域に置かれるのでやはり`str`であり、\nその領域を指すので変数`S` は`&str`型になります。\n\n```rust\n\u002F\u002F\u002F コンパイルできる\nconst S: &str = \"a fixed string\";\n```\n\n## 前提知識：`str`と`String`間の変換\n\n### `&str`から`String`へ\n\n`&str`型の変数があればその指している対象から`to_string`メソッドを使って`String`を作ることができます。\n\n```rust\n\u002F\u002F\u002F コンパイルできる\nfn f() {\n  let s: &str = \"A fixed string\" \n  let t = s.to_string();     \u002F\u002F ヒープ操作を必要とする\n  ...\n```\n\nこの時`t`の実体はヒープ上に置かれたfat pointerです。固定長なのでメモリを大きく消費するわけではありませんが、実体へのポインタを含む構造体をヒープ上に構成する必要があります。\n\n### `String`から`&str`へ\n\n逆の操作は`as_str()`です。この操作は`String`を構成するfat pointerを流用すればいいので極めて軽量です。\nこれは`&srt`から`String`への変換が`to_*`系なのに対し、`String`から`&str`への変換が`as_*`系の[命名](https:\u002F\u002Frust-lang.github.io\u002Fapi-guidelines\u002Fnaming.html#ad-hoc-conversions-follow-as_-to_-into_-conventions-c-conv)になっていることからもわかります。\n\n```rust\n\u002F\u002F\u002F コンパイルできる\nfn f() {\n  let s: String = \"A fixed string\".to_string();\n  let t: &str = s.as_str();    \u002F\u002F 軽量な操作\n  ...\n```\n\nここまでが前提知識でした。\n\n# 問題となるシナリオ: `&str` と `String` の混在\n\nさて、以下のような構造体`S`に対してその文字列表現を返す`rep()`メソッドを定義するとします。\n\n```rust\nstruct S {\n  index: usize,\n  vec: Vec\u003Cusize\u003E,\n}\n```\n\nただし、\n\n* その構造体が持っているフィールド`index`が0の時は固定のメッセージを返す。\n* そうでなければ内部データの値がわかる文字列にしたい。\n\nとします。\n\n```rust\n\u002F\u002F\u002F 設計中\nimpl S {\n  fn rep(&self) -\u003E ??? {\n     if self.index == 0 {\n         ...\n     } else {\n         ...\n     }\n  }\n}\n```\n\n### Case 1: index == 0 のオブジェクトの場合\n\nこの場合、`rep()`内部で固定のメッセージを保持するローカル変数`mes`の値をそのまま返すことにします。\n`mes`の型は `&str` であることから`rep()`の返値型も`&str`になります。\n\n```rust\n\u002F\u002F\u002F コンパイルできるはず\nimpl S {\n  fn rep(&self) -\u003E &str {\n     if self.index == 0 {\n         let mes: &str = \"null object\";\n         mes\n     } else {\n         ...\n     }\n  }\n}\n```\n\n### Case 2: それ以外\n\nフィールド`vec`の値を埋め込んだ文字列を作るため`format!`を使うことにしました。\n\n`format!`の返す型は`String`なので`rep()`の返値型も`String`になります。\n```rust\n\u002F\u002F\u002F コンパイルできない\nimpl S {\n  fn rep(&self) -\u003E String {\n\n\n         ...\n     } else {\n         format!(\"S{{{:?}}}\", self.vec)\n     }\n  }\n}\n```\n\nここで型が一致しない問題に直面します。\n\n### 案1: `&str`への統一\n\n既に見たようにどちらの方向にも変換できるのでまず`&str`へ統一することを考えてみます。\n\n```rust\n  fn rep(&self) -\u003E &str {\n     if self.index == 0 {\n         let mes: &str = \"null object\";\n         mes\n     } else {\n         format!(\"S{{{:?}}}\", self.vec).as_str()\n     }\n  }\n}\n```\n\nこれはライフタイム制約を満足しないエラーになります。\n\n```text\nerror[E0515]: cannot return value referencing temporary value\n   |\n   |          format!(\"S{{{:?}}}\", self.vec).as_str()                                                        \n   |          ------------------------------^^^^^^^^^\n   |          |\n   |          returns a value referencing data owned by the current function\n   |          temporary value created here\n```\n\n以下のようにローカル変数`res`にバインドしても、\n\n```rust\n  fn rep(&self) -\u003E &str {\n     if self.index == 0 {\n         let mes: &str = \"null object\";\n         mes\n     } else {\n         let res = format!(\"S{{{:?}}}\", self.vec);\n         res.as_str()\n     }\n  }\n}\n```\n\nライフタイムが短すぎることには変わりはないので、エラーになります（`res`はヒープに置かれても所有者である`rep`からexitする時点で回収されてしまう）\n\n```text\nerror[E0515]: cannot return value referencing local variable `res`\n   |\n   |          res.as_str()                                                        \n   |          ---^^^^^^^^^\n   |          |\n   |          returns a value referencing data owned by the current function\n   |          `res` is borrowed here\n```\n\nなので、`format!`で作った`String`実体を呼び出し側に渡さないといけません。\n\n### 案2: `String`への統一\n\nということで`&str`型の`mes`を返しているパスの型を変えることにします。関数の返値型を変えてコンパイルすると以下のようなエラーメッセージが表示されます。\n\n```text\nerror[E0308]: mismatched types\n  --\u003E src\u002Fmain.rs:13:10\n   |\n   |   fn rep(&self) -\u003E String {                                                                               \n   |                    ------ expected `std::string::String` because of return type\n...\n   |          mes                                                                                           \n   |          ^^^^\n   |          |\n   |          expected struct `std::string::String`, found `&str`\n   |          help: try using a conversion method: `mes.to_string()`\n\n```\n\nヘルプに従って修正すれば問題はなくなります。\n\n```rust\n  \u002F\u002F\u002F コンパイルできる\n  fn rep(&self) -\u003E String {\n     if self.index == 0 {\n         let mes: &str = \"null object\";\n         mes.to_string()\n     } else {\n         let res = format!(\"S{{{:?}}}\", self.vec);\n         res.as_str()\n     }\n  }\n}\n```\n\nしかしこれは、必要とは思われないヒープでのオブジェクト生成をしているため、時間的にも空間的にも（できれば避けたい）コストをかけてしまっています。ゼロコストアブストラクションをうたうRustのプログラムとしては是非とも避けたいところです。\n\n### 案3: 型の包含\n\nこの問題を解決するには「借用」と「実体」のどちらも返せるような`enum`を用意するという手が使えます。\n\n* 借用でいいならなら借用を包む\n* 実体が必要なら、実体を包む\n\n```rust\n\u002F\u002F\u002F 設計中（ライフタイム指定がまだついていない）\nenum WrapStr {\n  from_str(&str),\n  from_format(String),\n}\n\nimpl S {\n  fn rep(&self) -\u003E WrapStr {\n     if self.index == 0 {\n         let mes: &str = \"null object\";\n         WrapStr::from_str(mes)\n     } else {\n         WraStr::from_format(format!(\"S{{{:?}}}\", self.vec))\n     }\n  }\n}\n```\n\nこうすれば型の問題は解決するし、見かけ上構造体で包むコストは（おそらく）コンパイラの最適化中に何もしないコードに変換されることが期待できます。ということで`WrapStr`を追加定義すれば問題解決します。ポインタを含むのでライフタイム制約が必要かな。。。\n\n# Cow\n\nしかし自分で定義するよりも、このような状況のための型がすでに標準ライブラリに用意されているのでそれを使いましょう。\nそれがClone on Write, `Cow`型です。これは以下のように定義されています。\nhttps:\u002F\u002Fdoc.rust-lang.org\u002Fstd\u002Fborrow\u002Fenum.Cow.html\n\n```rust\n\u002F\u002F\u002F https:\u002F\u002Fdoc.rust-lang.org\u002Fstd\u002Fborrow\u002Fenum.Cow.html\npub enum Cow\u003C'a, B\u003E \nwhere\n    B: 'a + ToOwned + ?Sized, \n {\n    Borrowed(&'a B),\n    Owned(\u003CB as ToOwned\u003E::Owned),\n}\n```\n\n`ToOwned`は借用したデータから、所有権を持つ実体を構成することができるというトレイトです。\n文字列関連では以下のようになっています。\nhttps:\u002F\u002Fdoc.rust-lang.org\u002Fstd\u002Fborrow\u002Ftrait.ToOwned.html\n\n```\n\u002F\u002F\u002F https:\u002F\u002Fdoc.rust-lang.org\u002Fstd\u002Fborrow\u002Ftrait.ToOwned.html\nimpl ToOwned for str\n  type Owned = String\n  \n  \u002F\u002F\u002F Examples\n  let s: &str = \"a\";\n  let ss: String = s.to_owned();\n```\n\nつまり`str`から`String`が作れると。これを見ながら`Cow`の定義の`B`を`str`に変換してやると以下のようになります。\n\n```\npub enum Cow\u003C'a, str\u003E \nwhere\n    str: 'a + ToOwned + ?Sized,  \u002F\u002F 条件OK\n {\n    Borrowed(&'a str),\n    Owned(String),\n}\n```\n\nということで、借用(`&str`)は`Cow::Borrowed`で実体(`String`)は`Cow::Owned`で包んでやればいいことがわかりました。\n\n最終的なプログラムはこうなります。\n\n```rust\nuse std::borrow::Cow;\n\nimpl S {\n  \u002F\u002F\u002F コンパイルできる\n  fn rep(&self) -\u003E Cow\u003C'_, str\u003E {\n    if self.index == 0 {\n      Cow::Borrowed(\"Null S\")                  \u002F\u002F 場所は確保済み =\u003E 借用したい\n    } else {\n      Cow::Owned(format!(\"S[{:?}]\", self.vec)) \u002F\u002F 借用ではダメ =\u003E実体を渡したい\n    }\n  }\n}\n```\n\n使う側では一回derefしてやれば借用であったか実体であったかを気にする必要はありません。\n\n```rust\n   println!(\"{}\", *s.rep());\n```\n\nちなみにderefしたものが何型になっているかというと、\n\n```rust\n  \u002F\u002F コンパイルできる\n  let temp: &str = &*s.rep();\n```\n\nだそうです。文字列のスライスみたいですね。\n\n\n### コストについて\n\nderefのコストは以下に引用したようにポインタ辿りだけなので、「軽量」と言ってしまっていいでしょう。\n\nhttps:\u002F\u002Fdoc.rust-lang.org\u002Fsrc\u002Falloc\u002Fborrow.rs.html#320\n```\n\u002F\u002F\u002F https:\u002F\u002Fdoc.rust-lang.org\u002Fsrc\u002Falloc\u002Fborrow.rs.html#320\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl\u003CB: ?Sized + ToOwned\u003E Deref for Cow\u003C'_, B\u003E {\n    type Target = B;\n\n    fn deref(&self) -\u003E &B {\n        match *self {\n            Borrowed(borrowed) =\u003E borrowed,\n            Owned(ref owned) =\u003E owned.borrow(),\n        }\n    }\n}\n```\n\nhttps:\u002F\u002Fdoc.rust-lang.org\u002Fsrc\u002Fcore\u002Fborrow.rs.html#212\n```rust\n\u002F\u002F\u002F https:\u002F\u002Fdoc.rust-lang.org\u002Fsrc\u002Fcore\u002Fborrow.rs.html#212\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl\u003CT: ?Sized\u003E Borrow\u003CT\u003E for T {\n    fn borrow(&self) -\u003E &T {\n        self\n    }\n}\n```\n\nhttps:\u002F\u002Fdoc.rust-lang.org\u002Fsrc\u002Fcore\u002Fborrow.rs.html#226\n```rust\n\u002F\u002F\u002F https:\u002F\u002Fdoc.rust-lang.org\u002Fsrc\u002Fcore\u002Fborrow.rs.html#226\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl\u003CT: ?Sized\u003E Borrow\u003CT\u003E for &T {\n    fn borrow(&self) -\u003E &T {\n        &**self\n    }\n}\n```",bodyHtml:"\u003Cp\u003E自転車本では紹介されてないけれど、Rustならでは必要とされる面白い型、Copy on Writeではなくて、Clone on Writeを意味する\u003Ca href=\"https:\u002F\u002Fdoc.rust-lang.org\u002Fstd\u002Fborrow\u002Fenum.Cow.html\"\u003E\u003Ccode\u003Estd::borrow::Cow\u003C\u002Fcode\u003E\u003C\u002Fa\u003E の紹介です。\u003C\u002Fp\u003E\n\u003Ch2\u003E前提知識：\u003Ccode\u003Estr\u003C\u002Fcode\u003E と \u003Ccode\u003EString\u003C\u002Fcode\u003Eの違い\u003C\u002Fh2\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003Estr\u003C\u002Fcode\u003E -- （固定長の）UTF-8文字のスライス\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003E&amp;str\u003C\u002Fcode\u003E -- UTF-8文字のスライスへのポインタ\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003EString\u003C\u002Fcode\u003E -- ヒープ上に置かれた、追加を含めた変更ができる文字列\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch2\u003E前提知識：文字列定数とその参照\u003C\u002Fh2\u003E\n\u003Ch4\u003Eローカル変数\u003C\u002Fh4\u003E\n\u003Cp\u003Eまず、以下のように関数内のローカルデータとして確保された文字列定数を参照する変数の型を確認しておきます。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F\u002F コンパイルできる\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Ef\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E() {\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E s = \u003Cspan class=\"hljs-string\"\u003E&quot;a fixed string&quot;\u003C\u002Fspan\u003E;\n  ...\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eこれは \u003Ccode\u003E&amp;str\u003C\u002Fcode\u003E です。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F\u002F コンパイルできる\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Ef\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E() {\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E s: &amp;\u003Cspan class=\"hljs-built_in\"\u003Estr\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-string\"\u003E&quot;a fixed string&quot;\u003C\u002Fspan\u003E;\n  ...\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003E&quot;a fixed string&quot;\u003C\u002Fcode\u003Eはローカルなデータなので（Boxも使ってないし）ヒープに置く必要はありません。\u003C\u002Fli\u003E\n\u003Cli\u003E変数\u003Ccode\u003Es\u003C\u002Fcode\u003Eはその確保された領域を指すように型付けられます。\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Estr\u003C\u002Fcode\u003Eは通常Rustのプログラムには出てきません。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003Eちなみに\u003Ccode\u003Es\u003C\u002Fcode\u003Eがグローバル変数\u003Ccode\u003ES\u003C\u002Fcode\u003Eになるとどうなるでしょう。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F\u002F 設計中\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E S: ??? = \u003Cspan class=\"hljs-string\"\u003E&quot;a fixed string&quot;\u003C\u002Fspan\u003E;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eグローバル変数も他の言語同様にヒープではなくOSで言うところのデータ領域に置かれるのでやはり\u003Ccode\u003Estr\u003C\u002Fcode\u003Eであり、\nその領域を指すので変数\u003Ccode\u003ES\u003C\u002Fcode\u003E は\u003Ccode\u003E&amp;str\u003C\u002Fcode\u003E型になります。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F\u002F コンパイルできる\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E S: &amp;\u003Cspan class=\"hljs-built_in\"\u003Estr\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-string\"\u003E&quot;a fixed string&quot;\u003C\u002Fspan\u003E;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch2\u003E前提知識：\u003Ccode\u003Estr\u003C\u002Fcode\u003Eと\u003Ccode\u003EString\u003C\u002Fcode\u003E間の変換\u003C\u002Fh2\u003E\n\u003Ch3\u003E\u003Ccode\u003E&amp;str\u003C\u002Fcode\u003Eから\u003Ccode\u003EString\u003C\u002Fcode\u003Eへ\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Ccode\u003E&amp;str\u003C\u002Fcode\u003E型の変数があればその指している対象から\u003Ccode\u003Eto_string\u003C\u002Fcode\u003Eメソッドを使って\u003Ccode\u003EString\u003C\u002Fcode\u003Eを作ることができます。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F\u002F コンパイルできる\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Ef\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E() {\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E s: &amp;\u003Cspan class=\"hljs-built_in\"\u003Estr\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-string\"\u003E&quot;A fixed string&quot;\u003C\u002Fspan\u003E \n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E t = s.to_string();     \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F ヒープ操作を必要とする\u003C\u002Fspan\u003E\n  ...\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eこの時\u003Ccode\u003Et\u003C\u002Fcode\u003Eの実体はヒープ上に置かれたfat pointerです。固定長なのでメモリを大きく消費するわけではありませんが、実体へのポインタを含む構造体をヒープ上に構成する必要があります。\u003C\u002Fp\u003E\n\u003Ch3\u003E\u003Ccode\u003EString\u003C\u002Fcode\u003Eから\u003Ccode\u003E&amp;str\u003C\u002Fcode\u003Eへ\u003C\u002Fh3\u003E\n\u003Cp\u003E逆の操作は\u003Ccode\u003Eas_str()\u003C\u002Fcode\u003Eです。この操作は\u003Ccode\u003EString\u003C\u002Fcode\u003Eを構成するfat pointerを流用すればいいので極めて軽量です。\nこれは\u003Ccode\u003E&amp;srt\u003C\u002Fcode\u003Eから\u003Ccode\u003EString\u003C\u002Fcode\u003Eへの変換が\u003Ccode\u003Eto_*\u003C\u002Fcode\u003E系なのに対し、\u003Ccode\u003EString\u003C\u002Fcode\u003Eから\u003Ccode\u003E&amp;str\u003C\u002Fcode\u003Eへの変換が\u003Ccode\u003Eas_*\u003C\u002Fcode\u003E系の\u003Ca href=\"https:\u002F\u002Frust-lang.github.io\u002Fapi-guidelines\u002Fnaming.html#ad-hoc-conversions-follow-as_-to_-into_-conventions-c-conv\"\u003E命名\u003C\u002Fa\u003Eになっていることからもわかります。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F\u002F コンパイルできる\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Ef\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E() {\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E s: \u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-string\"\u003E&quot;A fixed string&quot;\u003C\u002Fspan\u003E.to_string();\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E t: &amp;\u003Cspan class=\"hljs-built_in\"\u003Estr\u003C\u002Fspan\u003E = s.as_str();    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 軽量な操作\u003C\u002Fspan\u003E\n  ...\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eここまでが前提知識でした。\u003C\u002Fp\u003E\n\u003Ch1\u003E問題となるシナリオ: \u003Ccode\u003E&amp;str\u003C\u002Fcode\u003E と \u003Ccode\u003EString\u003C\u002Fcode\u003E の混在\u003C\u002Fh1\u003E\n\u003Cp\u003Eさて、以下のような構造体\u003Ccode\u003ES\u003C\u002Fcode\u003Eに対してその文字列表現を返す\u003Ccode\u003Erep()\u003C\u002Fcode\u003Eメソッドを定義するとします。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Estruct\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003ES\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E {\n  index: \u003Cspan class=\"hljs-built_in\"\u003Eusize\u003C\u002Fspan\u003E,\n  vec: \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;\u003Cspan class=\"hljs-built_in\"\u003Eusize\u003C\u002Fspan\u003E&gt;,\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eただし、\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003Eその構造体が持っているフィールド\u003Ccode\u003Eindex\u003C\u002Fcode\u003Eが0の時は固定のメッセージを返す。\u003C\u002Fli\u003E\n\u003Cli\u003Eそうでなければ内部データの値がわかる文字列にしたい。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003Eとします。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F\u002F 設計中\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Eimpl\u003C\u002Fspan\u003E S {\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Erep\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E) -&gt; ??? {\n     \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E.index == \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E {\n         ...\n     } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n         ...\n     }\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3\u003ECase 1: index == 0 のオブジェクトの場合\u003C\u002Fh3\u003E\n\u003Cp\u003Eこの場合、\u003Ccode\u003Erep()\u003C\u002Fcode\u003E内部で固定のメッセージを保持するローカル変数\u003Ccode\u003Emes\u003C\u002Fcode\u003Eの値をそのまま返すことにします。\n\u003Ccode\u003Emes\u003C\u002Fcode\u003Eの型は \u003Ccode\u003E&amp;str\u003C\u002Fcode\u003E であることから\u003Ccode\u003Erep()\u003C\u002Fcode\u003Eの返値型も\u003Ccode\u003E&amp;str\u003C\u002Fcode\u003Eになります。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F\u002F コンパイルできるはず\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Eimpl\u003C\u002Fspan\u003E S {\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Erep\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E) -&gt; &amp;\u003Cspan class=\"hljs-built_in\"\u003Estr\u003C\u002Fspan\u003E {\n     \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E.index == \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E {\n         \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E mes: &amp;\u003Cspan class=\"hljs-built_in\"\u003Estr\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-string\"\u003E&quot;null object&quot;\u003C\u002Fspan\u003E;\n         mes\n     } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n         ...\n     }\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3\u003ECase 2: それ以外\u003C\u002Fh3\u003E\n\u003Cp\u003Eフィールド\u003Ccode\u003Evec\u003C\u002Fcode\u003Eの値を埋め込んだ文字列を作るため\u003Ccode\u003Eformat!\u003C\u002Fcode\u003Eを使うことにしました。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Eformat!\u003C\u002Fcode\u003Eの返す型は\u003Ccode\u003EString\u003C\u002Fcode\u003Eなので\u003Ccode\u003Erep()\u003C\u002Fcode\u003Eの返値型も\u003Ccode\u003EString\u003C\u002Fcode\u003Eになります。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F\u002F コンパイルできない\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Eimpl\u003C\u002Fspan\u003E S {\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Erep\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E) -&gt; \u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E {\n\n\n         ...\n     } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n         \u003Cspan class=\"hljs-built_in\"\u003Eformat!\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E&quot;S{{{:?}}}&quot;\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E.vec)\n     }\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eここで型が一致しない問題に直面します。\u003C\u002Fp\u003E\n\u003Ch3\u003E案1: \u003Ccode\u003E&amp;str\u003C\u002Fcode\u003Eへの統一\u003C\u002Fh3\u003E\n\u003Cp\u003E既に見たようにどちらの方向にも変換できるのでまず\u003Ccode\u003E&amp;str\u003C\u002Fcode\u003Eへ統一することを考えてみます。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Erep\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E) -&gt; &amp;\u003Cspan class=\"hljs-built_in\"\u003Estr\u003C\u002Fspan\u003E {\n     \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E.index == \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E {\n         \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E mes: &amp;\u003Cspan class=\"hljs-built_in\"\u003Estr\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-string\"\u003E&quot;null object&quot;\u003C\u002Fspan\u003E;\n         mes\n     } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n         \u003Cspan class=\"hljs-built_in\"\u003Eformat!\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E&quot;S{{{:?}}}&quot;\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E.vec).as_str()\n     }\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eこれはライフタイム制約を満足しないエラーになります。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003Eerror[E0515]: cannot return value referencing temporary value\n   |\n   |          format!(&quot;S{{{:?}}}&quot;, self.vec).as_str()                                                        \n   |          ------------------------------^^^^^^^^^\n   |          |\n   |          returns a value referencing data owned by the current function\n   |          temporary value created here\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E以下のようにローカル変数\u003Ccode\u003Eres\u003C\u002Fcode\u003Eにバインドしても、\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Erep\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E) -&gt; &amp;\u003Cspan class=\"hljs-built_in\"\u003Estr\u003C\u002Fspan\u003E {\n     \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E.index == \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E {\n         \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E mes: &amp;\u003Cspan class=\"hljs-built_in\"\u003Estr\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-string\"\u003E&quot;null object&quot;\u003C\u002Fspan\u003E;\n         mes\n     } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n         \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E res = \u003Cspan class=\"hljs-built_in\"\u003Eformat!\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E&quot;S{{{:?}}}&quot;\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E.vec);\n         res.as_str()\n     }\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eライフタイムが短すぎることには変わりはないので、エラーになります（\u003Ccode\u003Eres\u003C\u002Fcode\u003Eはヒープに置かれても所有者である\u003Ccode\u003Erep\u003C\u002Fcode\u003Eからexitする時点で回収されてしまう）\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003Eerror[E0515]: cannot return value referencing local variable `res`\n   |\n   |          res.as_str()                                                        \n   |          ---^^^^^^^^^\n   |          |\n   |          returns a value referencing data owned by the current function\n   |          `res` is borrowed here\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eなので、\u003Ccode\u003Eformat!\u003C\u002Fcode\u003Eで作った\u003Ccode\u003EString\u003C\u002Fcode\u003E実体を呼び出し側に渡さないといけません。\u003C\u002Fp\u003E\n\u003Ch3\u003E案2: \u003Ccode\u003EString\u003C\u002Fcode\u003Eへの統一\u003C\u002Fh3\u003E\n\u003Cp\u003Eということで\u003Ccode\u003E&amp;str\u003C\u002Fcode\u003E型の\u003Ccode\u003Emes\u003C\u002Fcode\u003Eを返しているパスの型を変えることにします。関数の返値型を変えてコンパイルすると以下のようなエラーメッセージが表示されます。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003Eerror[E0308]: mismatched types\n  --&gt; src\u002Fmain.rs:13:10\n   |\n   |   fn rep(&amp;self) -&gt; String {                                                                               \n   |                    ------ expected `std::string::String` because of return type\n...\n   |          mes                                                                                           \n   |          ^^^^\n   |          |\n   |          expected struct `std::string::String`, found `&amp;str`\n   |          help: try using a conversion method: `mes.to_string()`\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eヘルプに従って修正すれば問題はなくなります。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F\u002F コンパイルできる\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Erep\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E) -&gt; \u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E {\n     \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E.index == \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E {\n         \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E mes: &amp;\u003Cspan class=\"hljs-built_in\"\u003Estr\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-string\"\u003E&quot;null object&quot;\u003C\u002Fspan\u003E;\n         mes.to_string()\n     } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n         \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E res = \u003Cspan class=\"hljs-built_in\"\u003Eformat!\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E&quot;S{{{:?}}}&quot;\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E.vec);\n         res.as_str()\n     }\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eしかしこれは、必要とは思われないヒープでのオブジェクト生成をしているため、時間的にも空間的にも（できれば避けたい）コストをかけてしまっています。ゼロコストアブストラクションをうたうRustのプログラムとしては是非とも避けたいところです。\u003C\u002Fp\u003E\n\u003Ch3\u003E案3: 型の包含\u003C\u002Fh3\u003E\n\u003Cp\u003Eこの問題を解決するには「借用」と「実体」のどちらも返せるような\u003Ccode\u003Eenum\u003C\u002Fcode\u003Eを用意するという手が使えます。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E借用でいいならなら借用を包む\u003C\u002Fli\u003E\n\u003Cli\u003E実体が必要なら、実体を包む\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F\u002F 設計中（ライフタイム指定がまだついていない）\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Eenum\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EWrapStr\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E {\n  from_str(&amp;\u003Cspan class=\"hljs-built_in\"\u003Estr\u003C\u002Fspan\u003E),\n  from_format(\u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E),\n}\n\n\u003Cspan class=\"hljs-keyword\"\u003Eimpl\u003C\u002Fspan\u003E S {\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Erep\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E) -&gt; WrapStr {\n     \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E.index == \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E {\n         \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E mes: &amp;\u003Cspan class=\"hljs-built_in\"\u003Estr\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-string\"\u003E&quot;null object&quot;\u003C\u002Fspan\u003E;\n         WrapStr::from_str(mes)\n     } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n         WraStr::from_format(\u003Cspan class=\"hljs-built_in\"\u003Eformat!\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E&quot;S{{{:?}}}&quot;\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E.vec))\n     }\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eこうすれば型の問題は解決するし、見かけ上構造体で包むコストは（おそらく）コンパイラの最適化中に何もしないコードに変換されることが期待できます。ということで\u003Ccode\u003EWrapStr\u003C\u002Fcode\u003Eを追加定義すれば問題解決します。ポインタを含むのでライフタイム制約が必要かな。。。\u003C\u002Fp\u003E\n\u003Ch1\u003ECow\u003C\u002Fh1\u003E\n\u003Cp\u003Eしかし自分で定義するよりも、このような状況のための型がすでに標準ライブラリに用意されているのでそれを使いましょう。\nそれがClone on Write, \u003Ccode\u003ECow\u003C\u002Fcode\u003E型です。これは以下のように定義されています。\nhttps:\u002F\u002Fdoc.rust-lang.org\u002Fstd\u002Fborrow\u002Fenum.Cow.html\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F\u002F https:\u002F\u002Fdoc.rust-lang.org\u002Fstd\u002Fborrow\u002Fenum.Cow.html\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Epub\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Eenum\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003ECow\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E&lt;\u003Cspan class=\"hljs-symbol\"\u003E&#x27;a\u003C\u002Fspan\u003E, B&gt; \n\u003Cspan class=\"hljs-keyword\"\u003Ewhere\u003C\u002Fspan\u003E\n    B: \u003Cspan class=\"hljs-symbol\"\u003E&#x27;a\u003C\u002Fspan\u003E + \u003Cspan class=\"hljs-built_in\"\u003EToOwned\u003C\u002Fspan\u003E + ?\u003Cspan class=\"hljs-built_in\"\u003ESized\u003C\u002Fspan\u003E, \n {\n    Borrowed(&amp;\u003Cspan class=\"hljs-symbol\"\u003E&#x27;a\u003C\u002Fspan\u003E B),\n    Owned(&lt;B \u003Cspan class=\"hljs-keyword\"\u003Eas\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003EToOwned\u003C\u002Fspan\u003E&gt;::Owned),\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Ccode\u003EToOwned\u003C\u002Fcode\u003Eは借用したデータから、所有権を持つ実体を構成することができるというトレイトです。\n文字列関連では以下のようになっています。\nhttps:\u002F\u002Fdoc.rust-lang.org\u002Fstd\u002Fborrow\u002Ftrait.ToOwned.html\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u002F\u002F\u002F https:\u002F\u002Fdoc.rust-lang.org\u002Fstd\u002Fborrow\u002Ftrait.ToOwned.html\nimpl ToOwned for str\n  type Owned = String\n  \n  \u002F\u002F\u002F Examples\n  let s: &amp;str = &quot;a&quot;;\n  let ss: String = s.to_owned();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003Eつまり\u003Ccode\u003Estr\u003C\u002Fcode\u003Eから\u003Ccode\u003EString\u003C\u002Fcode\u003Eが作れると。これを見ながら\u003Ccode\u003ECow\u003C\u002Fcode\u003Eの定義の\u003Ccode\u003EB\u003C\u002Fcode\u003Eを\u003Ccode\u003Estr\u003C\u002Fcode\u003Eに変換してやると以下のようになります。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003Epub enum Cow&lt;'a, str&gt; \nwhere\n    str: 'a + ToOwned + ?Sized,  \u002F\u002F 条件OK\n {\n    Borrowed(&amp;'a str),\n    Owned(String),\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003Eということで、借用(\u003Ccode\u003E&amp;str\u003C\u002Fcode\u003E)は\u003Ccode\u003ECow::Borrowed\u003C\u002Fcode\u003Eで実体(\u003Ccode\u003EString\u003C\u002Fcode\u003E)は\u003Ccode\u003ECow::Owned\u003C\u002Fcode\u003Eで包んでやればいいことがわかりました。\u003C\u002Fp\u003E\n\u003Cp\u003E最終的なプログラムはこうなります。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Euse\u003C\u002Fspan\u003E std::borrow::Cow;\n\n\u003Cspan class=\"hljs-keyword\"\u003Eimpl\u003C\u002Fspan\u003E S {\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F\u002F コンパイルできる\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Erep\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E) -&gt; Cow&lt;\u003Cspan class=\"hljs-symbol\"\u003E&#x27;_\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-built_in\"\u003Estr\u003C\u002Fspan\u003E&gt; {\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E.index == \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E {\n      Cow::Borrowed(\u003Cspan class=\"hljs-string\"\u003E&quot;Null S&quot;\u003C\u002Fspan\u003E)                  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 場所は確保済み =&gt; 借用したい\u003C\u002Fspan\u003E\n    } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n      Cow::Owned(\u003Cspan class=\"hljs-built_in\"\u003Eformat!\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E&quot;S[{:?}]&quot;\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E.vec)) \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 借用ではダメ =&gt;実体を渡したい\u003C\u002Fspan\u003E\n    }\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E使う側では一回derefしてやれば借用であったか実体であったかを気にする必要はありません。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-built_in\"\u003Eprintln!\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E&quot;{}&quot;\u003C\u002Fspan\u003E, *s.rep());\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eちなみにderefしたものが何型になっているかというと、\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F コンパイルできる\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E temp: &amp;\u003Cspan class=\"hljs-built_in\"\u003Estr\u003C\u002Fspan\u003E = &amp;*s.rep();\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eだそうです。文字列のスライスみたいですね。\u003C\u002Fp\u003E\n\u003Ch3\u003Eコストについて\u003C\u002Fh3\u003E\n\u003Cp\u003Ederefのコストは以下に引用したようにポインタ辿りだけなので、「軽量」と言ってしまっていいでしょう。\u003C\u002Fp\u003E\n\u003Cp\u003Ehttps:\u002F\u002Fdoc.rust-lang.org\u002Fsrc\u002Falloc\u002Fborrow.rs.html#320\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u002F\u002F\u002F https:\u002F\u002Fdoc.rust-lang.org\u002Fsrc\u002Falloc\u002Fborrow.rs.html#320\n#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]\nimpl&lt;B: ?Sized + ToOwned&gt; Deref for Cow&lt;'_, B&gt; {\n    type Target = B;\n\n    fn deref(&amp;self) -&gt; &amp;B {\n        match *self {\n            Borrowed(borrowed) =&gt; borrowed,\n            Owned(ref owned) =&gt; owned.borrow(),\n        }\n    }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003Ehttps:\u002F\u002Fdoc.rust-lang.org\u002Fsrc\u002Fcore\u002Fborrow.rs.html#212\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F\u002F https:\u002F\u002Fdoc.rust-lang.org\u002Fsrc\u002Fcore\u002Fborrow.rs.html#212\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-meta\"\u003E#[stable(feature = \u003Cspan class=\"hljs-meta-string\"\u003E&quot;rust1&quot;\u003C\u002Fspan\u003E, since = \u003Cspan class=\"hljs-meta-string\"\u003E&quot;1.0.0&quot;\u003C\u002Fspan\u003E)]\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Eimpl\u003C\u002Fspan\u003E&lt;T: ?\u003Cspan class=\"hljs-built_in\"\u003ESized\u003C\u002Fspan\u003E&gt; Borrow&lt;T&gt; \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E T {\n    \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eborrow\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E) -&gt; &amp;T {\n        \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Ehttps:\u002F\u002Fdoc.rust-lang.org\u002Fsrc\u002Fcore\u002Fborrow.rs.html#226\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F\u002F https:\u002F\u002Fdoc.rust-lang.org\u002Fsrc\u002Fcore\u002Fborrow.rs.html#226\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-meta\"\u003E#[stable(feature = \u003Cspan class=\"hljs-meta-string\"\u003E&quot;rust1&quot;\u003C\u002Fspan\u003E, since = \u003Cspan class=\"hljs-meta-string\"\u003E&quot;1.0.0&quot;\u003C\u002Fspan\u003E)]\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Eimpl\u003C\u002Fspan\u003E&lt;T: ?\u003Cspan class=\"hljs-built_in\"\u003ESized\u003C\u002Fspan\u003E&gt; Borrow&lt;T&gt; \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E &amp;T {\n    \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eborrow\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E) -&gt; &amp;T {\n        &amp;**\u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E",dir:"article\u002F.json\u002F2020",base:"2020-08-15-Cow.json",ext:".json",sourceBase:"2020-08-15-Cow.md",sourceExt:".md"}},title:{writable:true,enumerable:true,value:"RustのClone on Writeについて"},subtitle:{writable:true,enumerable:true,value:"std::borrow::cow"},date:{writable:true,enumerable:true,value:"2020-08-15T00:00:00.000Z"},tags:{writable:true,enumerable:true,value:["Rust"]},banner:{writable:true,enumerable:true,value:"\u002Fimg\u002F2020\u002F08-15\u002Fbanner.jpg"},bodyContent:{writable:true,enumerable:true,value:"自転車本では紹介されてないけれど、Rustならでは必要とされる面白い型、Copy on Writeではなくて、Clone on Writeを意味する[`std::borrow::Cow`](https:\u002F\u002Fdoc.rust-lang.org\u002Fstd\u002Fborrow\u002Fenum.Cow.html) の紹介です。\n\n## 前提知識：`str` と `String`の違い\n\n* `str` -- （固定長の）UTF-8文字のスライス\n* `&str` -- UTF-8文字のスライスへのポインタ\n* `String` -- ヒープ上に置かれた、追加を含めた変更ができる文字列\n\n\n## 前提知識：文字列定数とその参照\n\n#### ローカル変数\n\nまず、以下のように関数内のローカルデータとして確保された文字列定数を参照する変数の型を確認しておきます。\n\n```rust\n\u002F\u002F\u002F コンパイルできる\nfn f() {\n  let s = \"a fixed string\";\n  ...\n```\n\nこれは `&str` です。\n\n```rust\n\u002F\u002F\u002F コンパイルできる\nfn f() {\n  let s: &str = \"a fixed string\";\n  ...\n```\n\n* `\"a fixed string\"`はローカルなデータなので（Boxも使ってないし）ヒープに置く必要はありません。\n* 変数`s`はその確保された領域を指すように型付けられます。\n* `str`は通常Rustのプログラムには出てきません。\n\nちなみに`s`がグローバル変数`S`になるとどうなるでしょう。\n\n```rust\n\u002F\u002F\u002F 設計中\nconst S: ??? = \"a fixed string\";\n```\n\nグローバル変数も他の言語同様にヒープではなくOSで言うところのデータ領域に置かれるのでやはり`str`であり、\nその領域を指すので変数`S` は`&str`型になります。\n\n```rust\n\u002F\u002F\u002F コンパイルできる\nconst S: &str = \"a fixed string\";\n```\n\n## 前提知識：`str`と`String`間の変換\n\n### `&str`から`String`へ\n\n`&str`型の変数があればその指している対象から`to_string`メソッドを使って`String`を作ることができます。\n\n```rust\n\u002F\u002F\u002F コンパイルできる\nfn f() {\n  let s: &str = \"A fixed string\" \n  let t = s.to_string();     \u002F\u002F ヒープ操作を必要とする\n  ...\n```\n\nこの時`t`の実体はヒープ上に置かれたfat pointerです。固定長なのでメモリを大きく消費するわけではありませんが、実体へのポインタを含む構造体をヒープ上に構成する必要があります。\n\n### `String`から`&str`へ\n\n逆の操作は`as_str()`です。この操作は`String`を構成するfat pointerを流用すればいいので極めて軽量です。\nこれは`&srt`から`String`への変換が`to_*`系なのに対し、`String`から`&str`への変換が`as_*`系の[命名](https:\u002F\u002Frust-lang.github.io\u002Fapi-guidelines\u002Fnaming.html#ad-hoc-conversions-follow-as_-to_-into_-conventions-c-conv)になっていることからもわかります。\n\n```rust\n\u002F\u002F\u002F コンパイルできる\nfn f() {\n  let s: String = \"A fixed string\".to_string();\n  let t: &str = s.as_str();    \u002F\u002F 軽量な操作\n  ...\n```\n\nここまでが前提知識でした。\n\n# 問題となるシナリオ: `&str` と `String` の混在\n\nさて、以下のような構造体`S`に対してその文字列表現を返す`rep()`メソッドを定義するとします。\n\n```rust\nstruct S {\n  index: usize,\n  vec: Vec\u003Cusize\u003E,\n}\n```\n\nただし、\n\n* その構造体が持っているフィールド`index`が0の時は固定のメッセージを返す。\n* そうでなければ内部データの値がわかる文字列にしたい。\n\nとします。\n\n```rust\n\u002F\u002F\u002F 設計中\nimpl S {\n  fn rep(&self) -\u003E ??? {\n     if self.index == 0 {\n         ...\n     } else {\n         ...\n     }\n  }\n}\n```\n\n### Case 1: index == 0 のオブジェクトの場合\n\nこの場合、`rep()`内部で固定のメッセージを保持するローカル変数`mes`の値をそのまま返すことにします。\n`mes`の型は `&str` であることから`rep()`の返値型も`&str`になります。\n\n```rust\n\u002F\u002F\u002F コンパイルできるはず\nimpl S {\n  fn rep(&self) -\u003E &str {\n     if self.index == 0 {\n         let mes: &str = \"null object\";\n         mes\n     } else {\n         ...\n     }\n  }\n}\n```\n\n### Case 2: それ以外\n\nフィールド`vec`の値を埋め込んだ文字列を作るため`format!`を使うことにしました。\n\n`format!`の返す型は`String`なので`rep()`の返値型も`String`になります。\n```rust\n\u002F\u002F\u002F コンパイルできない\nimpl S {\n  fn rep(&self) -\u003E String {\n\n\n         ...\n     } else {\n         format!(\"S{{{:?}}}\", self.vec)\n     }\n  }\n}\n```\n\nここで型が一致しない問題に直面します。\n\n### 案1: `&str`への統一\n\n既に見たようにどちらの方向にも変換できるのでまず`&str`へ統一することを考えてみます。\n\n```rust\n  fn rep(&self) -\u003E &str {\n     if self.index == 0 {\n         let mes: &str = \"null object\";\n         mes\n     } else {\n         format!(\"S{{{:?}}}\", self.vec).as_str()\n     }\n  }\n}\n```\n\nこれはライフタイム制約を満足しないエラーになります。\n\n```text\nerror[E0515]: cannot return value referencing temporary value\n   |\n   |          format!(\"S{{{:?}}}\", self.vec).as_str()                                                        \n   |          ------------------------------^^^^^^^^^\n   |          |\n   |          returns a value referencing data owned by the current function\n   |          temporary value created here\n```\n\n以下のようにローカル変数`res`にバインドしても、\n\n```rust\n  fn rep(&self) -\u003E &str {\n     if self.index == 0 {\n         let mes: &str = \"null object\";\n         mes\n     } else {\n         let res = format!(\"S{{{:?}}}\", self.vec);\n         res.as_str()\n     }\n  }\n}\n```\n\nライフタイムが短すぎることには変わりはないので、エラーになります（`res`はヒープに置かれても所有者である`rep`からexitする時点で回収されてしまう）\n\n```text\nerror[E0515]: cannot return value referencing local variable `res`\n   |\n   |          res.as_str()                                                        \n   |          ---^^^^^^^^^\n   |          |\n   |          returns a value referencing data owned by the current function\n   |          `res` is borrowed here\n```\n\nなので、`format!`で作った`String`実体を呼び出し側に渡さないといけません。\n\n### 案2: `String`への統一\n\nということで`&str`型の`mes`を返しているパスの型を変えることにします。関数の返値型を変えてコンパイルすると以下のようなエラーメッセージが表示されます。\n\n```text\nerror[E0308]: mismatched types\n  --\u003E src\u002Fmain.rs:13:10\n   |\n   |   fn rep(&self) -\u003E String {                                                                               \n   |                    ------ expected `std::string::String` because of return type\n...\n   |          mes                                                                                           \n   |          ^^^^\n   |          |\n   |          expected struct `std::string::String`, found `&str`\n   |          help: try using a conversion method: `mes.to_string()`\n\n```\n\nヘルプに従って修正すれば問題はなくなります。\n\n```rust\n  \u002F\u002F\u002F コンパイルできる\n  fn rep(&self) -\u003E String {\n     if self.index == 0 {\n         let mes: &str = \"null object\";\n         mes.to_string()\n     } else {\n         let res = format!(\"S{{{:?}}}\", self.vec);\n         res.as_str()\n     }\n  }\n}\n```\n\nしかしこれは、必要とは思われないヒープでのオブジェクト生成をしているため、時間的にも空間的にも（できれば避けたい）コストをかけてしまっています。ゼロコストアブストラクションをうたうRustのプログラムとしては是非とも避けたいところです。\n\n### 案3: 型の包含\n\nこの問題を解決するには「借用」と「実体」のどちらも返せるような`enum`を用意するという手が使えます。\n\n* 借用でいいならなら借用を包む\n* 実体が必要なら、実体を包む\n\n```rust\n\u002F\u002F\u002F 設計中（ライフタイム指定がまだついていない）\nenum WrapStr {\n  from_str(&str),\n  from_format(String),\n}\n\nimpl S {\n  fn rep(&self) -\u003E WrapStr {\n     if self.index == 0 {\n         let mes: &str = \"null object\";\n         WrapStr::from_str(mes)\n     } else {\n         WraStr::from_format(format!(\"S{{{:?}}}\", self.vec))\n     }\n  }\n}\n```\n\nこうすれば型の問題は解決するし、見かけ上構造体で包むコストは（おそらく）コンパイラの最適化中に何もしないコードに変換されることが期待できます。ということで`WrapStr`を追加定義すれば問題解決します。ポインタを含むのでライフタイム制約が必要かな。。。\n\n# Cow\n\nしかし自分で定義するよりも、このような状況のための型がすでに標準ライブラリに用意されているのでそれを使いましょう。\nそれがClone on Write, `Cow`型です。これは以下のように定義されています。\nhttps:\u002F\u002Fdoc.rust-lang.org\u002Fstd\u002Fborrow\u002Fenum.Cow.html\n\n```rust\n\u002F\u002F\u002F https:\u002F\u002Fdoc.rust-lang.org\u002Fstd\u002Fborrow\u002Fenum.Cow.html\npub enum Cow\u003C'a, B\u003E \nwhere\n    B: 'a + ToOwned + ?Sized, \n {\n    Borrowed(&'a B),\n    Owned(\u003CB as ToOwned\u003E::Owned),\n}\n```\n\n`ToOwned`は借用したデータから、所有権を持つ実体を構成することができるというトレイトです。\n文字列関連では以下のようになっています。\nhttps:\u002F\u002Fdoc.rust-lang.org\u002Fstd\u002Fborrow\u002Ftrait.ToOwned.html\n\n```\n\u002F\u002F\u002F https:\u002F\u002Fdoc.rust-lang.org\u002Fstd\u002Fborrow\u002Ftrait.ToOwned.html\nimpl ToOwned for str\n  type Owned = String\n  \n  \u002F\u002F\u002F Examples\n  let s: &str = \"a\";\n  let ss: String = s.to_owned();\n```\n\nつまり`str`から`String`が作れると。これを見ながら`Cow`の定義の`B`を`str`に変換してやると以下のようになります。\n\n```\npub enum Cow\u003C'a, str\u003E \nwhere\n    str: 'a + ToOwned + ?Sized,  \u002F\u002F 条件OK\n {\n    Borrowed(&'a str),\n    Owned(String),\n}\n```\n\nということで、借用(`&str`)は`Cow::Borrowed`で実体(`String`)は`Cow::Owned`で包んでやればいいことがわかりました。\n\n最終的なプログラムはこうなります。\n\n```rust\nuse std::borrow::Cow;\n\nimpl S {\n  \u002F\u002F\u002F コンパイルできる\n  fn rep(&self) -\u003E Cow\u003C'_, str\u003E {\n    if self.index == 0 {\n      Cow::Borrowed(\"Null S\")                  \u002F\u002F 場所は確保済み =\u003E 借用したい\n    } else {\n      Cow::Owned(format!(\"S[{:?}]\", self.vec)) \u002F\u002F 借用ではダメ =\u003E実体を渡したい\n    }\n  }\n}\n```\n\n使う側では一回derefしてやれば借用であったか実体であったかを気にする必要はありません。\n\n```rust\n   println!(\"{}\", *s.rep());\n```\n\nちなみにderefしたものが何型になっているかというと、\n\n```rust\n  \u002F\u002F コンパイルできる\n  let temp: &str = &*s.rep();\n```\n\nだそうです。文字列のスライスみたいですね。\n\n\n### コストについて\n\nderefのコストは以下に引用したようにポインタ辿りだけなので、「軽量」と言ってしまっていいでしょう。\n\nhttps:\u002F\u002Fdoc.rust-lang.org\u002Fsrc\u002Falloc\u002Fborrow.rs.html#320\n```\n\u002F\u002F\u002F https:\u002F\u002Fdoc.rust-lang.org\u002Fsrc\u002Falloc\u002Fborrow.rs.html#320\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl\u003CB: ?Sized + ToOwned\u003E Deref for Cow\u003C'_, B\u003E {\n    type Target = B;\n\n    fn deref(&self) -\u003E &B {\n        match *self {\n            Borrowed(borrowed) =\u003E borrowed,\n            Owned(ref owned) =\u003E owned.borrow(),\n        }\n    }\n}\n```\n\nhttps:\u002F\u002Fdoc.rust-lang.org\u002Fsrc\u002Fcore\u002Fborrow.rs.html#212\n```rust\n\u002F\u002F\u002F https:\u002F\u002Fdoc.rust-lang.org\u002Fsrc\u002Fcore\u002Fborrow.rs.html#212\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl\u003CT: ?Sized\u003E Borrow\u003CT\u003E for T {\n    fn borrow(&self) -\u003E &T {\n        self\n    }\n}\n```\n\nhttps:\u002F\u002Fdoc.rust-lang.org\u002Fsrc\u002Fcore\u002Fborrow.rs.html#226\n```rust\n\u002F\u002F\u002F https:\u002F\u002Fdoc.rust-lang.org\u002Fsrc\u002Fcore\u002Fborrow.rs.html#226\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl\u003CT: ?Sized\u003E Borrow\u003CT\u003E for &T {\n    fn borrow(&self) -\u003E &T {\n        &**self\n    }\n}\n```"},bodyHtml:{writable:true,enumerable:true,value:"\u003Cp\u003E自転車本では紹介されてないけれど、Rustならでは必要とされる面白い型、Copy on Writeではなくて、Clone on Writeを意味する\u003Ca href=\"https:\u002F\u002Fdoc.rust-lang.org\u002Fstd\u002Fborrow\u002Fenum.Cow.html\"\u003E\u003Ccode\u003Estd::borrow::Cow\u003C\u002Fcode\u003E\u003C\u002Fa\u003E の紹介です。\u003C\u002Fp\u003E\n\u003Ch2\u003E前提知識：\u003Ccode\u003Estr\u003C\u002Fcode\u003E と \u003Ccode\u003EString\u003C\u002Fcode\u003Eの違い\u003C\u002Fh2\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003Estr\u003C\u002Fcode\u003E -- （固定長の）UTF-8文字のスライス\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003E&amp;str\u003C\u002Fcode\u003E -- UTF-8文字のスライスへのポインタ\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003EString\u003C\u002Fcode\u003E -- ヒープ上に置かれた、追加を含めた変更ができる文字列\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch2\u003E前提知識：文字列定数とその参照\u003C\u002Fh2\u003E\n\u003Ch4\u003Eローカル変数\u003C\u002Fh4\u003E\n\u003Cp\u003Eまず、以下のように関数内のローカルデータとして確保された文字列定数を参照する変数の型を確認しておきます。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F\u002F コンパイルできる\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Ef\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E() {\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E s = \u003Cspan class=\"hljs-string\"\u003E&quot;a fixed string&quot;\u003C\u002Fspan\u003E;\n  ...\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eこれは \u003Ccode\u003E&amp;str\u003C\u002Fcode\u003E です。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F\u002F コンパイルできる\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Ef\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E() {\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E s: &amp;\u003Cspan class=\"hljs-built_in\"\u003Estr\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-string\"\u003E&quot;a fixed string&quot;\u003C\u002Fspan\u003E;\n  ...\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003E&quot;a fixed string&quot;\u003C\u002Fcode\u003Eはローカルなデータなので（Boxも使ってないし）ヒープに置く必要はありません。\u003C\u002Fli\u003E\n\u003Cli\u003E変数\u003Ccode\u003Es\u003C\u002Fcode\u003Eはその確保された領域を指すように型付けられます。\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Estr\u003C\u002Fcode\u003Eは通常Rustのプログラムには出てきません。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003Eちなみに\u003Ccode\u003Es\u003C\u002Fcode\u003Eがグローバル変数\u003Ccode\u003ES\u003C\u002Fcode\u003Eになるとどうなるでしょう。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F\u002F 設計中\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E S: ??? = \u003Cspan class=\"hljs-string\"\u003E&quot;a fixed string&quot;\u003C\u002Fspan\u003E;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eグローバル変数も他の言語同様にヒープではなくOSで言うところのデータ領域に置かれるのでやはり\u003Ccode\u003Estr\u003C\u002Fcode\u003Eであり、\nその領域を指すので変数\u003Ccode\u003ES\u003C\u002Fcode\u003E は\u003Ccode\u003E&amp;str\u003C\u002Fcode\u003E型になります。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F\u002F コンパイルできる\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E S: &amp;\u003Cspan class=\"hljs-built_in\"\u003Estr\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-string\"\u003E&quot;a fixed string&quot;\u003C\u002Fspan\u003E;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch2\u003E前提知識：\u003Ccode\u003Estr\u003C\u002Fcode\u003Eと\u003Ccode\u003EString\u003C\u002Fcode\u003E間の変換\u003C\u002Fh2\u003E\n\u003Ch3\u003E\u003Ccode\u003E&amp;str\u003C\u002Fcode\u003Eから\u003Ccode\u003EString\u003C\u002Fcode\u003Eへ\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Ccode\u003E&amp;str\u003C\u002Fcode\u003E型の変数があればその指している対象から\u003Ccode\u003Eto_string\u003C\u002Fcode\u003Eメソッドを使って\u003Ccode\u003EString\u003C\u002Fcode\u003Eを作ることができます。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F\u002F コンパイルできる\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Ef\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E() {\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E s: &amp;\u003Cspan class=\"hljs-built_in\"\u003Estr\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-string\"\u003E&quot;A fixed string&quot;\u003C\u002Fspan\u003E \n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E t = s.to_string();     \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F ヒープ操作を必要とする\u003C\u002Fspan\u003E\n  ...\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eこの時\u003Ccode\u003Et\u003C\u002Fcode\u003Eの実体はヒープ上に置かれたfat pointerです。固定長なのでメモリを大きく消費するわけではありませんが、実体へのポインタを含む構造体をヒープ上に構成する必要があります。\u003C\u002Fp\u003E\n\u003Ch3\u003E\u003Ccode\u003EString\u003C\u002Fcode\u003Eから\u003Ccode\u003E&amp;str\u003C\u002Fcode\u003Eへ\u003C\u002Fh3\u003E\n\u003Cp\u003E逆の操作は\u003Ccode\u003Eas_str()\u003C\u002Fcode\u003Eです。この操作は\u003Ccode\u003EString\u003C\u002Fcode\u003Eを構成するfat pointerを流用すればいいので極めて軽量です。\nこれは\u003Ccode\u003E&amp;srt\u003C\u002Fcode\u003Eから\u003Ccode\u003EString\u003C\u002Fcode\u003Eへの変換が\u003Ccode\u003Eto_*\u003C\u002Fcode\u003E系なのに対し、\u003Ccode\u003EString\u003C\u002Fcode\u003Eから\u003Ccode\u003E&amp;str\u003C\u002Fcode\u003Eへの変換が\u003Ccode\u003Eas_*\u003C\u002Fcode\u003E系の\u003Ca href=\"https:\u002F\u002Frust-lang.github.io\u002Fapi-guidelines\u002Fnaming.html#ad-hoc-conversions-follow-as_-to_-into_-conventions-c-conv\"\u003E命名\u003C\u002Fa\u003Eになっていることからもわかります。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F\u002F コンパイルできる\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Ef\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E() {\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E s: \u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-string\"\u003E&quot;A fixed string&quot;\u003C\u002Fspan\u003E.to_string();\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E t: &amp;\u003Cspan class=\"hljs-built_in\"\u003Estr\u003C\u002Fspan\u003E = s.as_str();    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 軽量な操作\u003C\u002Fspan\u003E\n  ...\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eここまでが前提知識でした。\u003C\u002Fp\u003E\n\u003Ch1\u003E問題となるシナリオ: \u003Ccode\u003E&amp;str\u003C\u002Fcode\u003E と \u003Ccode\u003EString\u003C\u002Fcode\u003E の混在\u003C\u002Fh1\u003E\n\u003Cp\u003Eさて、以下のような構造体\u003Ccode\u003ES\u003C\u002Fcode\u003Eに対してその文字列表現を返す\u003Ccode\u003Erep()\u003C\u002Fcode\u003Eメソッドを定義するとします。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Estruct\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003ES\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E {\n  index: \u003Cspan class=\"hljs-built_in\"\u003Eusize\u003C\u002Fspan\u003E,\n  vec: \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;\u003Cspan class=\"hljs-built_in\"\u003Eusize\u003C\u002Fspan\u003E&gt;,\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eただし、\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003Eその構造体が持っているフィールド\u003Ccode\u003Eindex\u003C\u002Fcode\u003Eが0の時は固定のメッセージを返す。\u003C\u002Fli\u003E\n\u003Cli\u003Eそうでなければ内部データの値がわかる文字列にしたい。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003Eとします。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F\u002F 設計中\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Eimpl\u003C\u002Fspan\u003E S {\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Erep\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E) -&gt; ??? {\n     \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E.index == \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E {\n         ...\n     } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n         ...\n     }\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3\u003ECase 1: index == 0 のオブジェクトの場合\u003C\u002Fh3\u003E\n\u003Cp\u003Eこの場合、\u003Ccode\u003Erep()\u003C\u002Fcode\u003E内部で固定のメッセージを保持するローカル変数\u003Ccode\u003Emes\u003C\u002Fcode\u003Eの値をそのまま返すことにします。\n\u003Ccode\u003Emes\u003C\u002Fcode\u003Eの型は \u003Ccode\u003E&amp;str\u003C\u002Fcode\u003E であることから\u003Ccode\u003Erep()\u003C\u002Fcode\u003Eの返値型も\u003Ccode\u003E&amp;str\u003C\u002Fcode\u003Eになります。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F\u002F コンパイルできるはず\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Eimpl\u003C\u002Fspan\u003E S {\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Erep\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E) -&gt; &amp;\u003Cspan class=\"hljs-built_in\"\u003Estr\u003C\u002Fspan\u003E {\n     \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E.index == \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E {\n         \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E mes: &amp;\u003Cspan class=\"hljs-built_in\"\u003Estr\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-string\"\u003E&quot;null object&quot;\u003C\u002Fspan\u003E;\n         mes\n     } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n         ...\n     }\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch3\u003ECase 2: それ以外\u003C\u002Fh3\u003E\n\u003Cp\u003Eフィールド\u003Ccode\u003Evec\u003C\u002Fcode\u003Eの値を埋め込んだ文字列を作るため\u003Ccode\u003Eformat!\u003C\u002Fcode\u003Eを使うことにしました。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Eformat!\u003C\u002Fcode\u003Eの返す型は\u003Ccode\u003EString\u003C\u002Fcode\u003Eなので\u003Ccode\u003Erep()\u003C\u002Fcode\u003Eの返値型も\u003Ccode\u003EString\u003C\u002Fcode\u003Eになります。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F\u002F コンパイルできない\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Eimpl\u003C\u002Fspan\u003E S {\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Erep\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E) -&gt; \u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E {\n\n\n         ...\n     } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n         \u003Cspan class=\"hljs-built_in\"\u003Eformat!\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E&quot;S{{{:?}}}&quot;\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E.vec)\n     }\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eここで型が一致しない問題に直面します。\u003C\u002Fp\u003E\n\u003Ch3\u003E案1: \u003Ccode\u003E&amp;str\u003C\u002Fcode\u003Eへの統一\u003C\u002Fh3\u003E\n\u003Cp\u003E既に見たようにどちらの方向にも変換できるのでまず\u003Ccode\u003E&amp;str\u003C\u002Fcode\u003Eへ統一することを考えてみます。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Erep\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E) -&gt; &amp;\u003Cspan class=\"hljs-built_in\"\u003Estr\u003C\u002Fspan\u003E {\n     \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E.index == \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E {\n         \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E mes: &amp;\u003Cspan class=\"hljs-built_in\"\u003Estr\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-string\"\u003E&quot;null object&quot;\u003C\u002Fspan\u003E;\n         mes\n     } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n         \u003Cspan class=\"hljs-built_in\"\u003Eformat!\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E&quot;S{{{:?}}}&quot;\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E.vec).as_str()\n     }\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eこれはライフタイム制約を満足しないエラーになります。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003Eerror[E0515]: cannot return value referencing temporary value\n   |\n   |          format!(&quot;S{{{:?}}}&quot;, self.vec).as_str()                                                        \n   |          ------------------------------^^^^^^^^^\n   |          |\n   |          returns a value referencing data owned by the current function\n   |          temporary value created here\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E以下のようにローカル変数\u003Ccode\u003Eres\u003C\u002Fcode\u003Eにバインドしても、\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Erep\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E) -&gt; &amp;\u003Cspan class=\"hljs-built_in\"\u003Estr\u003C\u002Fspan\u003E {\n     \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E.index == \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E {\n         \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E mes: &amp;\u003Cspan class=\"hljs-built_in\"\u003Estr\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-string\"\u003E&quot;null object&quot;\u003C\u002Fspan\u003E;\n         mes\n     } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n         \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E res = \u003Cspan class=\"hljs-built_in\"\u003Eformat!\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E&quot;S{{{:?}}}&quot;\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E.vec);\n         res.as_str()\n     }\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eライフタイムが短すぎることには変わりはないので、エラーになります（\u003Ccode\u003Eres\u003C\u002Fcode\u003Eはヒープに置かれても所有者である\u003Ccode\u003Erep\u003C\u002Fcode\u003Eからexitする時点で回収されてしまう）\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003Eerror[E0515]: cannot return value referencing local variable `res`\n   |\n   |          res.as_str()                                                        \n   |          ---^^^^^^^^^\n   |          |\n   |          returns a value referencing data owned by the current function\n   |          `res` is borrowed here\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eなので、\u003Ccode\u003Eformat!\u003C\u002Fcode\u003Eで作った\u003Ccode\u003EString\u003C\u002Fcode\u003E実体を呼び出し側に渡さないといけません。\u003C\u002Fp\u003E\n\u003Ch3\u003E案2: \u003Ccode\u003EString\u003C\u002Fcode\u003Eへの統一\u003C\u002Fh3\u003E\n\u003Cp\u003Eということで\u003Ccode\u003E&amp;str\u003C\u002Fcode\u003E型の\u003Ccode\u003Emes\u003C\u002Fcode\u003Eを返しているパスの型を変えることにします。関数の返値型を変えてコンパイルすると以下のようなエラーメッセージが表示されます。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003Eerror[E0308]: mismatched types\n  --&gt; src\u002Fmain.rs:13:10\n   |\n   |   fn rep(&amp;self) -&gt; String {                                                                               \n   |                    ------ expected `std::string::String` because of return type\n...\n   |          mes                                                                                           \n   |          ^^^^\n   |          |\n   |          expected struct `std::string::String`, found `&amp;str`\n   |          help: try using a conversion method: `mes.to_string()`\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eヘルプに従って修正すれば問題はなくなります。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F\u002F コンパイルできる\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Erep\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E) -&gt; \u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E {\n     \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E.index == \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E {\n         \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E mes: &amp;\u003Cspan class=\"hljs-built_in\"\u003Estr\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-string\"\u003E&quot;null object&quot;\u003C\u002Fspan\u003E;\n         mes.to_string()\n     } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n         \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E res = \u003Cspan class=\"hljs-built_in\"\u003Eformat!\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E&quot;S{{{:?}}}&quot;\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E.vec);\n         res.as_str()\n     }\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eしかしこれは、必要とは思われないヒープでのオブジェクト生成をしているため、時間的にも空間的にも（できれば避けたい）コストをかけてしまっています。ゼロコストアブストラクションをうたうRustのプログラムとしては是非とも避けたいところです。\u003C\u002Fp\u003E\n\u003Ch3\u003E案3: 型の包含\u003C\u002Fh3\u003E\n\u003Cp\u003Eこの問題を解決するには「借用」と「実体」のどちらも返せるような\u003Ccode\u003Eenum\u003C\u002Fcode\u003Eを用意するという手が使えます。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E借用でいいならなら借用を包む\u003C\u002Fli\u003E\n\u003Cli\u003E実体が必要なら、実体を包む\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F\u002F 設計中（ライフタイム指定がまだついていない）\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Eenum\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EWrapStr\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E {\n  from_str(&amp;\u003Cspan class=\"hljs-built_in\"\u003Estr\u003C\u002Fspan\u003E),\n  from_format(\u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E),\n}\n\n\u003Cspan class=\"hljs-keyword\"\u003Eimpl\u003C\u002Fspan\u003E S {\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Erep\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E) -&gt; WrapStr {\n     \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E.index == \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E {\n         \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E mes: &amp;\u003Cspan class=\"hljs-built_in\"\u003Estr\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-string\"\u003E&quot;null object&quot;\u003C\u002Fspan\u003E;\n         WrapStr::from_str(mes)\n     } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n         WraStr::from_format(\u003Cspan class=\"hljs-built_in\"\u003Eformat!\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E&quot;S{{{:?}}}&quot;\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E.vec))\n     }\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eこうすれば型の問題は解決するし、見かけ上構造体で包むコストは（おそらく）コンパイラの最適化中に何もしないコードに変換されることが期待できます。ということで\u003Ccode\u003EWrapStr\u003C\u002Fcode\u003Eを追加定義すれば問題解決します。ポインタを含むのでライフタイム制約が必要かな。。。\u003C\u002Fp\u003E\n\u003Ch1\u003ECow\u003C\u002Fh1\u003E\n\u003Cp\u003Eしかし自分で定義するよりも、このような状況のための型がすでに標準ライブラリに用意されているのでそれを使いましょう。\nそれがClone on Write, \u003Ccode\u003ECow\u003C\u002Fcode\u003E型です。これは以下のように定義されています。\nhttps:\u002F\u002Fdoc.rust-lang.org\u002Fstd\u002Fborrow\u002Fenum.Cow.html\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F\u002F https:\u002F\u002Fdoc.rust-lang.org\u002Fstd\u002Fborrow\u002Fenum.Cow.html\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Epub\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Eenum\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003ECow\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E&lt;\u003Cspan class=\"hljs-symbol\"\u003E&#x27;a\u003C\u002Fspan\u003E, B&gt; \n\u003Cspan class=\"hljs-keyword\"\u003Ewhere\u003C\u002Fspan\u003E\n    B: \u003Cspan class=\"hljs-symbol\"\u003E&#x27;a\u003C\u002Fspan\u003E + \u003Cspan class=\"hljs-built_in\"\u003EToOwned\u003C\u002Fspan\u003E + ?\u003Cspan class=\"hljs-built_in\"\u003ESized\u003C\u002Fspan\u003E, \n {\n    Borrowed(&amp;\u003Cspan class=\"hljs-symbol\"\u003E&#x27;a\u003C\u002Fspan\u003E B),\n    Owned(&lt;B \u003Cspan class=\"hljs-keyword\"\u003Eas\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003EToOwned\u003C\u002Fspan\u003E&gt;::Owned),\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E\u003Ccode\u003EToOwned\u003C\u002Fcode\u003Eは借用したデータから、所有権を持つ実体を構成することができるというトレイトです。\n文字列関連では以下のようになっています。\nhttps:\u002F\u002Fdoc.rust-lang.org\u002Fstd\u002Fborrow\u002Ftrait.ToOwned.html\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u002F\u002F\u002F https:\u002F\u002Fdoc.rust-lang.org\u002Fstd\u002Fborrow\u002Ftrait.ToOwned.html\nimpl ToOwned for str\n  type Owned = String\n  \n  \u002F\u002F\u002F Examples\n  let s: &amp;str = &quot;a&quot;;\n  let ss: String = s.to_owned();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003Eつまり\u003Ccode\u003Estr\u003C\u002Fcode\u003Eから\u003Ccode\u003EString\u003C\u002Fcode\u003Eが作れると。これを見ながら\u003Ccode\u003ECow\u003C\u002Fcode\u003Eの定義の\u003Ccode\u003EB\u003C\u002Fcode\u003Eを\u003Ccode\u003Estr\u003C\u002Fcode\u003Eに変換してやると以下のようになります。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003Epub enum Cow&lt;'a, str&gt; \nwhere\n    str: 'a + ToOwned + ?Sized,  \u002F\u002F 条件OK\n {\n    Borrowed(&amp;'a str),\n    Owned(String),\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003Eということで、借用(\u003Ccode\u003E&amp;str\u003C\u002Fcode\u003E)は\u003Ccode\u003ECow::Borrowed\u003C\u002Fcode\u003Eで実体(\u003Ccode\u003EString\u003C\u002Fcode\u003E)は\u003Ccode\u003ECow::Owned\u003C\u002Fcode\u003Eで包んでやればいいことがわかりました。\u003C\u002Fp\u003E\n\u003Cp\u003E最終的なプログラムはこうなります。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Euse\u003C\u002Fspan\u003E std::borrow::Cow;\n\n\u003Cspan class=\"hljs-keyword\"\u003Eimpl\u003C\u002Fspan\u003E S {\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F\u002F コンパイルできる\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Erep\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E) -&gt; Cow&lt;\u003Cspan class=\"hljs-symbol\"\u003E&#x27;_\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-built_in\"\u003Estr\u003C\u002Fspan\u003E&gt; {\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E.index == \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E {\n      Cow::Borrowed(\u003Cspan class=\"hljs-string\"\u003E&quot;Null S&quot;\u003C\u002Fspan\u003E)                  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 場所は確保済み =&gt; 借用したい\u003C\u002Fspan\u003E\n    } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n      Cow::Owned(\u003Cspan class=\"hljs-built_in\"\u003Eformat!\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E&quot;S[{:?}]&quot;\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E.vec)) \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 借用ではダメ =&gt;実体を渡したい\u003C\u002Fspan\u003E\n    }\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E使う側では一回derefしてやれば借用であったか実体であったかを気にする必要はありません。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-built_in\"\u003Eprintln!\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E&quot;{}&quot;\u003C\u002Fspan\u003E, *s.rep());\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eちなみにderefしたものが何型になっているかというと、\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F コンパイルできる\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E temp: &amp;\u003Cspan class=\"hljs-built_in\"\u003Estr\u003C\u002Fspan\u003E = &amp;*s.rep();\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eだそうです。文字列のスライスみたいですね。\u003C\u002Fp\u003E\n\u003Ch3\u003Eコストについて\u003C\u002Fh3\u003E\n\u003Cp\u003Ederefのコストは以下に引用したようにポインタ辿りだけなので、「軽量」と言ってしまっていいでしょう。\u003C\u002Fp\u003E\n\u003Cp\u003Ehttps:\u002F\u002Fdoc.rust-lang.org\u002Fsrc\u002Falloc\u002Fborrow.rs.html#320\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u002F\u002F\u002F https:\u002F\u002Fdoc.rust-lang.org\u002Fsrc\u002Falloc\u002Fborrow.rs.html#320\n#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]\nimpl&lt;B: ?Sized + ToOwned&gt; Deref for Cow&lt;'_, B&gt; {\n    type Target = B;\n\n    fn deref(&amp;self) -&gt; &amp;B {\n        match *self {\n            Borrowed(borrowed) =&gt; borrowed,\n            Owned(ref owned) =&gt; owned.borrow(),\n        }\n    }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003Ehttps:\u002F\u002Fdoc.rust-lang.org\u002Fsrc\u002Fcore\u002Fborrow.rs.html#212\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F\u002F https:\u002F\u002Fdoc.rust-lang.org\u002Fsrc\u002Fcore\u002Fborrow.rs.html#212\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-meta\"\u003E#[stable(feature = \u003Cspan class=\"hljs-meta-string\"\u003E&quot;rust1&quot;\u003C\u002Fspan\u003E, since = \u003Cspan class=\"hljs-meta-string\"\u003E&quot;1.0.0&quot;\u003C\u002Fspan\u003E)]\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Eimpl\u003C\u002Fspan\u003E&lt;T: ?\u003Cspan class=\"hljs-built_in\"\u003ESized\u003C\u002Fspan\u003E&gt; Borrow&lt;T&gt; \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E T {\n    \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eborrow\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E) -&gt; &amp;T {\n        \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Ehttps:\u002F\u002Fdoc.rust-lang.org\u002Fsrc\u002Fcore\u002Fborrow.rs.html#226\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F\u002F https:\u002F\u002Fdoc.rust-lang.org\u002Fsrc\u002Fcore\u002Fborrow.rs.html#226\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-meta\"\u003E#[stable(feature = \u003Cspan class=\"hljs-meta-string\"\u003E&quot;rust1&quot;\u003C\u002Fspan\u003E, since = \u003Cspan class=\"hljs-meta-string\"\u003E&quot;1.0.0&quot;\u003C\u002Fspan\u003E)]\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Eimpl\u003C\u002Fspan\u003E&lt;T: ?\u003Cspan class=\"hljs-built_in\"\u003ESized\u003C\u002Fspan\u003E&gt; Borrow&lt;T&gt; \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E &amp;T {\n    \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eborrow\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E) -&gt; &amp;T {\n        &amp;**\u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E"},dir:{writable:true,enumerable:true,value:"article\u002F.json\u002F2020"},base:{writable:true,enumerable:true,value:"2020-08-15-Cow.json"},ext:{writable:true,enumerable:true,value:".json"},sourceBase:{writable:true,enumerable:true,value:"2020-08-15-Cow.md"},sourceExt:{writable:true,enumerable:true,value:".md"}})}],fetch:[],mutations:[]});