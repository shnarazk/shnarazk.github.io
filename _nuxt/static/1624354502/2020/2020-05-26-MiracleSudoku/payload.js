__NUXT_JSONP__("/2020/2020-05-26-MiracleSudoku", {data:[{article:Object.create(null,{default:{writable:true,enumerable:true,value:{title:"What's Miracle Sudoku?",subtitle:"for a SAT solver developer",date:"2020-08-24T00:00:00.000Z",tags:["SAT","splr","sudoku"],banner:"https:\u002F\u002Fimages.unsplash.com\u002Fphoto-1511689774932-3aca18459e68?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1234&q=80",bodyContent:"25日のHacker Newsで初めて知ったMiracle Sudoku。[ビデオ](https:\u002F\u002Fwww.youtube.com\u002Fwatch?v=cvEq_XkQg8U)の横に書いてあることから判断するに\n\n* Normal Sudoku rules apply.\n* ナイトまたはキングが1hopで行ける場所には同じ数は置けない: Any two cells separated by a knight's move or a king's move (in chess) cannot contain the same digit.\n* 近接した4近傍には連続する数列は置けない: Any two orthogonally adjacent cells cannot contain consecutive digits.\n\nさあSATソルバの出番。\n\n# 2020-05-30 mokumoku\n\n場所とセルの状態をそれぞれ構造体`Pos`, `Cell`で表現すると\n\n* `fn state(Pos, digit: usize, bool) -\u003E Cell`　で状態を生成\n* `fn requires(Cell, Cell) -\u003E [i32; 2]` で制約節を生成\n* `fn valid(Pos) -\u003E Option\u003CPos\u003E` で妥当なセル座標に限定\n\nといった補助関数を用意すれば後は簡単。\n\n## ナイトまたはキングが1hopで行ける場所には同じ数は置けない\n\nまず、移動可能なベクターを用意。\n\n\n```rust\n    let knights_moves = [\n        Pos::at(-2, 1),\n        Pos::at(-1, 2),\n        Pos::at(1, 2),\n        Pos::at(2, 1),\n        Pos::at(2, -1),\n        Pos::at(1, -2),\n        Pos::at(-1, -2),\n        Pos::at(-2, -1),\n    ];\n```\n\n全ての位置で移動して、妥当な場所なら全ての数字に対して禁止ルールを追加。\n\n```rust\n    let mut rules = Vec::new();\n    for i in 1..=RANGE {\n        for j in 1..=RANGE {\n            let p = Pos::at(i, j);\n            for m in moves.iter() {\n                if let Some(t) = (p + *m).valid() {\n                    for d in 1..=RANGE as usize {\n                        rules.push(p.state(d, true).requires(t.state(d, false)));\n                    }\n                }\n            }\n        }\n    }\n```\n\nキングについても同様。\n\n## 近接した4近傍には連続する数列は置けない\n\nほぼ同じ考えでいける。連続した数列なのでそこだけ変更。\n\n```rust\n    let dirs = [\n        Pos::at(-1, 0), \u002F\u002F North\n        Pos::at(0, 1),  \u002F\u002F East\n        Pos::at(1, 0),  \u002F\u002F South\n        Pos::at(0, -1), \u002F\u002F West\n    ];\n    let mut rules = Vec::new();\n    for i in 1..=RANGE {\n        for j in 1..=RANGE {\n            let p = Pos::at(i, j);\n            for m in dirs.iter() {\n                if let Some(t) = (p + *m).valid() {\n                    for d in 1..RANGE as usize {\n                        rules.push(p.state(d, true).requires(t.state(d + 1, false)));\n                    }\n                }\n            }\n        }\n    }\n```\n\n## SATソルバを呼び出す\n\n`rules`が`Vec\u003CVec\u003Ci32\u003E\u003E`の形なので、後はSplrを呼び出すだけ。\n\n```rust\n    let rules: Vec\u003CVec\u003Ci32\u003E = make_rules();\n    let mut solver = Solver::try_from((Config::default(), rules.as_ref())).expect(\"panic\");\n    \u002F\u002F 初期状態\n    solver.add_assignment(Pos::at(5, 3).state(1, true).as_lit()).expect(\"panic\");\n    solver.add_assignment(Pos::at(6, 7).state(2, true).as_lit()).expect(\"panic\");\n    for ans in solver.iter() {\n        \u002F\u002F 正リテラルだけ抽出\n        let picked = ans.iter().filter(|l| 0 \u003C **l).collect::\u003CVec\u003C&i32\u003E\u003E();\n        println!(-);\n    }\n```\n\nできたプログラムは[こちら](https:\u002F\u002Fgithub.com\u002Fshnarazk\u002Fsudoku_sat)。\n\n\n座標やリテラルは1で始まる一方で、`Vec` は0で始まるといったあたりでいつものようにバグを発生させてしまった\nけど、200行程度でできました。\n\n## 実行結果\n\n得られる出力は以下の通り。\n\n```plaintext\n4 8 3 7 2 6 1 5 9 \n7 2 6 1 5 9 4 8 3 \n1 5 9 4 8 3 7 2 6 \n8 3 7 2 6 1 5 9 4 \n2 6 1 5 9 4 8 3 7 \n5 9 4 8 3 7 2 6 1 \n3 7 2 6 1 5 9 4 8 \n6 1 5 9 4 8 3 7 2 \n9 4 8 3 7 2 6 1 5 \n```\n\nとなって、ビデオの解が唯一解であることも判明しました。\n\n## 2020-08-24\n\nRust-jp slackでの[近隣を辿るイテレータ](https:\u002F\u002Fgithub.com\u002Fshnarazk\u002Fsudoku_sat\u002Fcommit\u002F565e09a45074fd13ac414737836cfcc5e92d40ca)というアイデアがよさそうだったので乗り換えました。\n\n```diff\n    let mut rules = Vec::new();\n    for i in 1..=RANGE {\n        for j in 1..=RANGE {\n            let p = Pos::at(i, j);\n-            for m in moves.iter() {\n-                if let Some(t) = (p + *m).valid() {\n-                    for d in 1..=RANGE as usize {\n-                        rules.push(p.state(d, true).requires(t.state(d, false)));\n-                    }\n+            for q in p.neighbors(&moves) {\n+                for d in 1..=RANGE as usize {\n+                    rules.push(p.state(d, true).requires(q.state(d, false)));\n                 }\n             }\n        }\n    }\n```",bodyHtml:"\u003Cp\u003E25日のHacker Newsで初めて知ったMiracle Sudoku。\u003Ca href=\"https:\u002F\u002Fwww.youtube.com\u002Fwatch?v=cvEq_XkQg8U\"\u003Eビデオ\u003C\u002Fa\u003Eの横に書いてあることから判断するに\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003ENormal Sudoku rules apply.\u003C\u002Fli\u003E\n\u003Cli\u003Eナイトまたはキングが1hopで行ける場所には同じ数は置けない: Any two cells separated by a knight's move or a king's move (in chess) cannot contain the same digit.\u003C\u002Fli\u003E\n\u003Cli\u003E近接した4近傍には連続する数列は置けない: Any two orthogonally adjacent cells cannot contain consecutive digits.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EさあSATソルバの出番。\u003C\u002Fp\u003E\n\u003Ch1\u003E2020-05-30 mokumoku\u003C\u002Fh1\u003E\n\u003Cp\u003E場所とセルの状態をそれぞれ構造体\u003Ccode\u003EPos\u003C\u002Fcode\u003E, \u003Ccode\u003ECell\u003C\u002Fcode\u003Eで表現すると\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003Efn state(Pos, digit: usize, bool) -&gt; Cell\u003C\u002Fcode\u003E　で状態を生成\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Efn requires(Cell, Cell) -&gt; [i32; 2]\u003C\u002Fcode\u003E で制約節を生成\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Efn valid(Pos) -&gt; Option&lt;Pos&gt;\u003C\u002Fcode\u003E で妥当なセル座標に限定\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003Eといった補助関数を用意すれば後は簡単。\u003C\u002Fp\u003E\n\u003Ch2\u003Eナイトまたはキングが1hopで行ける場所には同じ数は置けない\u003C\u002Fh2\u003E\n\u003Cp\u003Eまず、移動可能なベクターを用意。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E knights_moves = [\n        Pos::at(-\u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E),\n        Pos::at(-\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E),\n        Pos::at(\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E),\n        Pos::at(\u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E),\n        Pos::at(\u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E, -\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E),\n        Pos::at(\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E, -\u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E),\n        Pos::at(-\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E, -\u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E),\n        Pos::at(-\u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E, -\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E),\n    ];\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E全ての位置で移動して、妥当な場所なら全ての数字に対して禁止ルールを追加。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E rules = \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E::new();\n    \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E i \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E..=RANGE {\n        \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E j \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E..=RANGE {\n            \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E p = Pos::at(i, j);\n            \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E m \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E moves.iter() {\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003ESome\u003C\u002Fspan\u003E(t) = (p + *m).valid() {\n                    \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E d \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E..=RANGE \u003Cspan class=\"hljs-keyword\"\u003Eas\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003Eusize\u003C\u002Fspan\u003E {\n                        rules.push(p.state(d, \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E).requires(t.state(d, \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E)));\n                    }\n                }\n            }\n        }\n    }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eキングについても同様。\u003C\u002Fp\u003E\n\u003Ch2\u003E近接した4近傍には連続する数列は置けない\u003C\u002Fh2\u003E\n\u003Cp\u003Eほぼ同じ考えでいける。連続した数列なのでそこだけ変更。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E dirs = [\n        Pos::at(-\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E), \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F North\u003C\u002Fspan\u003E\n        Pos::at(\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E),  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F East\u003C\u002Fspan\u003E\n        Pos::at(\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E),  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F South\u003C\u002Fspan\u003E\n        Pos::at(\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E, -\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E), \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F West\u003C\u002Fspan\u003E\n    ];\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E rules = \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E::new();\n    \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E i \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E..=RANGE {\n        \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E j \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E..=RANGE {\n            \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E p = Pos::at(i, j);\n            \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E m \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E dirs.iter() {\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003ESome\u003C\u002Fspan\u003E(t) = (p + *m).valid() {\n                    \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E d \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E..RANGE \u003Cspan class=\"hljs-keyword\"\u003Eas\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003Eusize\u003C\u002Fspan\u003E {\n                        rules.push(p.state(d, \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E).requires(t.state(d + \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E)));\n                    }\n                }\n            }\n        }\n    }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch2\u003ESATソルバを呼び出す\u003C\u002Fh2\u003E\n\u003Cp\u003E\u003Ccode\u003Erules\u003C\u002Fcode\u003Eが\u003Ccode\u003EVec&lt;Vec&lt;i32&gt;&gt;\u003C\u002Fcode\u003Eの形なので、後はSplrを呼び出すだけ。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E rules: \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;\u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;\u003Cspan class=\"hljs-built_in\"\u003Ei32\u003C\u002Fspan\u003E&gt; = make_rules();\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E solver = Solver::try_from((Config::default(), rules.as_ref())).expect(\u003Cspan class=\"hljs-string\"\u003E&quot;panic&quot;\u003C\u002Fspan\u003E);\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 初期状態\u003C\u002Fspan\u003E\n    solver.add_assignment(Pos::at(\u003Cspan class=\"hljs-number\"\u003E5\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E3\u003C\u002Fspan\u003E).state(\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E).as_lit()).expect(\u003Cspan class=\"hljs-string\"\u003E&quot;panic&quot;\u003C\u002Fspan\u003E);\n    solver.add_assignment(Pos::at(\u003Cspan class=\"hljs-number\"\u003E6\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E7\u003C\u002Fspan\u003E).state(\u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E).as_lit()).expect(\u003Cspan class=\"hljs-string\"\u003E&quot;panic&quot;\u003C\u002Fspan\u003E);\n    \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E ans \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E solver.iter() {\n        \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 正リテラルだけ抽出\u003C\u002Fspan\u003E\n        \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E picked = ans.iter().filter(|l| \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E &lt; **l).collect::&lt;\u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;&amp;\u003Cspan class=\"hljs-built_in\"\u003Ei32\u003C\u002Fspan\u003E&gt;&gt;();\n        \u003Cspan class=\"hljs-built_in\"\u003Eprintln!\u003C\u002Fspan\u003E(-);\n    }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eできたプログラムは\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fshnarazk\u002Fsudoku_sat\"\u003Eこちら\u003C\u002Fa\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E座標やリテラルは1で始まる一方で、\u003Ccode\u003EVec\u003C\u002Fcode\u003E は0で始まるといったあたりでいつものようにバグを発生させてしまった\nけど、200行程度でできました。\u003C\u002Fp\u003E\n\u003Ch2\u003E実行結果\u003C\u002Fh2\u003E\n\u003Cp\u003E得られる出力は以下の通り。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E4 8 3 7 2 6 1 5 9 \n7 2 6 1 5 9 4 8 3 \n1 5 9 4 8 3 7 2 6 \n8 3 7 2 6 1 5 9 4 \n2 6 1 5 9 4 8 3 7 \n5 9 4 8 3 7 2 6 1 \n3 7 2 6 1 5 9 4 8 \n6 1 5 9 4 8 3 7 2 \n9 4 8 3 7 2 6 1 5\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eとなって、ビデオの解が唯一解であることも判明しました。\u003C\u002Fp\u003E\n\u003Ch2\u003E2020-08-24\u003C\u002Fh2\u003E\n\u003Cp\u003ERust-jp slackでの\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fshnarazk\u002Fsudoku_sat\u002Fcommit\u002F565e09a45074fd13ac414737836cfcc5e92d40ca\"\u003E近隣を辿るイテレータ\u003C\u002Fa\u003Eというアイデアがよさそうだったので乗り換えました。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003Elet mut rules = Vec::new();\n    for i in 1..=RANGE {\n        for j in 1..=RANGE {\n            let p = Pos::at(i, j);\n\u003Cspan class=\"hljs-deletion\"\u003E-            for m in moves.iter() {\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-deletion\"\u003E-                if let Some(t) = (p + *m).valid() {\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-deletion\"\u003E-                    for d in 1..=RANGE as usize {\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-deletion\"\u003E-                        rules.push(p.state(d, true).requires(t.state(d, false)));\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-deletion\"\u003E-                    }\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-addition\"\u003E+            for q in p.neighbors(&amp;moves) {\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-addition\"\u003E+                for d in 1..=RANGE as usize {\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-addition\"\u003E+                    rules.push(p.state(d, true).requires(q.state(d, false)));\u003C\u002Fspan\u003E\n                 }\n             }\n        }\n    }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E",dir:"article\u002F.json\u002F2020",base:"2020-05-26-MiracleSudoku.json",ext:".json",sourceBase:"2020-05-26-MiracleSudoku.md",sourceExt:".md"}},title:{writable:true,enumerable:true,value:"What's Miracle Sudoku?"},subtitle:{writable:true,enumerable:true,value:"for a SAT solver developer"},date:{writable:true,enumerable:true,value:"2020-08-24T00:00:00.000Z"},tags:{writable:true,enumerable:true,value:["SAT","splr","sudoku"]},banner:{writable:true,enumerable:true,value:"https:\u002F\u002Fimages.unsplash.com\u002Fphoto-1511689774932-3aca18459e68?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1234&q=80"},bodyContent:{writable:true,enumerable:true,value:"25日のHacker Newsで初めて知ったMiracle Sudoku。[ビデオ](https:\u002F\u002Fwww.youtube.com\u002Fwatch?v=cvEq_XkQg8U)の横に書いてあることから判断するに\n\n* Normal Sudoku rules apply.\n* ナイトまたはキングが1hopで行ける場所には同じ数は置けない: Any two cells separated by a knight's move or a king's move (in chess) cannot contain the same digit.\n* 近接した4近傍には連続する数列は置けない: Any two orthogonally adjacent cells cannot contain consecutive digits.\n\nさあSATソルバの出番。\n\n# 2020-05-30 mokumoku\n\n場所とセルの状態をそれぞれ構造体`Pos`, `Cell`で表現すると\n\n* `fn state(Pos, digit: usize, bool) -\u003E Cell`　で状態を生成\n* `fn requires(Cell, Cell) -\u003E [i32; 2]` で制約節を生成\n* `fn valid(Pos) -\u003E Option\u003CPos\u003E` で妥当なセル座標に限定\n\nといった補助関数を用意すれば後は簡単。\n\n## ナイトまたはキングが1hopで行ける場所には同じ数は置けない\n\nまず、移動可能なベクターを用意。\n\n\n```rust\n    let knights_moves = [\n        Pos::at(-2, 1),\n        Pos::at(-1, 2),\n        Pos::at(1, 2),\n        Pos::at(2, 1),\n        Pos::at(2, -1),\n        Pos::at(1, -2),\n        Pos::at(-1, -2),\n        Pos::at(-2, -1),\n    ];\n```\n\n全ての位置で移動して、妥当な場所なら全ての数字に対して禁止ルールを追加。\n\n```rust\n    let mut rules = Vec::new();\n    for i in 1..=RANGE {\n        for j in 1..=RANGE {\n            let p = Pos::at(i, j);\n            for m in moves.iter() {\n                if let Some(t) = (p + *m).valid() {\n                    for d in 1..=RANGE as usize {\n                        rules.push(p.state(d, true).requires(t.state(d, false)));\n                    }\n                }\n            }\n        }\n    }\n```\n\nキングについても同様。\n\n## 近接した4近傍には連続する数列は置けない\n\nほぼ同じ考えでいける。連続した数列なのでそこだけ変更。\n\n```rust\n    let dirs = [\n        Pos::at(-1, 0), \u002F\u002F North\n        Pos::at(0, 1),  \u002F\u002F East\n        Pos::at(1, 0),  \u002F\u002F South\n        Pos::at(0, -1), \u002F\u002F West\n    ];\n    let mut rules = Vec::new();\n    for i in 1..=RANGE {\n        for j in 1..=RANGE {\n            let p = Pos::at(i, j);\n            for m in dirs.iter() {\n                if let Some(t) = (p + *m).valid() {\n                    for d in 1..RANGE as usize {\n                        rules.push(p.state(d, true).requires(t.state(d + 1, false)));\n                    }\n                }\n            }\n        }\n    }\n```\n\n## SATソルバを呼び出す\n\n`rules`が`Vec\u003CVec\u003Ci32\u003E\u003E`の形なので、後はSplrを呼び出すだけ。\n\n```rust\n    let rules: Vec\u003CVec\u003Ci32\u003E = make_rules();\n    let mut solver = Solver::try_from((Config::default(), rules.as_ref())).expect(\"panic\");\n    \u002F\u002F 初期状態\n    solver.add_assignment(Pos::at(5, 3).state(1, true).as_lit()).expect(\"panic\");\n    solver.add_assignment(Pos::at(6, 7).state(2, true).as_lit()).expect(\"panic\");\n    for ans in solver.iter() {\n        \u002F\u002F 正リテラルだけ抽出\n        let picked = ans.iter().filter(|l| 0 \u003C **l).collect::\u003CVec\u003C&i32\u003E\u003E();\n        println!(-);\n    }\n```\n\nできたプログラムは[こちら](https:\u002F\u002Fgithub.com\u002Fshnarazk\u002Fsudoku_sat)。\n\n\n座標やリテラルは1で始まる一方で、`Vec` は0で始まるといったあたりでいつものようにバグを発生させてしまった\nけど、200行程度でできました。\n\n## 実行結果\n\n得られる出力は以下の通り。\n\n```plaintext\n4 8 3 7 2 6 1 5 9 \n7 2 6 1 5 9 4 8 3 \n1 5 9 4 8 3 7 2 6 \n8 3 7 2 6 1 5 9 4 \n2 6 1 5 9 4 8 3 7 \n5 9 4 8 3 7 2 6 1 \n3 7 2 6 1 5 9 4 8 \n6 1 5 9 4 8 3 7 2 \n9 4 8 3 7 2 6 1 5 \n```\n\nとなって、ビデオの解が唯一解であることも判明しました。\n\n## 2020-08-24\n\nRust-jp slackでの[近隣を辿るイテレータ](https:\u002F\u002Fgithub.com\u002Fshnarazk\u002Fsudoku_sat\u002Fcommit\u002F565e09a45074fd13ac414737836cfcc5e92d40ca)というアイデアがよさそうだったので乗り換えました。\n\n```diff\n    let mut rules = Vec::new();\n    for i in 1..=RANGE {\n        for j in 1..=RANGE {\n            let p = Pos::at(i, j);\n-            for m in moves.iter() {\n-                if let Some(t) = (p + *m).valid() {\n-                    for d in 1..=RANGE as usize {\n-                        rules.push(p.state(d, true).requires(t.state(d, false)));\n-                    }\n+            for q in p.neighbors(&moves) {\n+                for d in 1..=RANGE as usize {\n+                    rules.push(p.state(d, true).requires(q.state(d, false)));\n                 }\n             }\n        }\n    }\n```"},bodyHtml:{writable:true,enumerable:true,value:"\u003Cp\u003E25日のHacker Newsで初めて知ったMiracle Sudoku。\u003Ca href=\"https:\u002F\u002Fwww.youtube.com\u002Fwatch?v=cvEq_XkQg8U\"\u003Eビデオ\u003C\u002Fa\u003Eの横に書いてあることから判断するに\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003ENormal Sudoku rules apply.\u003C\u002Fli\u003E\n\u003Cli\u003Eナイトまたはキングが1hopで行ける場所には同じ数は置けない: Any two cells separated by a knight's move or a king's move (in chess) cannot contain the same digit.\u003C\u002Fli\u003E\n\u003Cli\u003E近接した4近傍には連続する数列は置けない: Any two orthogonally adjacent cells cannot contain consecutive digits.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EさあSATソルバの出番。\u003C\u002Fp\u003E\n\u003Ch1\u003E2020-05-30 mokumoku\u003C\u002Fh1\u003E\n\u003Cp\u003E場所とセルの状態をそれぞれ構造体\u003Ccode\u003EPos\u003C\u002Fcode\u003E, \u003Ccode\u003ECell\u003C\u002Fcode\u003Eで表現すると\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003Efn state(Pos, digit: usize, bool) -&gt; Cell\u003C\u002Fcode\u003E　で状態を生成\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Efn requires(Cell, Cell) -&gt; [i32; 2]\u003C\u002Fcode\u003E で制約節を生成\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Efn valid(Pos) -&gt; Option&lt;Pos&gt;\u003C\u002Fcode\u003E で妥当なセル座標に限定\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003Eといった補助関数を用意すれば後は簡単。\u003C\u002Fp\u003E\n\u003Ch2\u003Eナイトまたはキングが1hopで行ける場所には同じ数は置けない\u003C\u002Fh2\u003E\n\u003Cp\u003Eまず、移動可能なベクターを用意。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E knights_moves = [\n        Pos::at(-\u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E),\n        Pos::at(-\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E),\n        Pos::at(\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E),\n        Pos::at(\u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E),\n        Pos::at(\u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E, -\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E),\n        Pos::at(\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E, -\u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E),\n        Pos::at(-\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E, -\u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E),\n        Pos::at(-\u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E, -\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E),\n    ];\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E全ての位置で移動して、妥当な場所なら全ての数字に対して禁止ルールを追加。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E rules = \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E::new();\n    \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E i \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E..=RANGE {\n        \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E j \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E..=RANGE {\n            \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E p = Pos::at(i, j);\n            \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E m \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E moves.iter() {\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003ESome\u003C\u002Fspan\u003E(t) = (p + *m).valid() {\n                    \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E d \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E..=RANGE \u003Cspan class=\"hljs-keyword\"\u003Eas\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003Eusize\u003C\u002Fspan\u003E {\n                        rules.push(p.state(d, \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E).requires(t.state(d, \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E)));\n                    }\n                }\n            }\n        }\n    }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eキングについても同様。\u003C\u002Fp\u003E\n\u003Ch2\u003E近接した4近傍には連続する数列は置けない\u003C\u002Fh2\u003E\n\u003Cp\u003Eほぼ同じ考えでいける。連続した数列なのでそこだけ変更。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E dirs = [\n        Pos::at(-\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E), \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F North\u003C\u002Fspan\u003E\n        Pos::at(\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E),  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F East\u003C\u002Fspan\u003E\n        Pos::at(\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E),  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F South\u003C\u002Fspan\u003E\n        Pos::at(\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E, -\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E), \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F West\u003C\u002Fspan\u003E\n    ];\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E rules = \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E::new();\n    \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E i \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E..=RANGE {\n        \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E j \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E..=RANGE {\n            \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E p = Pos::at(i, j);\n            \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E m \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E dirs.iter() {\n                \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003ESome\u003C\u002Fspan\u003E(t) = (p + *m).valid() {\n                    \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E d \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E..RANGE \u003Cspan class=\"hljs-keyword\"\u003Eas\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003Eusize\u003C\u002Fspan\u003E {\n                        rules.push(p.state(d, \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E).requires(t.state(d + \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E)));\n                    }\n                }\n            }\n        }\n    }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch2\u003ESATソルバを呼び出す\u003C\u002Fh2\u003E\n\u003Cp\u003E\u003Ccode\u003Erules\u003C\u002Fcode\u003Eが\u003Ccode\u003EVec&lt;Vec&lt;i32&gt;&gt;\u003C\u002Fcode\u003Eの形なので、後はSplrを呼び出すだけ。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E rules: \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;\u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;\u003Cspan class=\"hljs-built_in\"\u003Ei32\u003C\u002Fspan\u003E&gt; = make_rules();\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E solver = Solver::try_from((Config::default(), rules.as_ref())).expect(\u003Cspan class=\"hljs-string\"\u003E&quot;panic&quot;\u003C\u002Fspan\u003E);\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 初期状態\u003C\u002Fspan\u003E\n    solver.add_assignment(Pos::at(\u003Cspan class=\"hljs-number\"\u003E5\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E3\u003C\u002Fspan\u003E).state(\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E).as_lit()).expect(\u003Cspan class=\"hljs-string\"\u003E&quot;panic&quot;\u003C\u002Fspan\u003E);\n    solver.add_assignment(Pos::at(\u003Cspan class=\"hljs-number\"\u003E6\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E7\u003C\u002Fspan\u003E).state(\u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E).as_lit()).expect(\u003Cspan class=\"hljs-string\"\u003E&quot;panic&quot;\u003C\u002Fspan\u003E);\n    \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E ans \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E solver.iter() {\n        \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 正リテラルだけ抽出\u003C\u002Fspan\u003E\n        \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E picked = ans.iter().filter(|l| \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E &lt; **l).collect::&lt;\u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;&amp;\u003Cspan class=\"hljs-built_in\"\u003Ei32\u003C\u002Fspan\u003E&gt;&gt;();\n        \u003Cspan class=\"hljs-built_in\"\u003Eprintln!\u003C\u002Fspan\u003E(-);\n    }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eできたプログラムは\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fshnarazk\u002Fsudoku_sat\"\u003Eこちら\u003C\u002Fa\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E座標やリテラルは1で始まる一方で、\u003Ccode\u003EVec\u003C\u002Fcode\u003E は0で始まるといったあたりでいつものようにバグを発生させてしまった\nけど、200行程度でできました。\u003C\u002Fp\u003E\n\u003Ch2\u003E実行結果\u003C\u002Fh2\u003E\n\u003Cp\u003E得られる出力は以下の通り。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E4 8 3 7 2 6 1 5 9 \n7 2 6 1 5 9 4 8 3 \n1 5 9 4 8 3 7 2 6 \n8 3 7 2 6 1 5 9 4 \n2 6 1 5 9 4 8 3 7 \n5 9 4 8 3 7 2 6 1 \n3 7 2 6 1 5 9 4 8 \n6 1 5 9 4 8 3 7 2 \n9 4 8 3 7 2 6 1 5\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eとなって、ビデオの解が唯一解であることも判明しました。\u003C\u002Fp\u003E\n\u003Ch2\u003E2020-08-24\u003C\u002Fh2\u003E\n\u003Cp\u003ERust-jp slackでの\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fshnarazk\u002Fsudoku_sat\u002Fcommit\u002F565e09a45074fd13ac414737836cfcc5e92d40ca\"\u003E近隣を辿るイテレータ\u003C\u002Fa\u003Eというアイデアがよさそうだったので乗り換えました。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003Elet mut rules = Vec::new();\n    for i in 1..=RANGE {\n        for j in 1..=RANGE {\n            let p = Pos::at(i, j);\n\u003Cspan class=\"hljs-deletion\"\u003E-            for m in moves.iter() {\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-deletion\"\u003E-                if let Some(t) = (p + *m).valid() {\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-deletion\"\u003E-                    for d in 1..=RANGE as usize {\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-deletion\"\u003E-                        rules.push(p.state(d, true).requires(t.state(d, false)));\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-deletion\"\u003E-                    }\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-addition\"\u003E+            for q in p.neighbors(&amp;moves) {\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-addition\"\u003E+                for d in 1..=RANGE as usize {\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-addition\"\u003E+                    rules.push(p.state(d, true).requires(q.state(d, false)));\u003C\u002Fspan\u003E\n                 }\n             }\n        }\n    }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E"},dir:{writable:true,enumerable:true,value:"article\u002F.json\u002F2020"},base:{writable:true,enumerable:true,value:"2020-05-26-MiracleSudoku.json"},ext:{writable:true,enumerable:true,value:".json"},sourceBase:{writable:true,enumerable:true,value:"2020-05-26-MiracleSudoku.md"},sourceExt:{writable:true,enumerable:true,value:".md"}})}],fetch:[],mutations:[]});