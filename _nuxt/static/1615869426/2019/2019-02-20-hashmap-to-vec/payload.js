__NUXT_JSONP__("/2019/2019-02-20-hashmap-to-vec", {data:[{article:Object.create(null,{default:{writable:true,enumerable:true,value:{title:"Make Vec from HashMap in Rust",subtitle:"関数型プログラミング的にHashMapからVecを作る",date:"2019-02-20T00:00:00.000Z",tags:["rust"],bodyContent:"Think about [HashMap](https:\u002F\u002Fdoc.rust-lang.org\u002Fstd\u002Fcollections\u002Fstruct.HashMap.html)\n\n```rust\nStruct std::collections::HashMap\n\n    pub fn insert(&mut self, k: K, v: V) -\u003E Option\u003CV\u003E\n        Inserts a key-value pair into the map.\n\n    pub fn keys(&self) -\u003E Keys\u003CK, V\u003E[src]\n        An iterator visiting all keys in arbitrary order. The iterator element type is &'a K.\n```\n\nAs a straight application of `insert`, the following code seems to work well.\n\n```rust\n\u002F\u002F collect keys of a HashMap into a Vec\nlet h: HashMap\u003CK, V\u003E;\nlet v: Vec\u003C_\u003E = h.keys().collect();\n```\n\nBut in some case this is troublesome. For example,\n\n```rust\n\u002F\u002F key is String\nlet h: HashMap\u003CString, V\u003E;\nreturn h.keys().collect::\u003CVec\u003CString\u003E\u003E();\n```\n\nis a type mismatch because the return type of `keys` is the reference to key:\n\n```\nerror[E0277]: a collection of type `std::vec::Vec\u003Cstd::string::String\u003E` cannot be built from an iterator over elements of type `&std::string::String`\n```\n\nTo fix it, make `hash` hold `&String` as *key*:\n\n```rust\n\u002F\u002F change the key's type\nlet h: HashMap\u003C&String, V\u003E;\nreturn h.keys().collect::\u003CVec\u003C&String\u003E\u003E();\n```\n\nit emits another error in this case:\n\n```\nerror[E0515]: cannot return value referencing local variable `h`\n```\n\nHow about dereferencing and *injecting* them to the return value?\n\n```rust\n\u002F\u002F &String to String\nlet h: HashMap\u003C&String, V\u003E;\nlet v: Vec\u003CString\u003E = h.keys().map(|k| *k).collect();\n```\n\nIt can't work (we can't destruct data in order to make a return value):\n\n```\nerror[E0507]: cannot move out of borrowed content\n```\n\nSo we need to copy them explicitly, if `K` doesn't have `Copy` trait.\n\n```rust\nlet hash: HashMap\u003CString, V\u003E;\nreturn hash.keys().map(|k| k.to_string()).collect::\u003CVec\u003CString\u003E\u003E();\n```\n\nBut this code may contain unwanted memory copy. So make `hash` hold the reference.\n\n\n```rust\n\u002F\u002F `hash` points the original data to avoid double allocation\nlet hash: HashMap\u003C&String, V\u003E;\nreturn hash.keys().map(|k| k.to_string()).collect::\u003CVec\u003CString\u003E\u003E();\n```\n\nThat's it.",bodyHtml:"\u003Cp\u003EThink about \u003Ca href=\"https:\u002F\u002Fdoc.rust-lang.org\u002Fstd\u002Fcollections\u002Fstruct.HashMap.html\"\u003EHashMap\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003EStruct std::collections::HashMap\n\n    \u003Cspan class=\"hljs-keyword\"\u003Epub\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Einsert\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E, k: K, v: V) -&gt; \u003Cspan class=\"hljs-built_in\"\u003EOption\u003C\u002Fspan\u003E&lt;V&gt;\n        Inserts a key-value pair into the map.\n\n    \u003Cspan class=\"hljs-keyword\"\u003Epub\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Ekeys\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E) -&gt; Keys&lt;K, V&gt;[src]\n        An iterator visiting all keys \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E arbitrary order. The iterator element \u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Etype\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eis\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E &amp;\u003Cspan class=\"hljs-symbol\"\u003E&#x27;a\u003C\u002Fspan\u003E K.\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EAs a straight application of \u003Ccode\u003Einsert\u003C\u002Fcode\u003E, the following code seems to work well.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F collect keys of a HashMap into a Vec\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E h: HashMap&lt;K, V&gt;;\n\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E v: \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;_&gt; = h.keys().collect();\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EBut in some case this is troublesome. For example,\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F key is String\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E h: HashMap&lt;\u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E, V&gt;;\n\u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E h.keys().collect::&lt;\u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;\u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E&gt;&gt;();\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eis a type mismatch because the return type of \u003Ccode\u003Ekeys\u003C\u002Fcode\u003E is the reference to key:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003Eerror[E0277]: a collection of type `std::vec::Vec&lt;std::string::String&gt;` cannot be built from an iterator over elements of type `&amp;std::string::String`\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003ETo fix it, make \u003Ccode\u003Ehash\u003C\u002Fcode\u003E hold \u003Ccode\u003E&amp;String\u003C\u002Fcode\u003E as \u003Cem\u003Ekey\u003C\u002Fem\u003E:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F change the key&#x27;s type\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E h: HashMap&lt;&amp;\u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E, V&gt;;\n\u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E h.keys().collect::&lt;\u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;&amp;\u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E&gt;&gt;();\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eit emits another error in this case:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003Eerror[E0515]: cannot return value referencing local variable `h`\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EHow about dereferencing and \u003Cem\u003Einjecting\u003C\u002Fem\u003E them to the return value?\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F &amp;String to String\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E h: HashMap&lt;&amp;\u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E, V&gt;;\n\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E v: \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;\u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E&gt; = h.keys().map(|k| *k).collect();\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EIt can't work (we can't destruct data in order to make a return value):\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003Eerror[E0507]: cannot move out of borrowed content\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003ESo we need to copy them explicitly, if \u003Ccode\u003EK\u003C\u002Fcode\u003E doesn't have \u003Ccode\u003ECopy\u003C\u002Fcode\u003E trait.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E hash: HashMap&lt;\u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E, V&gt;;\n\u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E hash.keys().map(|k| k.to_string()).collect::&lt;\u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;\u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E&gt;&gt;();\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EBut this code may contain unwanted memory copy. So make \u003Ccode\u003Ehash\u003C\u002Fcode\u003E hold the reference.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F `hash` points the original data to avoid double allocation\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E hash: HashMap&lt;&amp;\u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E, V&gt;;\n\u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E hash.keys().map(|k| k.to_string()).collect::&lt;\u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;\u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E&gt;&gt;();\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EThat's it.\u003C\u002Fp\u003E\n",dir:"article\u002F.json\u002F2019",base:"2019-02-20-hashmap-to-vec.json",ext:".json",sourceBase:"2019-02-20-hashmap-to-vec.md",sourceExt:".md"}},title:{writable:true,enumerable:true,value:"Make Vec from HashMap in Rust"},subtitle:{writable:true,enumerable:true,value:"関数型プログラミング的にHashMapからVecを作る"},date:{writable:true,enumerable:true,value:"2019-02-20T00:00:00.000Z"},tags:{writable:true,enumerable:true,value:["rust"]},bodyContent:{writable:true,enumerable:true,value:"Think about [HashMap](https:\u002F\u002Fdoc.rust-lang.org\u002Fstd\u002Fcollections\u002Fstruct.HashMap.html)\n\n```rust\nStruct std::collections::HashMap\n\n    pub fn insert(&mut self, k: K, v: V) -\u003E Option\u003CV\u003E\n        Inserts a key-value pair into the map.\n\n    pub fn keys(&self) -\u003E Keys\u003CK, V\u003E[src]\n        An iterator visiting all keys in arbitrary order. The iterator element type is &'a K.\n```\n\nAs a straight application of `insert`, the following code seems to work well.\n\n```rust\n\u002F\u002F collect keys of a HashMap into a Vec\nlet h: HashMap\u003CK, V\u003E;\nlet v: Vec\u003C_\u003E = h.keys().collect();\n```\n\nBut in some case this is troublesome. For example,\n\n```rust\n\u002F\u002F key is String\nlet h: HashMap\u003CString, V\u003E;\nreturn h.keys().collect::\u003CVec\u003CString\u003E\u003E();\n```\n\nis a type mismatch because the return type of `keys` is the reference to key:\n\n```\nerror[E0277]: a collection of type `std::vec::Vec\u003Cstd::string::String\u003E` cannot be built from an iterator over elements of type `&std::string::String`\n```\n\nTo fix it, make `hash` hold `&String` as *key*:\n\n```rust\n\u002F\u002F change the key's type\nlet h: HashMap\u003C&String, V\u003E;\nreturn h.keys().collect::\u003CVec\u003C&String\u003E\u003E();\n```\n\nit emits another error in this case:\n\n```\nerror[E0515]: cannot return value referencing local variable `h`\n```\n\nHow about dereferencing and *injecting* them to the return value?\n\n```rust\n\u002F\u002F &String to String\nlet h: HashMap\u003C&String, V\u003E;\nlet v: Vec\u003CString\u003E = h.keys().map(|k| *k).collect();\n```\n\nIt can't work (we can't destruct data in order to make a return value):\n\n```\nerror[E0507]: cannot move out of borrowed content\n```\n\nSo we need to copy them explicitly, if `K` doesn't have `Copy` trait.\n\n```rust\nlet hash: HashMap\u003CString, V\u003E;\nreturn hash.keys().map(|k| k.to_string()).collect::\u003CVec\u003CString\u003E\u003E();\n```\n\nBut this code may contain unwanted memory copy. So make `hash` hold the reference.\n\n\n```rust\n\u002F\u002F `hash` points the original data to avoid double allocation\nlet hash: HashMap\u003C&String, V\u003E;\nreturn hash.keys().map(|k| k.to_string()).collect::\u003CVec\u003CString\u003E\u003E();\n```\n\nThat's it."},bodyHtml:{writable:true,enumerable:true,value:"\u003Cp\u003EThink about \u003Ca href=\"https:\u002F\u002Fdoc.rust-lang.org\u002Fstd\u002Fcollections\u002Fstruct.HashMap.html\"\u003EHashMap\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003EStruct std::collections::HashMap\n\n    \u003Cspan class=\"hljs-keyword\"\u003Epub\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Einsert\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E, k: K, v: V) -&gt; \u003Cspan class=\"hljs-built_in\"\u003EOption\u003C\u002Fspan\u003E&lt;V&gt;\n        Inserts a key-value pair into the map.\n\n    \u003Cspan class=\"hljs-keyword\"\u003Epub\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Ekeys\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E) -&gt; Keys&lt;K, V&gt;[src]\n        An iterator visiting all keys \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E arbitrary order. The iterator element \u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Etype\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eis\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E &amp;\u003Cspan class=\"hljs-symbol\"\u003E&#x27;a\u003C\u002Fspan\u003E K.\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EAs a straight application of \u003Ccode\u003Einsert\u003C\u002Fcode\u003E, the following code seems to work well.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F collect keys of a HashMap into a Vec\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E h: HashMap&lt;K, V&gt;;\n\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E v: \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;_&gt; = h.keys().collect();\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EBut in some case this is troublesome. For example,\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F key is String\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E h: HashMap&lt;\u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E, V&gt;;\n\u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E h.keys().collect::&lt;\u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;\u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E&gt;&gt;();\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eis a type mismatch because the return type of \u003Ccode\u003Ekeys\u003C\u002Fcode\u003E is the reference to key:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003Eerror[E0277]: a collection of type `std::vec::Vec&lt;std::string::String&gt;` cannot be built from an iterator over elements of type `&amp;std::string::String`\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003ETo fix it, make \u003Ccode\u003Ehash\u003C\u002Fcode\u003E hold \u003Ccode\u003E&amp;String\u003C\u002Fcode\u003E as \u003Cem\u003Ekey\u003C\u002Fem\u003E:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F change the key&#x27;s type\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E h: HashMap&lt;&amp;\u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E, V&gt;;\n\u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E h.keys().collect::&lt;\u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;&amp;\u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E&gt;&gt;();\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003Eit emits another error in this case:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003Eerror[E0515]: cannot return value referencing local variable `h`\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EHow about dereferencing and \u003Cem\u003Einjecting\u003C\u002Fem\u003E them to the return value?\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F &amp;String to String\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E h: HashMap&lt;&amp;\u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E, V&gt;;\n\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E v: \u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;\u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E&gt; = h.keys().map(|k| *k).collect();\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EIt can't work (we can't destruct data in order to make a return value):\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003Eerror[E0507]: cannot move out of borrowed content\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003ESo we need to copy them explicitly, if \u003Ccode\u003EK\u003C\u002Fcode\u003E doesn't have \u003Ccode\u003ECopy\u003C\u002Fcode\u003E trait.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E hash: HashMap&lt;\u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E, V&gt;;\n\u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E hash.keys().map(|k| k.to_string()).collect::&lt;\u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;\u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E&gt;&gt;();\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EBut this code may contain unwanted memory copy. So make \u003Ccode\u003Ehash\u003C\u002Fcode\u003E hold the reference.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F `hash` points the original data to avoid double allocation\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E hash: HashMap&lt;&amp;\u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E, V&gt;;\n\u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E hash.keys().map(|k| k.to_string()).collect::&lt;\u003Cspan class=\"hljs-built_in\"\u003EVec\u003C\u002Fspan\u003E&lt;\u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E&gt;&gt;();\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003EThat's it.\u003C\u002Fp\u003E\n"},dir:{writable:true,enumerable:true,value:"article\u002F.json\u002F2019"},base:{writable:true,enumerable:true,value:"2019-02-20-hashmap-to-vec.json"},ext:{writable:true,enumerable:true,value:".json"},sourceBase:{writable:true,enumerable:true,value:"2019-02-20-hashmap-to-vec.md"},sourceExt:{writable:true,enumerable:true,value:".md"}})}],fetch:[],mutations:[]});