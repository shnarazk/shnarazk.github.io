__NUXT_JSONP__("/2018/2018-02-03-Evil-keybindings", {data:[{article:Object.create(null,{default:{writable:true,enumerable:true,value:{title:"Evil (and vim) cheat sheet",date:"2019-08-18T00:00:00.000Z",tags:["Emacs","evil","Vim"],bodyContent:"## Basic :: object \u002F mark \u002F register\n\n#### object\n\n```plaintext\nb      - a block by ()\nt      - tag\nw      - a small word\nW      - a big word\n$      - math mode in latex\ni{o}   - inner text object {o}\na{o}   - around text object {o}\ns{o}   - [Surround] surround object {o} in normal mode\nS{o}   - [Surround] surround object {o} in visual mode\n```\n\n#### mark (location)\n\n```plaintext\n.      - last changed position (jump there by ` or ')\n^      - last insert position\n-      - latest small delete, which is a delete smaller than 1 line\n[      - beginning of previously changed or yanked text\n]      - end of previously changed or yanked text\n\u003C      - beginning of last visual selection\n\u003E      - end of last visual selection\n```\n\n#### register\n\n```plaintext\n0 to 9 - latest to 10th yanked text\n\"      - latest deleted or yanked text\n.      - latest inserted text\n+      - clipboard\n:      - latest executed command (f.e. @:)\n%      - current file path\n#      - alternate file path\n=      - expression register, taking an elisp expression\n:reg   - list up the contents\n```\n\n---\n\n## Normal Mode :: motion \u002F operator\n\n#### motion\n\n```plaintext\nh \t- move left\nj \t- move down\nk \t- move up\nl\t- move right\nw \t- jump by start of words (punctuation considered words)\nW \t- jump by words (spaces separate words)\nb \t- jump backward by words (punctuation considered words)\nB \t- jump backward by words (no punctuation)\ne \t- jump to end of words (punctuation considered words)\nE \t- jump to end of words (no punctuation)\nge \t- jump backward to end of words (punctuation considered words)\ngE \t- jump backward to end of words (no punctuation)\nf{c} \t- jump forward to the character {c}\nF{c} \t- jump backward to the character {c}\nt{c} \t- jump forward by the character {c}\nT{c} \t- jump backward by the character {c}\n; \t- repeat the last {fFtT}\n, \t- repeat the last {fFtT} in reverse direction\n0 \t- (zero) start of line\n^ \t- first non-blank character of line\n$ \t- end of line\ngg \t- go to first line\n[N]G \t- go to line N. No N: last line\n`{m} \t- jump to the marked position {m}\n'{m} \t- jump to the marked line {m}\n```\n\n#### register operator\n\n```plaintext\n[\"{r}]d \t- delete target [to register {r}]\n[\"{r}]y \t- yank target [to register]\n[\"{r}]P \t- put (paste) the clipboard after cursor\u002Fcurrent line [from register]\n[\"{r}]p \t- put (paste) before cursor\u002Fcurrent line [from register]\n```\n\n---\n\n## Normal Mode Command :: search \u002F edit \u002F movement\n\n#### search\n\n```plaintext\n\u002Fpattern \t- search for pattern\n?pattern \t- search backward for pattern\nn \t\t- repeat search in same direction\nN \t\t- repeat search in opposite direction\n* \t\t- search the word on cursor\n:%s\u002Fold\u002Fnew\u002Fg \t- replace all old with new throughout file\n:%s\u002Fold\u002Fnew\u002Fgc \t- replace all old with new throughout file with confirmations\n```\n\n#### edit\n\n```plaintext\ni \t- start insert mode at cursor\nI \t- insert at the beginning of the line\na \t- append after the cursor\nA \t- append at the end of the line\no \t- open (append) blank line below current line (no need to press return)\nO \t- open blank line above current line\n. \t- repeat last command\nu \t- undo\nCtrl-r \t- redo\nx \t- delete current character\nX \t- delete previous character\ns \t- delete character at cursor and substitute text\nr \t- replace a single character (does not use insert mode)\nJ \t- join line below to the current one\n~ \t- switch case\n\u003E\u003E \t- indent line one column to right\n\u003C\u003C \t- indent line one column to left\n== \t- auto-indent current line\nq{m} \t- start recording a macro into {m}\nq \t- end macro recording\n@{m} \t- execute macro {m}\n```\n\n#### movement\n\n```plaintext\nm{m} \t- mark the current position to {m} (jump there by ` or ')\nCtrl-b \t- page up\nCtrl-f \t- page down\n% \t- jump to matching brace\nz. \t- recenter\nzz \t- jump to center of screen\nzt \t- jump to the top of screen\nzb \t- jump to the bottom of screen\n```\n\n---\n\n## Visual Mode :: mark \u002F commands\n\n#### mark\n\n```plaintext\nv \t- start visual mode, mark lines, then do command (such as y-yank)\nV \t- start Linewise visual mode\nCtrl-v \t- start visual block mode\no \t- move to other end of marked area\nO \t- move to Other corner of block\n```\n\n#### commands\n\n```plaintext\n\u003E \t- shift right\n\u003C \t- shift left\nc \t- change (replace) marked text\ny \t- yank (copy) marked text\nd \t- delete (cut) marked text\n~ \t- switch case\nU \t- upper case of marked area\nv\t- exit visual mode\nS \t- [Surround] insert surrounding\n```\n\n---\n\n## Insert Mode\n\n```plaintext\nEsc \t\t- exit insert mode\n\\ \t\t- execute an command\nCtrl-r{r} \t- insert the content in register {r}\nCtrl-w \t\t- backward delete a word\nCtrl-y \t\t- copy a char in above line\nCtrl-e \t\t- copy a char in below line\n```\n\n---\n\n## Interface :: buffer \u002F windows \u002F tab \u002F exit\n\n#### buffer\n\n```plaintext\n:edit filename \t- Edit a file in a new buffer\n:new **\u002F* \t- Open new files\n:bnext\t\t- go to next buffer\n:bprev \t\t- go to previous buffer\n:bd   \t\t- delete a buffer (close a file)\n```\n\n#### window\n\n```plaintext\n:sp filename \t- Open a file in a new buffer and split window\nCtrl-w s \t- Split windows\nCtrl-w w \t- switch between windows\nCtrl-w q \t- Quit a window\nCtrl-w v \t- Split windows vertically\n```\n\n#### tab\n\n```plaintext\ngt\t\t- next tab\ngT\t\t- previous tab\n:tabr\t\t- first tab\n:tabl\t\t- last tab\n:tabe filename \t- Edit a file in a new tab (vim7)\n:tabm [n]\t- move current tab after tab n. no n: last. n=0: first.\n```\n\n#### exit\n\n```plaintext\n:w\t\t- write (save) the file, but don't exit\n:wq \t\t- write (save) and quit\n:x\t\t- same as :wq\n:q\t\t- quit (fails if anything has changed)\n:q!\t\t- quit and throw away changes\n:setlocal fileformat=dos|unix | fileencoding=utf-8\n:viusage \t- show a huge cheat sheet listing every command\n:help\n```\n\n---\n\n## Cliche\n\n```plaintext\ncs({    - [Surround] change surrounding parens to curly braces\nxp \t\t- transpose two letters (delete and paste, technically)\ng~iw \t\t- switch case of current word\nguiw \t\t- make current word uppercase\nguiw \t\t- make current word lowercase\nddp \t\t- swap current line with next\nddkp \t\t- swap current line with previous\n:set paste \t- avoid unexpected effects in pasting\nds(    \t\t- [Surround] delete the surrounding parens\n```",bodyHtml:"\u003Ch2\u003EBasic :: object \u002F mark \u002F register\u003C\u002Fh2\u003E\n\u003Ch4\u003Eobject\u003C\u002Fh4\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003Eb      - a block by ()\nt      - tag\nw      - a small word\nW      - a big word\n$      - math mode in latex\ni{o}   - inner text object {o}\na{o}   - around text object {o}\ns{o}   - [Surround] surround object {o} in normal mode\nS{o}   - [Surround] surround object {o} in visual mode\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch4\u003Emark (location)\u003C\u002Fh4\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E.      - last changed position (jump there by ` or &#x27;)\n^      - last insert position\n-      - latest small delete, which is a delete smaller than 1 line\n[      - beginning of previously changed or yanked text\n]      - end of previously changed or yanked text\n&lt;      - beginning of last visual selection\n&gt;      - end of last visual selection\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch4\u003Eregister\u003C\u002Fh4\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E0 to 9 - latest to 10th yanked text\n&quot;      - latest deleted or yanked text\n.      - latest inserted text\n+      - clipboard\n:      - latest executed command (f.e. @:)\n%      - current file path\n#      - alternate file path\n=      - expression register, taking an elisp expression\n:reg   - list up the contents\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Chr\u003E\n\u003Ch2\u003ENormal Mode :: motion \u002F operator\u003C\u002Fh2\u003E\n\u003Ch4\u003Emotion\u003C\u002Fh4\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003Eh \t- move left\nj \t- move down\nk \t- move up\nl\t- move right\nw \t- jump by start of words (punctuation considered words)\nW \t- jump by words (spaces separate words)\nb \t- jump backward by words (punctuation considered words)\nB \t- jump backward by words (no punctuation)\ne \t- jump to end of words (punctuation considered words)\nE \t- jump to end of words (no punctuation)\nge \t- jump backward to end of words (punctuation considered words)\ngE \t- jump backward to end of words (no punctuation)\nf{c} \t- jump forward to the character {c}\nF{c} \t- jump backward to the character {c}\nt{c} \t- jump forward by the character {c}\nT{c} \t- jump backward by the character {c}\n; \t- repeat the last {fFtT}\n, \t- repeat the last {fFtT} in reverse direction\n0 \t- (zero) start of line\n^ \t- first non-blank character of line\n$ \t- end of line\ngg \t- go to first line\n[N]G \t- go to line N. No N: last line\n`{m} \t- jump to the marked position {m}\n&#x27;{m} \t- jump to the marked line {m}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch4\u003Eregister operator\u003C\u002Fh4\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E[&quot;{r}]d \t- delete target [to register {r}]\n[&quot;{r}]y \t- yank target [to register]\n[&quot;{r}]P \t- put (paste) the clipboard after cursor\u002Fcurrent line [from register]\n[&quot;{r}]p \t- put (paste) before cursor\u002Fcurrent line [from register]\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Chr\u003E\n\u003Ch2\u003ENormal Mode Command :: search \u002F edit \u002F movement\u003C\u002Fh2\u003E\n\u003Ch4\u003Esearch\u003C\u002Fh4\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u002Fpattern \t- search for pattern\n?pattern \t- search backward for pattern\nn \t\t- repeat search in same direction\nN \t\t- repeat search in opposite direction\n* \t\t- search the word on cursor\n:%s\u002Fold\u002Fnew\u002Fg \t- replace all old with new throughout file\n:%s\u002Fold\u002Fnew\u002Fgc \t- replace all old with new throughout file with confirmations\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch4\u003Eedit\u003C\u002Fh4\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003Ei \t- start insert mode at cursor\nI \t- insert at the beginning of the line\na \t- append after the cursor\nA \t- append at the end of the line\no \t- open (append) blank line below current line (no need to press return)\nO \t- open blank line above current line\n. \t- repeat last command\nu \t- undo\nCtrl-r \t- redo\nx \t- delete current character\nX \t- delete previous character\ns \t- delete character at cursor and substitute text\nr \t- replace a single character (does not use insert mode)\nJ \t- join line below to the current one\n~ \t- switch case\n&gt;&gt; \t- indent line one column to right\n&lt;&lt; \t- indent line one column to left\n== \t- auto-indent current line\nq{m} \t- start recording a macro into {m}\nq \t- end macro recording\n@{m} \t- execute macro {m}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch4\u003Emovement\u003C\u002Fh4\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003Em{m} \t- mark the current position to {m} (jump there by ` or &#x27;)\nCtrl-b \t- page up\nCtrl-f \t- page down\n% \t- jump to matching brace\nz. \t- recenter\nzz \t- jump to center of screen\nzt \t- jump to the top of screen\nzb \t- jump to the bottom of screen\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Chr\u003E\n\u003Ch2\u003EVisual Mode :: mark \u002F commands\u003C\u002Fh2\u003E\n\u003Ch4\u003Emark\u003C\u002Fh4\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003Ev \t- start visual mode, mark lines, then do command (such as y-yank)\nV \t- start Linewise visual mode\nCtrl-v \t- start visual block mode\no \t- move to other end of marked area\nO \t- move to Other corner of block\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch4\u003Ecommands\u003C\u002Fh4\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E&gt; \t- shift right\n&lt; \t- shift left\nc \t- change (replace) marked text\ny \t- yank (copy) marked text\nd \t- delete (cut) marked text\n~ \t- switch case\nU \t- upper case of marked area\nv\t- exit visual mode\nS \t- [Surround] insert surrounding\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Chr\u003E\n\u003Ch2\u003EInsert Mode\u003C\u002Fh2\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003EEsc \t\t- exit insert mode\n\\ \t\t- execute an command\nCtrl-r{r} \t- insert the content in register {r}\nCtrl-w \t\t- backward delete a word\nCtrl-y \t\t- copy a char in above line\nCtrl-e \t\t- copy a char in below line\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Chr\u003E\n\u003Ch2\u003EInterface :: buffer \u002F windows \u002F tab \u002F exit\u003C\u002Fh2\u003E\n\u003Ch4\u003Ebuffer\u003C\u002Fh4\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E:edit filename \t- Edit a file in a new buffer\n:new **\u002F* \t- Open new files\n:bnext\t\t- go to next buffer\n:bprev \t\t- go to previous buffer\n:bd   \t\t- delete a buffer (close a file)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch4\u003Ewindow\u003C\u002Fh4\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E:sp filename \t- Open a file in a new buffer and split window\nCtrl-w s \t- Split windows\nCtrl-w w \t- switch between windows\nCtrl-w q \t- Quit a window\nCtrl-w v \t- Split windows vertically\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch4\u003Etab\u003C\u002Fh4\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003Egt\t\t- next tab\ngT\t\t- previous tab\n:tabr\t\t- first tab\n:tabl\t\t- last tab\n:tabe filename \t- Edit a file in a new tab (vim7)\n:tabm [n]\t- move current tab after tab n. no n: last. n=0: first.\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch4\u003Eexit\u003C\u002Fh4\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E:w\t\t- write (save) the file, but don&#x27;t exit\n:wq \t\t- write (save) and quit\n:x\t\t- same as :wq\n:q\t\t- quit (fails if anything has changed)\n:q!\t\t- quit and throw away changes\n:setlocal fileformat=dos|unix | fileencoding=utf-8\n:viusage \t- show a huge cheat sheet listing every command\n:help\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Chr\u003E\n\u003Ch2\u003ECliche\u003C\u002Fh2\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003Ecs({    - [Surround] change surrounding parens to curly braces\nxp \t\t- transpose two letters (delete and paste, technically)\ng~iw \t\t- switch case of current word\nguiw \t\t- make current word uppercase\nguiw \t\t- make current word lowercase\nddp \t\t- swap current line with next\nddkp \t\t- swap current line with previous\n:set paste \t- avoid unexpected effects in pasting\nds(    \t\t- [Surround] delete the surrounding parens\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E",dir:"article\u002F.json\u002F2018",base:"2018-02-03-Evil-keybindings.json",ext:".json",sourceBase:"2018-02-03-Evil-keybindings.md",sourceExt:".md"}},title:{writable:true,enumerable:true,value:"Evil (and vim) cheat sheet"},date:{writable:true,enumerable:true,value:"2019-08-18T00:00:00.000Z"},tags:{writable:true,enumerable:true,value:["Emacs","evil","Vim"]},bodyContent:{writable:true,enumerable:true,value:"## Basic :: object \u002F mark \u002F register\n\n#### object\n\n```plaintext\nb      - a block by ()\nt      - tag\nw      - a small word\nW      - a big word\n$      - math mode in latex\ni{o}   - inner text object {o}\na{o}   - around text object {o}\ns{o}   - [Surround] surround object {o} in normal mode\nS{o}   - [Surround] surround object {o} in visual mode\n```\n\n#### mark (location)\n\n```plaintext\n.      - last changed position (jump there by ` or ')\n^      - last insert position\n-      - latest small delete, which is a delete smaller than 1 line\n[      - beginning of previously changed or yanked text\n]      - end of previously changed or yanked text\n\u003C      - beginning of last visual selection\n\u003E      - end of last visual selection\n```\n\n#### register\n\n```plaintext\n0 to 9 - latest to 10th yanked text\n\"      - latest deleted or yanked text\n.      - latest inserted text\n+      - clipboard\n:      - latest executed command (f.e. @:)\n%      - current file path\n#      - alternate file path\n=      - expression register, taking an elisp expression\n:reg   - list up the contents\n```\n\n---\n\n## Normal Mode :: motion \u002F operator\n\n#### motion\n\n```plaintext\nh \t- move left\nj \t- move down\nk \t- move up\nl\t- move right\nw \t- jump by start of words (punctuation considered words)\nW \t- jump by words (spaces separate words)\nb \t- jump backward by words (punctuation considered words)\nB \t- jump backward by words (no punctuation)\ne \t- jump to end of words (punctuation considered words)\nE \t- jump to end of words (no punctuation)\nge \t- jump backward to end of words (punctuation considered words)\ngE \t- jump backward to end of words (no punctuation)\nf{c} \t- jump forward to the character {c}\nF{c} \t- jump backward to the character {c}\nt{c} \t- jump forward by the character {c}\nT{c} \t- jump backward by the character {c}\n; \t- repeat the last {fFtT}\n, \t- repeat the last {fFtT} in reverse direction\n0 \t- (zero) start of line\n^ \t- first non-blank character of line\n$ \t- end of line\ngg \t- go to first line\n[N]G \t- go to line N. No N: last line\n`{m} \t- jump to the marked position {m}\n'{m} \t- jump to the marked line {m}\n```\n\n#### register operator\n\n```plaintext\n[\"{r}]d \t- delete target [to register {r}]\n[\"{r}]y \t- yank target [to register]\n[\"{r}]P \t- put (paste) the clipboard after cursor\u002Fcurrent line [from register]\n[\"{r}]p \t- put (paste) before cursor\u002Fcurrent line [from register]\n```\n\n---\n\n## Normal Mode Command :: search \u002F edit \u002F movement\n\n#### search\n\n```plaintext\n\u002Fpattern \t- search for pattern\n?pattern \t- search backward for pattern\nn \t\t- repeat search in same direction\nN \t\t- repeat search in opposite direction\n* \t\t- search the word on cursor\n:%s\u002Fold\u002Fnew\u002Fg \t- replace all old with new throughout file\n:%s\u002Fold\u002Fnew\u002Fgc \t- replace all old with new throughout file with confirmations\n```\n\n#### edit\n\n```plaintext\ni \t- start insert mode at cursor\nI \t- insert at the beginning of the line\na \t- append after the cursor\nA \t- append at the end of the line\no \t- open (append) blank line below current line (no need to press return)\nO \t- open blank line above current line\n. \t- repeat last command\nu \t- undo\nCtrl-r \t- redo\nx \t- delete current character\nX \t- delete previous character\ns \t- delete character at cursor and substitute text\nr \t- replace a single character (does not use insert mode)\nJ \t- join line below to the current one\n~ \t- switch case\n\u003E\u003E \t- indent line one column to right\n\u003C\u003C \t- indent line one column to left\n== \t- auto-indent current line\nq{m} \t- start recording a macro into {m}\nq \t- end macro recording\n@{m} \t- execute macro {m}\n```\n\n#### movement\n\n```plaintext\nm{m} \t- mark the current position to {m} (jump there by ` or ')\nCtrl-b \t- page up\nCtrl-f \t- page down\n% \t- jump to matching brace\nz. \t- recenter\nzz \t- jump to center of screen\nzt \t- jump to the top of screen\nzb \t- jump to the bottom of screen\n```\n\n---\n\n## Visual Mode :: mark \u002F commands\n\n#### mark\n\n```plaintext\nv \t- start visual mode, mark lines, then do command (such as y-yank)\nV \t- start Linewise visual mode\nCtrl-v \t- start visual block mode\no \t- move to other end of marked area\nO \t- move to Other corner of block\n```\n\n#### commands\n\n```plaintext\n\u003E \t- shift right\n\u003C \t- shift left\nc \t- change (replace) marked text\ny \t- yank (copy) marked text\nd \t- delete (cut) marked text\n~ \t- switch case\nU \t- upper case of marked area\nv\t- exit visual mode\nS \t- [Surround] insert surrounding\n```\n\n---\n\n## Insert Mode\n\n```plaintext\nEsc \t\t- exit insert mode\n\\ \t\t- execute an command\nCtrl-r{r} \t- insert the content in register {r}\nCtrl-w \t\t- backward delete a word\nCtrl-y \t\t- copy a char in above line\nCtrl-e \t\t- copy a char in below line\n```\n\n---\n\n## Interface :: buffer \u002F windows \u002F tab \u002F exit\n\n#### buffer\n\n```plaintext\n:edit filename \t- Edit a file in a new buffer\n:new **\u002F* \t- Open new files\n:bnext\t\t- go to next buffer\n:bprev \t\t- go to previous buffer\n:bd   \t\t- delete a buffer (close a file)\n```\n\n#### window\n\n```plaintext\n:sp filename \t- Open a file in a new buffer and split window\nCtrl-w s \t- Split windows\nCtrl-w w \t- switch between windows\nCtrl-w q \t- Quit a window\nCtrl-w v \t- Split windows vertically\n```\n\n#### tab\n\n```plaintext\ngt\t\t- next tab\ngT\t\t- previous tab\n:tabr\t\t- first tab\n:tabl\t\t- last tab\n:tabe filename \t- Edit a file in a new tab (vim7)\n:tabm [n]\t- move current tab after tab n. no n: last. n=0: first.\n```\n\n#### exit\n\n```plaintext\n:w\t\t- write (save) the file, but don't exit\n:wq \t\t- write (save) and quit\n:x\t\t- same as :wq\n:q\t\t- quit (fails if anything has changed)\n:q!\t\t- quit and throw away changes\n:setlocal fileformat=dos|unix | fileencoding=utf-8\n:viusage \t- show a huge cheat sheet listing every command\n:help\n```\n\n---\n\n## Cliche\n\n```plaintext\ncs({    - [Surround] change surrounding parens to curly braces\nxp \t\t- transpose two letters (delete and paste, technically)\ng~iw \t\t- switch case of current word\nguiw \t\t- make current word uppercase\nguiw \t\t- make current word lowercase\nddp \t\t- swap current line with next\nddkp \t\t- swap current line with previous\n:set paste \t- avoid unexpected effects in pasting\nds(    \t\t- [Surround] delete the surrounding parens\n```"},bodyHtml:{writable:true,enumerable:true,value:"\u003Ch2\u003EBasic :: object \u002F mark \u002F register\u003C\u002Fh2\u003E\n\u003Ch4\u003Eobject\u003C\u002Fh4\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003Eb      - a block by ()\nt      - tag\nw      - a small word\nW      - a big word\n$      - math mode in latex\ni{o}   - inner text object {o}\na{o}   - around text object {o}\ns{o}   - [Surround] surround object {o} in normal mode\nS{o}   - [Surround] surround object {o} in visual mode\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch4\u003Emark (location)\u003C\u002Fh4\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E.      - last changed position (jump there by ` or &#x27;)\n^      - last insert position\n-      - latest small delete, which is a delete smaller than 1 line\n[      - beginning of previously changed or yanked text\n]      - end of previously changed or yanked text\n&lt;      - beginning of last visual selection\n&gt;      - end of last visual selection\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch4\u003Eregister\u003C\u002Fh4\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E0 to 9 - latest to 10th yanked text\n&quot;      - latest deleted or yanked text\n.      - latest inserted text\n+      - clipboard\n:      - latest executed command (f.e. @:)\n%      - current file path\n#      - alternate file path\n=      - expression register, taking an elisp expression\n:reg   - list up the contents\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Chr\u003E\n\u003Ch2\u003ENormal Mode :: motion \u002F operator\u003C\u002Fh2\u003E\n\u003Ch4\u003Emotion\u003C\u002Fh4\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003Eh \t- move left\nj \t- move down\nk \t- move up\nl\t- move right\nw \t- jump by start of words (punctuation considered words)\nW \t- jump by words (spaces separate words)\nb \t- jump backward by words (punctuation considered words)\nB \t- jump backward by words (no punctuation)\ne \t- jump to end of words (punctuation considered words)\nE \t- jump to end of words (no punctuation)\nge \t- jump backward to end of words (punctuation considered words)\ngE \t- jump backward to end of words (no punctuation)\nf{c} \t- jump forward to the character {c}\nF{c} \t- jump backward to the character {c}\nt{c} \t- jump forward by the character {c}\nT{c} \t- jump backward by the character {c}\n; \t- repeat the last {fFtT}\n, \t- repeat the last {fFtT} in reverse direction\n0 \t- (zero) start of line\n^ \t- first non-blank character of line\n$ \t- end of line\ngg \t- go to first line\n[N]G \t- go to line N. No N: last line\n`{m} \t- jump to the marked position {m}\n&#x27;{m} \t- jump to the marked line {m}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch4\u003Eregister operator\u003C\u002Fh4\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E[&quot;{r}]d \t- delete target [to register {r}]\n[&quot;{r}]y \t- yank target [to register]\n[&quot;{r}]P \t- put (paste) the clipboard after cursor\u002Fcurrent line [from register]\n[&quot;{r}]p \t- put (paste) before cursor\u002Fcurrent line [from register]\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Chr\u003E\n\u003Ch2\u003ENormal Mode Command :: search \u002F edit \u002F movement\u003C\u002Fh2\u003E\n\u003Ch4\u003Esearch\u003C\u002Fh4\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E\u002Fpattern \t- search for pattern\n?pattern \t- search backward for pattern\nn \t\t- repeat search in same direction\nN \t\t- repeat search in opposite direction\n* \t\t- search the word on cursor\n:%s\u002Fold\u002Fnew\u002Fg \t- replace all old with new throughout file\n:%s\u002Fold\u002Fnew\u002Fgc \t- replace all old with new throughout file with confirmations\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch4\u003Eedit\u003C\u002Fh4\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003Ei \t- start insert mode at cursor\nI \t- insert at the beginning of the line\na \t- append after the cursor\nA \t- append at the end of the line\no \t- open (append) blank line below current line (no need to press return)\nO \t- open blank line above current line\n. \t- repeat last command\nu \t- undo\nCtrl-r \t- redo\nx \t- delete current character\nX \t- delete previous character\ns \t- delete character at cursor and substitute text\nr \t- replace a single character (does not use insert mode)\nJ \t- join line below to the current one\n~ \t- switch case\n&gt;&gt; \t- indent line one column to right\n&lt;&lt; \t- indent line one column to left\n== \t- auto-indent current line\nq{m} \t- start recording a macro into {m}\nq \t- end macro recording\n@{m} \t- execute macro {m}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch4\u003Emovement\u003C\u002Fh4\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003Em{m} \t- mark the current position to {m} (jump there by ` or &#x27;)\nCtrl-b \t- page up\nCtrl-f \t- page down\n% \t- jump to matching brace\nz. \t- recenter\nzz \t- jump to center of screen\nzt \t- jump to the top of screen\nzb \t- jump to the bottom of screen\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Chr\u003E\n\u003Ch2\u003EVisual Mode :: mark \u002F commands\u003C\u002Fh2\u003E\n\u003Ch4\u003Emark\u003C\u002Fh4\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003Ev \t- start visual mode, mark lines, then do command (such as y-yank)\nV \t- start Linewise visual mode\nCtrl-v \t- start visual block mode\no \t- move to other end of marked area\nO \t- move to Other corner of block\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch4\u003Ecommands\u003C\u002Fh4\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E&gt; \t- shift right\n&lt; \t- shift left\nc \t- change (replace) marked text\ny \t- yank (copy) marked text\nd \t- delete (cut) marked text\n~ \t- switch case\nU \t- upper case of marked area\nv\t- exit visual mode\nS \t- [Surround] insert surrounding\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Chr\u003E\n\u003Ch2\u003EInsert Mode\u003C\u002Fh2\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003EEsc \t\t- exit insert mode\n\\ \t\t- execute an command\nCtrl-r{r} \t- insert the content in register {r}\nCtrl-w \t\t- backward delete a word\nCtrl-y \t\t- copy a char in above line\nCtrl-e \t\t- copy a char in below line\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Chr\u003E\n\u003Ch2\u003EInterface :: buffer \u002F windows \u002F tab \u002F exit\u003C\u002Fh2\u003E\n\u003Ch4\u003Ebuffer\u003C\u002Fh4\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E:edit filename \t- Edit a file in a new buffer\n:new **\u002F* \t- Open new files\n:bnext\t\t- go to next buffer\n:bprev \t\t- go to previous buffer\n:bd   \t\t- delete a buffer (close a file)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch4\u003Ewindow\u003C\u002Fh4\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E:sp filename \t- Open a file in a new buffer and split window\nCtrl-w s \t- Split windows\nCtrl-w w \t- switch between windows\nCtrl-w q \t- Quit a window\nCtrl-w v \t- Split windows vertically\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch4\u003Etab\u003C\u002Fh4\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003Egt\t\t- next tab\ngT\t\t- previous tab\n:tabr\t\t- first tab\n:tabl\t\t- last tab\n:tabe filename \t- Edit a file in a new tab (vim7)\n:tabm [n]\t- move current tab after tab n. no n: last. n=0: first.\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Ch4\u003Eexit\u003C\u002Fh4\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003E:w\t\t- write (save) the file, but don&#x27;t exit\n:wq \t\t- write (save) and quit\n:x\t\t- same as :wq\n:q\t\t- quit (fails if anything has changed)\n:q!\t\t- quit and throw away changes\n:setlocal fileformat=dos|unix | fileencoding=utf-8\n:viusage \t- show a huge cheat sheet listing every command\n:help\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Chr\u003E\n\u003Ch2\u003ECliche\u003C\u002Fh2\u003E\n\u003Cpre\u003E\u003Ccode class=\"hljs\"\u003Ecs({    - [Surround] change surrounding parens to curly braces\nxp \t\t- transpose two letters (delete and paste, technically)\ng~iw \t\t- switch case of current word\nguiw \t\t- make current word uppercase\nguiw \t\t- make current word lowercase\nddp \t\t- swap current line with next\nddkp \t\t- swap current line with previous\n:set paste \t- avoid unexpected effects in pasting\nds(    \t\t- [Surround] delete the surrounding parens\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E"},dir:{writable:true,enumerable:true,value:"article\u002F.json\u002F2018"},base:{writable:true,enumerable:true,value:"2018-02-03-Evil-keybindings.json"},ext:{writable:true,enumerable:true,value:".json"},sourceBase:{writable:true,enumerable:true,value:"2018-02-03-Evil-keybindings.md"},sourceExt:{writable:true,enumerable:true,value:".md"}})}],fetch:[],mutations:[]});