(window.webpackJsonp=window.webpackJsonp||[]).push([[79],{558:function(n){n.exports=JSON.parse('{"title":"What\'s Miracle Sudoku?","subtitle":"for a SAT solver developer","date":"2020-06-01T00:00:00.000Z","tags":["SAT","splr","sudoku"],"banner":"https://images.unsplash.com/photo-1511689774932-3aca18459e68?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1234&q=80","bodyContent":"25日のHacker Newsで初めて知ったMiracle Sudoku。[ビデオ](https://www.youtube.com/watch?v=cvEq_XkQg8U)の横に書いてあることから判断するに\\n\\n* Normal Sudoku rules apply.\\n* ナイトまたはキングが1hopで行ける場所には同じ数は置けない: Any two cells separated by a knight\'s move or a king\'s move (in chess) cannot contain the same digit.\\n* 近接した4近傍には連続する数列は置けない: Any two orthogonally adjacent cells cannot contain consecutive digits.\\n\\nさあSATソルバの出番。\\n\\n# 2020-05-30 mokumoku\\n\\n場所とセルの状態をそれぞれ構造体`Pos`, `Cell`で表現すると\\n\\n* `fn state(Pos, digit: usize, bool) -> Cell`　で状態を生成\\n* `fn requires(Cell, Cell) -> [i32; 2]` で制約節を生成\\n* `fn valid(Pos) -> Option<Pos>` で妥当なセル座標に限定\\n\\nといった補助関数を用意すれば後は簡単。\\n\\n## ナイトまたはキングが1hopで行ける場所には同じ数は置けない\\n\\nまず、移動可能なベクターを用意。\\n\\n\\n```rust\\n    let knights_moves = [\\n        Pos::at(-2, 1),\\n        Pos::at(-1, 2),\\n        Pos::at(1, 2),\\n        Pos::at(2, 1),\\n        Pos::at(2, -1),\\n        Pos::at(1, -2),\\n        Pos::at(-1, -2),\\n        Pos::at(-2, -1),\\n    ];\\n```\\n\\n全ての位置で移動して、妥当な場所なら全ての数字に対して禁止ルールを追加。\\n\\n```rust\\n    let mut rules = Vec::new();\\n    for i in 1..=RANGE {\\n        for j in 1..=RANGE {\\n            let p = Pos::at(i, j);\\n            for m in moves.iter() {\\n                if let Some(t) = (p + *m).valid() {\\n                    for d in 1..=RANGE as usize {\\n                        rules.push(p.state(d, true).requires(t.state(d, false)));\\n                    }\\n                }\\n            }\\n        }\\n    }\\n```\\n\\nキングについても同様。\\n\\n## 近接した4近傍には連続する数列は置けない\\n\\nほぼ同じ考えでいける。連続した数列なのでそこだけ変更。\\n\\n```rust\\n    let dirs = [\\n        Pos::at(-1, 0), // North\\n        Pos::at(0, 1),  // East\\n        Pos::at(1, 0),  // South\\n        Pos::at(0, -1), // West\\n    ];\\n    let mut rules = Vec::new();\\n    for i in 1..=RANGE {\\n        for j in 1..=RANGE {\\n            let p = Pos::at(i, j);\\n            for m in dirs.iter() {\\n                if let Some(t) = (p + *m).valid() {\\n                    for d in 1..RANGE as usize {\\n                        rules.push(p.state(d, true).requires(t.state(d + 1, false)));\\n                    }\\n                }\\n            }\\n        }\\n    }\\n```\\n\\n## SATソルバを呼び出す\\n\\n`rules`が`Vec<Vec<i32>>`の形なので、後はSplrを呼び出すだけ。\\n\\n```rust\\n    let rules: Vec<Vec<i32> = make_rules();\\n    let mut solver = Solver::try_from((Config::default(), rules.as_ref())).expect(\\"panic\\");\\n    // 初期状態\\n    solver.add_assignment(Pos::at(5, 3).state(1, true).as_lit()).expect(\\"panic\\");\\n    solver.add_assignment(Pos::at(6, 7).state(2, true).as_lit()).expect(\\"panic\\");\\n    for ans in solver.iter() {\\n        // 正リテラルだけ抽出\\n        let picked = ans.iter().filter(|l| 0 < **l).collect::<Vec<&i32>>();\\n        println!(-);\\n    }\\n```\\n\\nできたプログラムは[こちら](https://github.com/shnarazk/miracle_sudoku)。\\n\\n\\n座標やリテラルは1で始まる一方で、`Vec` は0で始まるといったあたりでいつものようにバグを発生させてしまった\\nけど、200行程度でできました。\\n\\n## 実行結果\\n\\n得られる出力は以下の通り。\\n\\n```text\\n4 8 3 7 2 6 1 5 9 \\n7 2 6 1 5 9 4 8 3 \\n1 5 9 4 8 3 7 2 6 \\n8 3 7 2 6 1 5 9 4 \\n2 6 1 5 9 4 8 3 7 \\n5 9 4 8 3 7 2 6 1 \\n3 7 2 6 1 5 9 4 8 \\n6 1 5 9 4 8 3 7 2 \\n9 4 8 3 7 2 6 1 5 \\n```\\n\\nとなって、ビデオの解が唯一解であることも判明しました。","bodyHtml":"<p>25日のHacker Newsで初めて知ったMiracle Sudoku。<a href=\\"https://www.youtube.com/watch?v=cvEq_XkQg8U\\">ビデオ</a>の横に書いてあることから判断するに</p>\\n<ul>\\n<li>Normal Sudoku rules apply.</li>\\n<li>ナイトまたはキングが1hopで行ける場所には同じ数は置けない: Any two cells separated by a knight\'s move or a king\'s move (in chess) cannot contain the same digit.</li>\\n<li>近接した4近傍には連続する数列は置けない: Any two orthogonally adjacent cells cannot contain consecutive digits.</li>\\n</ul>\\n<p>さあSATソルバの出番。</p>\\n<h1>2020-05-30 mokumoku</h1>\\n<p>場所とセルの状態をそれぞれ構造体<code>Pos</code>, <code>Cell</code>で表現すると</p>\\n<ul>\\n<li><code>fn state(Pos, digit: usize, bool) -&gt; Cell</code>　で状態を生成</li>\\n<li><code>fn requires(Cell, Cell) -&gt; [i32; 2]</code> で制約節を生成</li>\\n<li><code>fn valid(Pos) -&gt; Option&lt;Pos&gt;</code> で妥当なセル座標に限定</li>\\n</ul>\\n<p>といった補助関数を用意すれば後は簡単。</p>\\n<h2>ナイトまたはキングが1hopで行ける場所には同じ数は置けない</h2>\\n<p>まず、移動可能なベクターを用意。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-keyword\\">let</span> knights_moves = [\\n        Pos::at(-<span class=\\"hljs-number\\">2</span>, <span class=\\"hljs-number\\">1</span>),\\n        Pos::at(-<span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-number\\">2</span>),\\n        Pos::at(<span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-number\\">2</span>),\\n        Pos::at(<span class=\\"hljs-number\\">2</span>, <span class=\\"hljs-number\\">1</span>),\\n        Pos::at(<span class=\\"hljs-number\\">2</span>, -<span class=\\"hljs-number\\">1</span>),\\n        Pos::at(<span class=\\"hljs-number\\">1</span>, -<span class=\\"hljs-number\\">2</span>),\\n        Pos::at(-<span class=\\"hljs-number\\">1</span>, -<span class=\\"hljs-number\\">2</span>),\\n        Pos::at(-<span class=\\"hljs-number\\">2</span>, -<span class=\\"hljs-number\\">1</span>),\\n    ];</code></pre><p>全ての位置で移動して、妥当な場所なら全ての数字に対して禁止ルールを追加。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-keyword\\">let</span> <span class=\\"hljs-keyword\\">mut</span> rules = <span class=\\"hljs-built_in\\">Vec</span>::new();\\n    <span class=\\"hljs-keyword\\">for</span> i <span class=\\"hljs-keyword\\">in</span> <span class=\\"hljs-number\\">1</span>..=RANGE {\\n        <span class=\\"hljs-keyword\\">for</span> j <span class=\\"hljs-keyword\\">in</span> <span class=\\"hljs-number\\">1</span>..=RANGE {\\n            <span class=\\"hljs-keyword\\">let</span> p = Pos::at(i, j);\\n            <span class=\\"hljs-keyword\\">for</span> m <span class=\\"hljs-keyword\\">in</span> moves.iter() {\\n                <span class=\\"hljs-keyword\\">if</span> <span class=\\"hljs-keyword\\">let</span> <span class=\\"hljs-literal\\">Some</span>(t) = (p + *m).valid() {\\n                    <span class=\\"hljs-keyword\\">for</span> d <span class=\\"hljs-keyword\\">in</span> <span class=\\"hljs-number\\">1</span>..=RANGE <span class=\\"hljs-keyword\\">as</span> <span class=\\"hljs-built_in\\">usize</span> {\\n                        rules.push(p.state(d, <span class=\\"hljs-literal\\">true</span>).requires(t.state(d, <span class=\\"hljs-literal\\">false</span>)));\\n                    }\\n                }\\n            }\\n        }\\n    }</code></pre><p>キングについても同様。</p>\\n<h2>近接した4近傍には連続する数列は置けない</h2>\\n<p>ほぼ同じ考えでいける。連続した数列なのでそこだけ変更。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-keyword\\">let</span> dirs = [\\n        Pos::at(-<span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-number\\">0</span>), <span class=\\"hljs-comment\\">// North</span>\\n        Pos::at(<span class=\\"hljs-number\\">0</span>, <span class=\\"hljs-number\\">1</span>),  <span class=\\"hljs-comment\\">// East</span>\\n        Pos::at(<span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-number\\">0</span>),  <span class=\\"hljs-comment\\">// South</span>\\n        Pos::at(<span class=\\"hljs-number\\">0</span>, -<span class=\\"hljs-number\\">1</span>), <span class=\\"hljs-comment\\">// West</span>\\n    ];\\n    <span class=\\"hljs-keyword\\">let</span> <span class=\\"hljs-keyword\\">mut</span> rules = <span class=\\"hljs-built_in\\">Vec</span>::new();\\n    <span class=\\"hljs-keyword\\">for</span> i <span class=\\"hljs-keyword\\">in</span> <span class=\\"hljs-number\\">1</span>..=RANGE {\\n        <span class=\\"hljs-keyword\\">for</span> j <span class=\\"hljs-keyword\\">in</span> <span class=\\"hljs-number\\">1</span>..=RANGE {\\n            <span class=\\"hljs-keyword\\">let</span> p = Pos::at(i, j);\\n            <span class=\\"hljs-keyword\\">for</span> m <span class=\\"hljs-keyword\\">in</span> dirs.iter() {\\n                <span class=\\"hljs-keyword\\">if</span> <span class=\\"hljs-keyword\\">let</span> <span class=\\"hljs-literal\\">Some</span>(t) = (p + *m).valid() {\\n                    <span class=\\"hljs-keyword\\">for</span> d <span class=\\"hljs-keyword\\">in</span> <span class=\\"hljs-number\\">1</span>..RANGE <span class=\\"hljs-keyword\\">as</span> <span class=\\"hljs-built_in\\">usize</span> {\\n                        rules.push(p.state(d, <span class=\\"hljs-literal\\">true</span>).requires(t.state(d + <span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-literal\\">false</span>)));\\n                    }\\n                }\\n            }\\n        }\\n    }</code></pre><h2>SATソルバを呼び出す</h2>\\n<p><code>rules</code>が<code>Vec&lt;Vec&lt;i32&gt;&gt;</code>の形なので、後はSplrを呼び出すだけ。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-keyword\\">let</span> rules: <span class=\\"hljs-built_in\\">Vec</span>&lt;<span class=\\"hljs-built_in\\">Vec</span>&lt;<span class=\\"hljs-built_in\\">i32</span>&gt; = make_rules();\\n    <span class=\\"hljs-keyword\\">let</span> <span class=\\"hljs-keyword\\">mut</span> solver = Solver::try_from((Config::<span class=\\"hljs-keyword\\">default</span>(), rules.as_ref())).expect(<span class=\\"hljs-string\\">\\"panic\\"</span>);\\n    <span class=\\"hljs-comment\\">// 初期状態</span>\\n    solver.add_assignment(Pos::at(<span class=\\"hljs-number\\">5</span>, <span class=\\"hljs-number\\">3</span>).state(<span class=\\"hljs-number\\">1</span>, <span class=\\"hljs-literal\\">true</span>).as_lit()).expect(<span class=\\"hljs-string\\">\\"panic\\"</span>);\\n    solver.add_assignment(Pos::at(<span class=\\"hljs-number\\">6</span>, <span class=\\"hljs-number\\">7</span>).state(<span class=\\"hljs-number\\">2</span>, <span class=\\"hljs-literal\\">true</span>).as_lit()).expect(<span class=\\"hljs-string\\">\\"panic\\"</span>);\\n    <span class=\\"hljs-keyword\\">for</span> ans <span class=\\"hljs-keyword\\">in</span> solver.iter() {\\n        <span class=\\"hljs-comment\\">// 正リテラルだけ抽出</span>\\n        <span class=\\"hljs-keyword\\">let</span> picked = ans.iter().filter(|l| <span class=\\"hljs-number\\">0</span> &lt; **l).collect::&lt;<span class=\\"hljs-built_in\\">Vec</span>&lt;&amp;<span class=\\"hljs-built_in\\">i32</span>&gt;&gt;();\\n        <span class=\\"hljs-built_in\\">println!</span>(-);\\n    }</code></pre><p>できたプログラムは<a href=\\"https://github.com/shnarazk/miracle_sudoku\\">こちら</a>。</p>\\n<p>座標やリテラルは1で始まる一方で、<code>Vec</code> は0で始まるといったあたりでいつものようにバグを発生させてしまった\\nけど、200行程度でできました。</p>\\n<h2>実行結果</h2>\\n<p>得られる出力は以下の通り。</p>\\n<pre><code class=\\"hljs\\">4 8 3 7 2 6 1 5 9 \\n7 2 6 1 5 9 4 8 3 \\n1 5 9 4 8 3 7 2 6 \\n8 3 7 2 6 1 5 9 4 \\n2 6 1 5 9 4 8 3 7 \\n5 9 4 8 3 7 2 6 1 \\n3 7 2 6 1 5 9 4 8 \\n6 1 5 9 4 8 3 7 2 \\n9 4 8 3 7 2 6 1 5</code></pre><p>となって、ビデオの解が唯一解であることも判明しました。</p>\\n","dir":"article/.json/2020","base":"2020-05-26-MiracleSudoku.json","ext":".json","sourceBase":"2020-05-26-MiracleSudoku.md","sourceExt":".md"}')}}]);