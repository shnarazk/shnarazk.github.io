(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{523:function(n){n.exports=JSON.parse('{"title":"Memo on Nixpkgs","subtitle":"nixで最強パッケージ管理","date":"2019-02-27T00:00:00.000Z","tags":["nixos"],"bodyContent":"## Location of my configuration file\\n\\nis **~/.config/nixpkgs/config.nix**.\\n\\n- https://nixos.wiki/wiki/FAQ#How_can_I_manage_software_with_nix-env_like_with_configuration.nix.3F\\n\\n\\n## Overriding nix package\\n\\n- \'error: attribute `override\' missing\'\\n\\nProbably you\'re trying to override a non-existing package.\\n\\nFor example, the following emits the error because `emacs26` doesn\'t exist.\\n\\n```\\n# ~/.config/nixpkgs/config.nix\\n{ pkgs }:\\n{\\n    allowBroken = true;\\n    allowUnfree = true;\\n\\n    packageOverrides = pkgs : rec {\\n   \\temacs26 = pkgs.stdenv.lib.overrideDerivation pkgs.emacs26 (oldAttrs : {\\n\\t    name = \\"emacs-26.1.92\\";\\n\\t    version = \\"26.1.92\\";\\n\\t    src = pkgs.fetchurl {\\n\\t        url = \\"https://alpha.gnu.org/gnu/emacs/pretest/emacs-26.1.92.tar.xz\\";\\n\\t\\t    sha256 = \\"0aa1dfa39b020feb49b82a388863c8a4b2ee0f1dfc04528f49759dbba4f28d41\\";\\n\\t\\t};\\n\\t});\\n  };\\n}\\n```\\n\\nBy changing the package name to `emacs`, it works.\\n\\n- https://github.com/NixOS/nixpkgs/issues/4017\\n\\n### UPDATE\\n\\n`overrideDerivation` is almost depricated. Here\'s a better version:\\n\\n```\\nself: super:\\n{\\n    emacs26 = super.emacs26.overrideAttrs (attrs: rec {\\n        name = \\"emacs-26.1.92\\";\\n        version = \\"26.1.92\\";\\n        src = super.fetchurl {\\n            url = \\"https://alpha.gnu.org/gnu/emacs/pretest/emacs-26.1.92.tar.xz\\";\\n            sha256 = \\"0aa1dfa39b020feb49b82a388863c8a4b2ee0f1dfc04528f49759dbba4f28d41\\";\\n        };\\n        patches = [];\\n    });\\n}\\n```\\n\\n### nixファイルの構造\\n\\nnixファイルはnix式を定義するもの。\\n\\n- nix-buildはderivationを生成する式を要求する。そしてその環境のシェルを走らせる。?\\n- config.nixやオーバレイはnixpkgsを更新する関数を定義するもの。?\\n\\n- https://nixos.org/nixos/manual/index.html#sec-nix-syntax-summary\\n- https://nixos.org/nixos/manual/index.html#sec-configuration-syntax\\n\\n### そもそもの関数の構文\\n\\n- `:`が引数と本体のセパレータ。\\n\\n```nix\\nx : x + 1\\n```\\n\\n- 集合を引数に取り、その中の特定要素を参照するならば、セレクタを並べた（カンマ区切り）集合が引数に位置する。\\n\\n```nix\\n{ x, y }: x + y\\n```\\n\\nこれは一見、2引数関数のように見えるがコロンの位置からもそうではない。\\n\\nということで、例えばlet構文（式）なしで集合型の返値が計算できるなら\\n\\n```nix\\n{ config, pkgs }:\\n{\\n\\t属性の定義式;\\n}\\n```\\n\\nとなるし、let構文を使いたいなら以下のようになる。\\n\\n```nix\\n{ config, pkgs }:\\nlet\\n  x = { ... };\\n  y = { ... };\\n  ...\\nin\\n  x\\n```\\n\\nなお、2引数関数はoverlayで用いられている。\\n\\n```nix\\nself: super:\\n...\\n```\\n\\n- nix-buildに与えるべきnixファイル(shell.nixという名前がconvention?)はこんな感じ:\\n\\n```nix\\nwith import <nixgkgs> {};   # この;は文を区切るものではなく、withは次の行まで続いている\\n  ...  # derivationを返すこと\\n```\\n\\nA derivationを返すwith構文が一つあるだけ。with構文については後述。\\n\\n- nix-shellに与えるべきnixファイル（default.nixがデフォールト）はこんな感じ:\\n\\n```nix\\nwith import <nixgkgs> {};\\n{ ... } # 集合を返す\\n```\\n\\npkgsを更新している？\\n\\n### モジュールとwith構文\\n\\nということで多くのファイルは以下の構造で単一の関数が定義されているだけ。\\n\\n```nix\\n{ 依存するモジュール（カンマ区切り） }:\\n返値\\n```\\n\\nオーバレイも ~/.config/nixpkgs/config.nix もこんな感じ。\\n\\n```nix\\n{ pkgs }:\\n{\\n\\t...\\n}\\n```\\n\\nここで`with import <nixpkgs>`を先頭に置いても問題ないはず。\\n試してみたところ、下のどちらの書き方でも正しく評価できる。\\n\\n```nix\\nwith import <inxpkgs>; self: super:\\n  ...\\n```\\n\\n\\n```nix\\nwith import <inxpkgs> {}; self: super:\\n  ...\\n```\\n\\nそれどころか以下でも問題ない。\\n\\n```nix\\nwith import <inxpkgs> {} {}; self: super:\\n  ...\\n```\\n\\n何故ならば、`import <nixpkgs>`は`関数：集合 -> 集合`。\\nなので`(import <inxpkgs>) {}`は関数適用。もちろんその返値は集合を受け付ける関数。なので`{}`を受け付\\nける。\\nそして評価が終わった`import <inxpkgs> {} {}`までを環境として、セミコロン以下の本体を評価するのがwith\\n構文（式）。\\n\\n- https://nixos.org/nixos/nix-pills/functions-and-imports.html#idm140737316371552\\n\\nS式で表せばこういうこと。\\n\\n```nix\\n(with (((import <inxpkgs>) {}) {}) (self: super: ...))\\n```\\n\\nうーん、ヘンタイ。","bodyHtml":"<h2>Location of my configuration file</h2>\\n<p>is <strong>~/.config/nixpkgs/config.nix</strong>.</p>\\n<ul>\\n<li>https://nixos.wiki/wiki/FAQ#How_can_I_manage_software_with_nix-env_like_with_configuration.nix.3F</li>\\n</ul>\\n<h2>Overriding nix package</h2>\\n<ul>\\n<li>\'error: attribute `override\' missing\'</li>\\n</ul>\\n<p>Probably you\'re trying to override a non-existing package.</p>\\n<p>For example, the following emits the error because <code>emacs26</code> doesn\'t exist.</p>\\n<pre><code># ~/.config/nixpkgs/config.nix\\n{ pkgs }:\\n{\\n    allowBroken = true;\\n    allowUnfree = true;\\n\\n    packageOverrides = pkgs : rec {\\n   \\temacs26 = pkgs.stdenv.lib.overrideDerivation pkgs.emacs26 (oldAttrs : {\\n\\t    name = &quot;emacs-26.1.92&quot;;\\n\\t    version = &quot;26.1.92&quot;;\\n\\t    src = pkgs.fetchurl {\\n\\t        url = &quot;https://alpha.gnu.org/gnu/emacs/pretest/emacs-26.1.92.tar.xz&quot;;\\n\\t\\t    sha256 = &quot;0aa1dfa39b020feb49b82a388863c8a4b2ee0f1dfc04528f49759dbba4f28d41&quot;;\\n\\t\\t};\\n\\t});\\n  };\\n}\\n</code></pre>\\n<p>By changing the package name to <code>emacs</code>, it works.</p>\\n<ul>\\n<li>https://github.com/NixOS/nixpkgs/issues/4017</li>\\n</ul>\\n<h3>UPDATE</h3>\\n<p><code>overrideDerivation</code> is almost depricated. Here\'s a better version:</p>\\n<pre><code>self: super:\\n{\\n    emacs26 = super.emacs26.overrideAttrs (attrs: rec {\\n        name = &quot;emacs-26.1.92&quot;;\\n        version = &quot;26.1.92&quot;;\\n        src = super.fetchurl {\\n            url = &quot;https://alpha.gnu.org/gnu/emacs/pretest/emacs-26.1.92.tar.xz&quot;;\\n            sha256 = &quot;0aa1dfa39b020feb49b82a388863c8a4b2ee0f1dfc04528f49759dbba4f28d41&quot;;\\n        };\\n        patches = [];\\n    });\\n}\\n</code></pre>\\n<h3>nixファイルの構造</h3>\\n<p>nixファイルはnix式を定義するもの。</p>\\n<ul>\\n<li>\\n<p>nix-buildはderivationを生成する式を要求する。そしてその環境のシェルを走らせる。?</p>\\n</li>\\n<li>\\n<p>config.nixやオーバレイはnixpkgsを更新する関数を定義するもの。?</p>\\n</li>\\n<li>\\n<p>https://nixos.org/nixos/manual/index.html#sec-nix-syntax-summary</p>\\n</li>\\n<li>\\n<p>https://nixos.org/nixos/manual/index.html#sec-configuration-syntax</p>\\n</li>\\n</ul>\\n<h3>そもそもの関数の構文</h3>\\n<ul>\\n<li><code>:</code>が引数と本体のセパレータ。</li>\\n</ul>\\n<pre><code class=\\"hljs\\">x : x + 1</code></pre><ul>\\n<li>集合を引数に取り、その中の特定要素を参照するならば、セレクタを並べた（カンマ区切り）集合が引数に位置する。</li>\\n</ul>\\n<pre><code class=\\"hljs\\">{ x, y }: x + y</code></pre><p>これは一見、2引数関数のように見えるがコロンの位置からもそうではない。</p>\\n<p>ということで、例えばlet構文（式）なしで集合型の返値が計算できるなら</p>\\n<pre><code class=\\"hljs\\">{ config, pkgs }:\\n{\\n\\t属性の定義式;\\n}</code></pre><p>となるし、let構文を使いたいなら以下のようになる。</p>\\n<pre><code class=\\"hljs\\">{ config, pkgs }:\\n<span class=\\"hljs-keyword\\">let</span>\\n  <span class=\\"hljs-attr\\">x</span> = { ... };\\n  <span class=\\"hljs-attr\\">y</span> = { ... };\\n  ...\\n<span class=\\"hljs-keyword\\">in</span>\\n  x</code></pre><p>なお、2引数関数はoverlayで用いられている。</p>\\n<pre><code class=\\"hljs\\">self: super:\\n...</code></pre><ul>\\n<li>nix-buildに与えるべきnixファイル(shell.nixという名前がconvention?)はこんな感じ:</li>\\n</ul>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-keyword\\">with</span> <span class=\\"hljs-built_in\\">import</span> &lt;nixgkgs&gt; {};   <span class=\\"hljs-comment\\"># この;は文を区切るものではなく、withは次の行まで続いている</span>\\n  ...  <span class=\\"hljs-comment\\"># derivationを返すこと</span></code></pre><p>A derivationを返すwith構文が一つあるだけ。with構文については後述。</p>\\n<ul>\\n<li>nix-shellに与えるべきnixファイル（default.nixがデフォールト）はこんな感じ:</li>\\n</ul>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-keyword\\">with</span> <span class=\\"hljs-built_in\\">import</span> &lt;nixgkgs&gt; {};\\n{ ... } <span class=\\"hljs-comment\\"># 集合を返す</span></code></pre><p>pkgsを更新している？</p>\\n<h3>モジュールとwith構文</h3>\\n<p>ということで多くのファイルは以下の構造で単一の関数が定義されているだけ。</p>\\n<pre><code class=\\"hljs\\">{ 依存するモジュール（カンマ区切り） }:\\n返値</code></pre><p>オーバレイも ~/.config/nixpkgs/config.nix もこんな感じ。</p>\\n<pre><code class=\\"hljs\\">{ pkgs }:\\n{\\n\\t...\\n}</code></pre><p>ここで<code>with import &lt;nixpkgs&gt;</code>を先頭に置いても問題ないはず。\\n試してみたところ、下のどちらの書き方でも正しく評価できる。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-keyword\\">with</span> <span class=\\"hljs-built_in\\">import</span> &lt;inxpkgs&gt;; self: super:\\n  ...</code></pre><pre><code class=\\"hljs\\"><span class=\\"hljs-keyword\\">with</span> <span class=\\"hljs-built_in\\">import</span> &lt;inxpkgs&gt; {}; self: super:\\n  ...</code></pre><p>それどころか以下でも問題ない。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-keyword\\">with</span> <span class=\\"hljs-built_in\\">import</span> &lt;inxpkgs&gt; {} {}; self: super:\\n  ...</code></pre><p>何故ならば、<code>import &lt;nixpkgs&gt;</code>は<code>関数：集合 -&gt; 集合</code>。\\nなので<code>(import &lt;inxpkgs&gt;) {}</code>は関数適用。もちろんその返値は集合を受け付ける関数。なので<code>{}</code>を受け付\\nける。\\nそして評価が終わった<code>import &lt;inxpkgs&gt; {} {}</code>までを環境として、セミコロン以下の本体を評価するのがwith\\n構文（式）。</p>\\n<ul>\\n<li>https://nixos.org/nixos/nix-pills/functions-and-imports.html#idm140737316371552</li>\\n</ul>\\n<p>S式で表せばこういうこと。</p>\\n<pre><code class=\\"hljs\\">(<span class=\\"hljs-keyword\\">with</span> (((<span class=\\"hljs-built_in\\">import</span> &lt;inxpkgs&gt;) {}) {}) (self: super: ...))</code></pre><p>うーん、ヘンタイ。</p>\\n","dir":"article/.json/2019","base":"2019-02-27-memo-on-nix.json","ext":".json","sourceBase":"2019-02-27-memo-on-nix.md","sourceExt":".md"}')}}]);