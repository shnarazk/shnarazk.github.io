(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{565:function(n){n.exports=JSON.parse('{"title":"LR needs something to explore the world","subtitle":"I guess so","date":"2020-05-21T00:00:00.000Z","tags":["SAT"],"bodyContent":"引き続きよくわかってない人の意見の連投ですが。\\n\\n## LRのリスタート問題\\n\\nLR はよさそうなんだけども、そんなにいいならリスタートの立場はどうなる？\\n矛盾発生率の最適化を達成していて何故リスタートが必要になるのだろうか。\\n\\nしかし何かそのようなものが必要なことはすぐわかる。\\n以前も書いたような気がするがリスタートはリスタートであって、決してリセットではないのだ。\\nEVSIDS も含めた変数選択ヒューリスティックスは割当て後にその使われた変数に値を割り当てるもので、使われてない変数に脚光を当てるものではない。\\n従って、リスタートを掛けても優先度が高い変数間の順序が変わるだけと書いてもそれほど言い過ぎというわけではないだろう。\\nもちろん順序を入れ替えることによってリスタート後の伝播の方向がこれまでと違う方向へと向かうことはあるけども、いきなり極端に違う変数が選ばれるものではない（という去年の経験）。\\n\\nさて、LRはあくまでみた事のある変数の中での順序づけであり、それが変数全体の中での最適解とはとても言えない。\\nそして、矛盾から生成される学習節の LBD 的なよさとも無関係である。\\n従って、もしLBD が悪い学習節が生成される傾向にあるならば、LRといえどもそれなりの対応が必要になるはずである。\\n\\nそれはどういうものかというと、\\n\\n* 試していない変数の評価を行う（そのためには割当てを実行しなければならない）。そのためにはリスタートが必要。\\n* 単にそのような変数への割当て評価を行っただけでは、decay rateが高い状況では結局無視されてしまうので、decay rateの一時的な修正か何かが必要。\\n\\nということではなかろうか（decay rate を下げる云々は昨日の複数ヒューリスティックスの併用を念頭に置いている）。\\nいっそのことdecay rate の違う二つのLRを使おうか。あるいはdecay rateを初期値に戻そうか。。。\\n\\nというわけでリスタートは実は不十分でさらにexploreのための補助となる仕組みが必要ではなかろうか、という作業仮説でした。\\n\\n```rust\\n#[derive(Eq, Ord, PartialEq, PartialOrd)]\\nstruct VarTimestamp {\\n    timestamp: usize,\\n    vi: VarId,\\n}\\n\\nimpl VarSelectIF for AssignStack {\\n    fn force_select_iter(&mut self, ...) {\\n        let mut heap: BinaryHeap<VarTimestamp> = BinaryHeap::new();\\n        let size: usize = todo!();\\n        for v in self.var.iter().skip(1) {\\n            if self.assign[v.index].is_some() || v.is(Flag::ELIMINATED) {\\n                continue;\\n            }\\n            if let Some(top) = heap.peek() {\\n                if v.timestamp < top.timestamp {\\n                    heap.push(VarTimestamp::from(v));\\n                    if size < heap.len() {\\n                        heap.pop();\\n                    }\\n                }\\n            }\\n        }\\n        for v in heap.iter() {\\n            let lit = Lit::from_assign(v.vi, self.var[v.vi].is(Flag::PHASE));\\n            self.temp_order.push(lit);\\n        }\\n    }\\n```\\n\\n## 2020-05-21\\n\\nうまくいかぬ。exploreの契機はworse LBDではないのかもしれない。\\n\\n![](https://2.bp.blogspot.com/-hMADLxB1puo/VMIvawjKgWI/AAAAAAAAq8E/2bgLT3inaSk/s400/cooking15_rangiri.png)","bodyHtml":"<p>引き続きよくわかってない人の意見の連投ですが。</p>\\n<h2>LRのリスタート問題</h2>\\n<p>LR はよさそうなんだけども、そんなにいいならリスタートの立場はどうなる？\\n矛盾発生率の最適化を達成していて何故リスタートが必要になるのだろうか。</p>\\n<p>しかし何かそのようなものが必要なことはすぐわかる。\\n以前も書いたような気がするがリスタートはリスタートであって、決してリセットではないのだ。\\nEVSIDS も含めた変数選択ヒューリスティックスは割当て後にその使われた変数に値を割り当てるもので、使われてない変数に脚光を当てるものではない。\\n従って、リスタートを掛けても優先度が高い変数間の順序が変わるだけと書いてもそれほど言い過ぎというわけではないだろう。\\nもちろん順序を入れ替えることによってリスタート後の伝播の方向がこれまでと違う方向へと向かうことはあるけども、いきなり極端に違う変数が選ばれるものではない（という去年の経験）。</p>\\n<p>さて、LRはあくまでみた事のある変数の中での順序づけであり、それが変数全体の中での最適解とはとても言えない。\\nそして、矛盾から生成される学習節の LBD 的なよさとも無関係である。\\n従って、もしLBD が悪い学習節が生成される傾向にあるならば、LRといえどもそれなりの対応が必要になるはずである。</p>\\n<p>それはどういうものかというと、</p>\\n<ul>\\n<li>試していない変数の評価を行う（そのためには割当てを実行しなければならない）。そのためにはリスタートが必要。</li>\\n<li>単にそのような変数への割当て評価を行っただけでは、decay rateが高い状況では結局無視されてしまうので、decay rateの一時的な修正か何かが必要。</li>\\n</ul>\\n<p>ということではなかろうか（decay rate を下げる云々は昨日の複数ヒューリスティックスの併用を念頭に置いている）。\\nいっそのことdecay rate の違う二つのLRを使おうか。あるいはdecay rateを初期値に戻そうか。。。</p>\\n<p>というわけでリスタートは実は不十分でさらにexploreのための補助となる仕組みが必要ではなかろうか、という作業仮説でした。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-meta\\">#[derive(Eq, Ord, PartialEq, PartialOrd)]</span>\\n<span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">struct</span> <span class=\\"hljs-title\\">VarTimestamp</span></span> {\\n    timestamp: <span class=\\"hljs-built_in\\">usize</span>,\\n    vi: VarId,\\n}\\n\\n<span class=\\"hljs-keyword\\">impl</span> VarSelectIF <span class=\\"hljs-keyword\\">for</span> AssignStack {\\n    <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">fn</span> <span class=\\"hljs-title\\">force_select_iter</span></span>(&amp;<span class=\\"hljs-keyword\\">mut</span> <span class=\\"hljs-keyword\\">self</span>, ...) {\\n        <span class=\\"hljs-keyword\\">let</span> <span class=\\"hljs-keyword\\">mut</span> heap: BinaryHeap&lt;VarTimestamp&gt; = BinaryHeap::new();\\n        <span class=\\"hljs-keyword\\">let</span> size: <span class=\\"hljs-built_in\\">usize</span> = todo!();\\n        <span class=\\"hljs-keyword\\">for</span> v <span class=\\"hljs-keyword\\">in</span> <span class=\\"hljs-keyword\\">self</span>.var.iter().skip(<span class=\\"hljs-number\\">1</span>) {\\n            <span class=\\"hljs-keyword\\">if</span> <span class=\\"hljs-keyword\\">self</span>.assign[v.index].is_some() || v.is(Flag::ELIMINATED) {\\n                <span class=\\"hljs-keyword\\">continue</span>;\\n            }\\n            <span class=\\"hljs-keyword\\">if</span> <span class=\\"hljs-keyword\\">let</span> <span class=\\"hljs-literal\\">Some</span>(top) = heap.peek() {\\n                <span class=\\"hljs-keyword\\">if</span> v.timestamp &lt; top.timestamp {\\n                    heap.push(VarTimestamp::from(v));\\n                    <span class=\\"hljs-keyword\\">if</span> size &lt; heap.len() {\\n                        heap.pop();\\n                    }\\n                }\\n            }\\n        }\\n        <span class=\\"hljs-keyword\\">for</span> v <span class=\\"hljs-keyword\\">in</span> heap.iter() {\\n            <span class=\\"hljs-keyword\\">let</span> lit = Lit::from_assign(v.vi, <span class=\\"hljs-keyword\\">self</span>.var[v.vi].is(Flag::PHASE));\\n            <span class=\\"hljs-keyword\\">self</span>.temp_order.push(lit);\\n        }\\n    }</code></pre><h2>2020-05-21</h2>\\n<p>うまくいかぬ。exploreの契機はworse LBDではないのかもしれない。</p>\\n<p><img src=\\"https://2.bp.blogspot.com/-hMADLxB1puo/VMIvawjKgWI/AAAAAAAAq8E/2bgLT3inaSk/s400/cooking15_rangiri.png\\" alt=\\"\\"></p>\\n","dir":"article/.json/2020","base":"2020-05-20-LR-needs-something.json","ext":".json","sourceBase":"2020-05-20-LR-needs-something.md","sourceExt":".md"}')}}]);