(window.webpackJsonp=window.webpackJsonp||[]).push([[116],{609:function(n){n.exports=JSON.parse('{"title":"New Implementation of vivification on Splr","subtitle":"vivification part 4","date":"2021-05-04T00:00:00.000Z","tags":["SAT","vivification","splr"],"banner":"https://unsplash.com/photos/GWtOJTUyDfc/download?force=true&w=2400","banner_caption":"https://unsplash.com/photos/GWtOJTUyDfc","bodyContent":"### 2021-04-10\\n\\nSplr-0.7.1で発見された決定性誤りバグの一因がどうもvivificationにあるようなので、徹底的に見直してみた。\\nその結果、バグ修正の副産物として大変更に至りました。\\n\\nこれまではひたすら論文[1]のオリジナル疑似コードに忠実な実装を心がけていた:\\n\\n![](/img/2020/07-05/vivi-algo3.jpg)\\n\\nここで`confilctAnalysis`の引数は\\n\\n1. $\\\\phi$ -- 論理式式\\n1. $D$ -- 仮定されたリテラル列（なぜtrailではいけないのだろう）\\n1. $R$ - 矛盾節\\n\\n見ての通り、節を追加して伝播させて、節を削除して、ということを繰り返している。\\nそのためsandboxなんてものをサブモジュールに追加したりしていたのだけど、この\\"clause vivification\\"とは\\n\\n- 節に含まれるリテラルを順に否定して行った時に、いくつ目のリテラルで（この節ひいては式が）矛盾するかを考え、それ以上のリテラルはあっても無駄なので省きましょう\\n\\nというだけのこと。だったらこの通りに実装すればいいんじゃない？\\n\\n```rust\\n  let c = cdb.clause[cid];\\n  for (i, lit) in c.lits.iter().enumerate() {  // 順番に\\n    asg.assign_by_decision(!lit); // 否定してみて\\n    if asg.propagate().is_some()  // 矛盾した時に\\n       && i < c.lits.len() // 短くなっていたら\\n    {\\n      cdb.strengthen_by_vivification(cid, i);  // iまでのリテラルに縮退\\n      break;\\n    }\\n  }\\n  asg.cancel_until(self.root_level); // クリーンアップ\\n```\\n\\n節の出し入れが一切なくなってclauseDB的な負荷が一切消えてしまった!\\nこれで決まりだな。\\n\\n### 2021-04-16\\n\\nそしてこれがSplr-0.7.1がさらに1週間リリースできなかった原因になってしまった。\\nうん、全くダメな考えだった。論外だった。\\n\\n### 2021-05-04\\n\\nだめじゃない。ダメなのは矛盾解析の部分で、決定リテラルを積み重ねるこの方法はずっとスマートな気がしてきた。少なくとも、これがSplr-0.7.1におけるvivificationの決定性判定間違いの原因ではない。\\n\\nというわけでこれで行こう：\\n\\n```rust\\n  let c = cdb.clause[cid];\\n  for (i, lit) in c.lits.iter().take(c.lits.len() - 1).enumerate() {  // 順番に\\n    asg.assign_by_decision(!lit);       // 否定してみて\\n    if let Some(cc) = asg.propagate() { // 矛盾した時に\\n      if cc == cid {                    // それが対象節なら、\\n        let vec = conflict_analyze(cc); // 矛盾解析して\\n        cdb.new_clause(vec);            // 学習節を追加\\n        cdb.remove_clause(cid);         // 対象節を削除\\n      }\\n      asg.backtrack(root_level);\\n      break;\\n    }\\n  }\\n  asg.cancel_until(self.root_level); // クリーンアップ\\n```\\n\\n## References\\n\\n[1] C.-M. Li, F. Xiao, M. Luo, F. Manyà, Z. Lü, and Y. Li, “Clause Vivification by Unit Propagation in CDCL SAT Solvers,”* Artif. Intell*., vol. 279, Jul. 2019.","bodyHtml":"<h3>2021-04-10</h3>\\n<p>Splr-0.7.1で発見された決定性誤りバグの一因がどうもvivificationにあるようなので、徹底的に見直してみた。\\nその結果、バグ修正の副産物として大変更に至りました。</p>\\n<p>これまではひたすら論文[1]のオリジナル疑似コードに忠実な実装を心がけていた:</p>\\n<p><img src=\\"/img/2020/07-05/vivi-algo3.jpg\\" alt=\\"\\"></p>\\n<p>ここで<code>confilctAnalysis</code>の引数は</p>\\n<ol>\\n<li>$\\\\phi$ -- 論理式式</li>\\n<li>$D$ -- 仮定されたリテラル列（なぜtrailではいけないのだろう）</li>\\n<li>$R$ - 矛盾節</li>\\n</ol>\\n<p>見ての通り、節を追加して伝播させて、節を削除して、ということを繰り返している。\\nそのためsandboxなんてものをサブモジュールに追加したりしていたのだけど、この&quot;clause vivification&quot;とは</p>\\n<ul>\\n<li>節に含まれるリテラルを順に否定して行った時に、いくつ目のリテラルで（この節ひいては式が）矛盾するかを考え、それ以上のリテラルはあっても無駄なので省きましょう</li>\\n</ul>\\n<p>というだけのこと。だったらこの通りに実装すればいいんじゃない？</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-keyword\\">let</span> c = cdb.clause[cid];\\n  <span class=\\"hljs-keyword\\">for</span> (i, lit) <span class=\\"hljs-keyword\\">in</span> c.lits.iter().enumerate() {  <span class=\\"hljs-comment\\">// 順番に</span>\\n    asg.assign_by_decision(!lit); <span class=\\"hljs-comment\\">// 否定してみて</span>\\n    <span class=\\"hljs-keyword\\">if</span> asg.propagate().is_some()  <span class=\\"hljs-comment\\">// 矛盾した時に</span>\\n       &amp;&amp; i &lt; c.lits.len() <span class=\\"hljs-comment\\">// 短くなっていたら</span>\\n    {\\n      cdb.strengthen_by_vivification(cid, i);  <span class=\\"hljs-comment\\">// iまでのリテラルに縮退</span>\\n      <span class=\\"hljs-keyword\\">break</span>;\\n    }\\n  }\\n  asg.cancel_until(<span class=\\"hljs-keyword\\">self</span>.root_level); <span class=\\"hljs-comment\\">// クリーンアップ</span></code></pre><p>節の出し入れが一切なくなってclauseDB的な負荷が一切消えてしまった!\\nこれで決まりだな。</p>\\n<h3>2021-04-16</h3>\\n<p>そしてこれがSplr-0.7.1がさらに1週間リリースできなかった原因になってしまった。\\nうん、全くダメな考えだった。論外だった。</p>\\n<h3>2021-05-04</h3>\\n<p>だめじゃない。ダメなのは矛盾解析の部分で、決定リテラルを積み重ねるこの方法はずっとスマートな気がしてきた。少なくとも、これがSplr-0.7.1におけるvivificationの決定性判定間違いの原因ではない。</p>\\n<p>というわけでこれで行こう：</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-keyword\\">let</span> c = cdb.clause[cid];\\n  <span class=\\"hljs-keyword\\">for</span> (i, lit) <span class=\\"hljs-keyword\\">in</span> c.lits.iter().take(c.lits.len() - <span class=\\"hljs-number\\">1</span>).enumerate() {  <span class=\\"hljs-comment\\">// 順番に</span>\\n    asg.assign_by_decision(!lit);       <span class=\\"hljs-comment\\">// 否定してみて</span>\\n    <span class=\\"hljs-keyword\\">if</span> <span class=\\"hljs-keyword\\">let</span> <span class=\\"hljs-literal\\">Some</span>(cc) = asg.propagate() { <span class=\\"hljs-comment\\">// 矛盾した時に</span>\\n      <span class=\\"hljs-keyword\\">if</span> cc == cid {                    <span class=\\"hljs-comment\\">// それが対象節なら、</span>\\n        <span class=\\"hljs-keyword\\">let</span> vec = conflict_analyze(cc); <span class=\\"hljs-comment\\">// 矛盾解析して</span>\\n        cdb.new_clause(vec);            <span class=\\"hljs-comment\\">// 学習節を追加</span>\\n        cdb.remove_clause(cid);         <span class=\\"hljs-comment\\">// 対象節を削除</span>\\n      }\\n      asg.backtrack(root_level);\\n      <span class=\\"hljs-keyword\\">break</span>;\\n    }\\n  }\\n  asg.cancel_until(<span class=\\"hljs-keyword\\">self</span>.root_level); <span class=\\"hljs-comment\\">// クリーンアップ</span></code></pre><h2>References</h2>\\n<p>[1] C.-M. Li, F. Xiao, M. Luo, F. Manyà, Z. Lü, and Y. Li, “Clause Vivification by Unit Propagation in CDCL SAT Solvers,”* Artif. Intell*., vol. 279, Jul. 2019.</p>\\n","dir":"article/.json/2021","base":"2021-04-10-splr-vivification.json","ext":".json","sourceBase":"2021-04-10-splr-vivification.md","sourceExt":".md"}')}}]);