(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{519:function(n){n.exports=JSON.parse('{"title":"Deploy a Servant program to Heroku with Docker","subtitle":"HaskellプログラムをHerokuで動かそう（2018年私家版）","date":"2018-06-24T00:00:00.000Z","tags":["haskell","servant","heroku","docker","gitlab","nixos"],"bodyContent":"stackのテンプレートを使って\\n[Dockerを使ってHaskellアプリをHerokuにデプロイする](https://haskell.jp/blog/posts/2017/02-haskell-on-heroku.html)\\nと同じことをやってみます．\\n\\n### 下準備（オプショナル）\\n\\nstackに警告を出されないように，~/.stack/config.yml に以下のような情報を追加しておくといいかも．\\n\\n```yaml\\ntemplates:\\n  params:\\n    author-email: EMAIL\\n    author-name:  NAME\\n```\\n\\n### プロジェクトの生成\\n\\nstackのテンプレート `servant-docker` を使ってプロジェクトの雛形を作らせます．\\n\\n```\\nstack new PROJECT [--bare] servant-docker [--solver SOLVER]\\n```\\n\\n雛形なのでこれでデプロイまでできるはずなのですが，いくつか問題があるので修正します．\\n\\n### heroku用にプログラムを変更\\n\\nまず，herokuの環境でlistenすべきポート番号は環境変数で取得しないといけないのでそれを反映させます：\\n\\n```diff\\ndiff --git a/src/Lib.hs b/src/Lib.hs\\nindex 46ba8bc..c800dc5 100644\\n--- a/src/Lib.hs\\n+++ b/src/Lib.hs\\n@@ -10,6 +10,7 @@ import Data.Aeson.TH\\n import Network.Wai\\n import Network.Wai.Handler.Warp\\n import Servant\\n+import System.ReadEnvVar (readEnvDef)\\n\\n data User = User\\n   { userId        :: Int\\n@@ -22,7 +23,10 @@ $(deriveJSON defaultOptions \'\'User)\\n type API = \\"users\\" :> Get \'[JSON] [User]\\n\\n startApp :: IO ()\\n-startApp = run 1234 app\\n+startApp = do\\n+  port <- readEnvDef \\"PORT\\" 8080\\n+  putStrLn $ \\";;; start server at \\" ++ show port\\n+  run port app\\n\\n app :: Application\\n app = serve api server\\n```\\n\\n[ReadEnvVar](https://github.com/cdepillabout/read-env-var)パッケージを追加したのでcabalファイルにも追加：\\n\\n```diff\\ndiff --git a/appname.cabal b/appname.cabal\\nindex b977aa5..e654f60 100644\\n--- a/PROJECT.cabal\\n+++ b/PROJECT.cabal\\n@@ -18,6 +18,7 @@ library\\n   exposed-modules:     Lib\\n   build-depends:       base >= 4.7 && < 5\\n                      , aeson\\n+                     , read-env-var\\n                      , servant-server\\n                      , wai\\n                      , warp\\n```\\n\\n### 手動で確認\\n\\nここでコンパイルしてエラーがないことを確認します．\\n\\n```bash\\n$ stack build\\n```\\n\\n動作確認は\\n\\n```bash\\n$ export PORT=8080; APP &\\n$ wget http://localhost:8080/\\n```\\n\\n### Dockerイメージの作成\\n\\nまずdockerのイメージでプログラムが自動で実行されるようにDockerfile（ついでにstack.yml）を変更します．\\n．\\n\\n```diff\\n--- a/Dockerfile\\n+++ b/Dockerfile\\n@@ -9,3 +9,4 @@\\n\\n COPY . /app/user\\n RUN stack install\\n+CMD APP.EXE\\n```\\n\\n```diff\\nmodified   stack.yaml\\n@@ -66,6 +66,15 @@ allow-newer: true\\n # Allow a newer minor version of GHC than the snapshot specifies\\n # compiler-check: newer-minor\\n\\n+image:\\n+  containers:\\n+    -\\n+      base: \\"haskell:8.4.3\\"\\n+      executables:\\n+        - APP.EXE\\n+      entrypoints:\\n+        - APP.EXE\\n```\\n\\n以下を実行してイメージを作ります：\\n\\n```\\ndocker build -t APPNAME .\\n```\\n\\n動作確認は\\n\\n```bash\\n$ docker run -p 8080:8080 --publish-all APPNAME\\n$ wget http://localhost:8080/\\n```\\n\\n### herokuへのデプロイ\\n\\n#### 初期設定\\n\\n1. アカウントを作る\\n2. heroku dashboardでアプリの登録\\n\\n```sh\\nheroku login\\nheroku apps:create APPNAME\\n```\\n\\n#### ビルドからデプロイ\\n\\n1. ログインする\\n2. コンテナ環境での作業\\n\\n```sh\\n$ heroku container:login\\n$ heroku container:push web [--app APPNAME]\\n$ heroku container:release web [--app APPNAME]\\n```\\n\\n### gitlab-ci.ymlに登録\\n\\nうまく行ったなら自動化させます．当然gitlab用に `.gitlab-ci.yml` を作成：\\n\\n```\\nbuild:\\n  stage: build\\n  script:\\n    - docker build -t APPNAME .\\n\\ndeploy heroku:\\n  stage: deploy\\n  script:\\n    - heroku container:login\\n    - heroku container:push web --app APPNAME\\n    - heroku container:release web --app APPNAME\\n```\\n\\n（さらにherokuへのデプロイ用のキーを登録する必要があるかも）\\n\\nThat\'s it.\\n\\n## だったらstack templateにしてしまおう\\n\\nということで以上の変更をしたテンプレート https://gitlab.com/snippets/1728485/raw を作りました．\\nテンプレートはurl指定で使えるので，以下のようにするのが一番速いでしょう．\\n\\n```\\nstack new projectname https://gitlab.com/snippets/1728485/raw\\n```\\n\\nということで結論\\n\\n1. プロジェクト生成： `stack new PROJECT https://gitlab.com/snippets/1728485/raw`\\n1. dockerで確認： `docker build -t PROJECT .`\\n1. herokuにログイン： `heroku container:login`\\n1. プッシュ: `heroku container:push web --app PROJECT`\\n1. 実行開始: `heroku container:release web --app PROJECT`\\n\\n## PostgreSQLにつないでみよう\\n\\nこのプログラムはPostgreSQLを使うために外部プログラムを呼び出していません。\\n対応するのは簡単で以下の通り：\\n\\n- Dockerのベースイメージを `nixos:2.0.4` に変更\\n- servantのプログラムはtutorialの[Cookbook PostgreSQL connection pool](http://haskell-servant.readthedocs.io/en/stable/cookbook/db-postgres-pool/PostgresPool.html)をそのまま流用\\n\\nあとはherokuでpostgreSQLを有効にすればOK。\\nDockerfileはこのようになりました。\\n\\n```\\nFROM nixos/nix:2.0.4\\nENV LANG C.UTF-8\\n\\nRUN nix-channel --update\\nRUN nix-env -u\\nRUN nix-env -f \\"<nixpkgs>\\" -iA haskell.compiler.ghc843\\nRUN nix-env -i stack\\n\\nWORKDIR /opt/PROJECT/src\\nENV PATH \\"/opt/PROJECT/bin:$PATH\\"\\n\\n# Build and install application binaries to /opt/PROJECT/bin.\\nCOPY *.yaml /opt/PROJECT/src/\\nRUN stack --no-terminal build --only-dependencies\\nCOPY . /opt/PROJECT/src\\nRUN stack --no-terminal --local-bin-path /opt/PROJECT/bin install\\n\\n# clean up and run\\nRUN rm -rf /opt/PROJECT/src\\nCMD /opt/PROJECT/bin/PROJECT\\n```","bodyHtml":"<p>stackのテンプレートを使って\\n<a href=\\"https://haskell.jp/blog/posts/2017/02-haskell-on-heroku.html\\">Dockerを使ってHaskellアプリをHerokuにデプロイする</a>\\nと同じことをやってみます．</p>\\n<h3>下準備（オプショナル）</h3>\\n<p>stackに警告を出されないように，~/.stack/config.yml に以下のような情報を追加しておくといいかも．</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-attr\\">templates:</span>\\n<span class=\\"hljs-attr\\">  params:</span>\\n<span class=\\"hljs-attr\\">    author-email:</span> <span class=\\"hljs-string\\">EMAIL</span>\\n<span class=\\"hljs-attr\\">    author-name:</span>  <span class=\\"hljs-string\\">NAME</span></code></pre><h3>プロジェクトの生成</h3>\\n<p>stackのテンプレート <code>servant-docker</code> を使ってプロジェクトの雛形を作らせます．</p>\\n<pre><code>stack new PROJECT [--bare] servant-docker [--solver SOLVER]\\n</code></pre>\\n<p>雛形なのでこれでデプロイまでできるはずなのですが，いくつか問題があるので修正します．</p>\\n<h3>heroku用にプログラムを変更</h3>\\n<p>まず，herokuの環境でlistenすべきポート番号は環境変数で取得しないといけないのでそれを反映させます：</p>\\n<pre><code class=\\"hljs\\">diff --git a/src/Lib.hs b/src/Lib.hs\\nindex 46ba8bc..c800dc5 100644\\n<span class=\\"hljs-comment\\">--- a/src/Lib.hs</span>\\n<span class=\\"hljs-comment\\">+++ b/src/Lib.hs</span>\\n@@ -10,6 +10,7 @@ import Data.Aeson.TH\\n import Network.Wai\\n import Network.Wai.Handler.Warp\\n import Servant\\n<span class=\\"hljs-addition\\">+import System.ReadEnvVar (readEnvDef)</span>\\n\\n data User = User\\n   { userId        :: Int\\n@@ -22,7 +23,10 @@ $(deriveJSON defaultOptions \'\'User)\\n type API = \\"users\\" :&gt; Get \'[JSON] [User]\\n\\n startApp :: IO ()\\n<span class=\\"hljs-deletion\\">-startApp = run 1234 app</span>\\n<span class=\\"hljs-addition\\">+startApp = do</span>\\n<span class=\\"hljs-addition\\">+  port &lt;- readEnvDef \\"PORT\\" 8080</span>\\n<span class=\\"hljs-addition\\">+  putStrLn $ \\";;; start server at \\" ++ show port</span>\\n<span class=\\"hljs-addition\\">+  run port app</span>\\n\\n app :: Application\\n app = serve api server</code></pre><p><a href=\\"https://github.com/cdepillabout/read-env-var\\">ReadEnvVar</a>パッケージを追加したのでcabalファイルにも追加：</p>\\n<pre><code class=\\"hljs\\">diff --git a/appname.cabal b/appname.cabal\\nindex b977aa5..e654f60 100644\\n<span class=\\"hljs-comment\\">--- a/PROJECT.cabal</span>\\n<span class=\\"hljs-comment\\">+++ b/PROJECT.cabal</span>\\n@@ -18,6 +18,7 @@ library\\n   exposed-modules:     Lib\\n   build-depends:       base &gt;= 4.7 &amp;&amp; &lt; 5\\n                      , aeson\\n<span class=\\"hljs-addition\\">+                     , read-env-var</span>\\n                      , servant-server\\n                      , wai\\n                      , warp</code></pre><h3>手動で確認</h3>\\n<p>ここでコンパイルしてエラーがないことを確認します．</p>\\n<pre><code class=\\"hljs\\">$ stack build</code></pre><p>動作確認は</p>\\n<pre><code class=\\"hljs\\">$ <span class=\\"hljs-built_in\\">export</span> PORT=8080; APP &amp;\\n$ wget http://localhost:8080/</code></pre><h3>Dockerイメージの作成</h3>\\n<p>まずdockerのイメージでプログラムが自動で実行されるようにDockerfile（ついでにstack.yml）を変更します．\\n．</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-comment\\">--- a/Dockerfile</span>\\n<span class=\\"hljs-comment\\">+++ b/Dockerfile</span>\\n<span class=\\"hljs-meta\\">@@ -9,3 +9,4 @@</span>\\n\\n COPY . /app/user\\n RUN stack install\\n<span class=\\"hljs-addition\\">+CMD APP.EXE</span></code></pre><pre><code class=\\"hljs\\">modified   stack.yaml\\n@@ -66,6 +66,15 @@ allow-newer: true\\n # Allow a newer minor version of GHC than the snapshot specifies\\n # compiler-check: newer-minor\\n\\n<span class=\\"hljs-addition\\">+image:</span>\\n<span class=\\"hljs-addition\\">+  containers:</span>\\n<span class=\\"hljs-addition\\">+    -</span>\\n<span class=\\"hljs-addition\\">+      base: \\"haskell:8.4.3\\"</span>\\n<span class=\\"hljs-addition\\">+      executables:</span>\\n<span class=\\"hljs-addition\\">+        - APP.EXE</span>\\n<span class=\\"hljs-addition\\">+      entrypoints:</span>\\n<span class=\\"hljs-addition\\">+        - APP.EXE</span></code></pre><p>以下を実行してイメージを作ります：</p>\\n<pre><code>docker build -t APPNAME .\\n</code></pre>\\n<p>動作確認は</p>\\n<pre><code class=\\"hljs\\">$ docker run -p 8080:8080 --publish-all APPNAME\\n$ wget http://localhost:8080/</code></pre><h3>herokuへのデプロイ</h3>\\n<h4>初期設定</h4>\\n<ol>\\n<li>アカウントを作る</li>\\n<li>heroku dashboardでアプリの登録</li>\\n</ol>\\n<pre><code class=\\"hljs\\">heroku login\\nheroku apps:create APPNAME</code></pre><h4>ビルドからデプロイ</h4>\\n<ol>\\n<li>ログインする</li>\\n<li>コンテナ環境での作業</li>\\n</ol>\\n<pre><code class=\\"hljs\\">$ heroku container:login\\n$ heroku container:push web [--app APPNAME]\\n$ heroku container:release web [--app APPNAME]</code></pre><h3>gitlab-ci.ymlに登録</h3>\\n<p>うまく行ったなら自動化させます．当然gitlab用に <code>.gitlab-ci.yml</code> を作成：</p>\\n<pre><code>build:\\n  stage: build\\n  script:\\n    - docker build -t APPNAME .\\n\\ndeploy heroku:\\n  stage: deploy\\n  script:\\n    - heroku container:login\\n    - heroku container:push web --app APPNAME\\n    - heroku container:release web --app APPNAME\\n</code></pre>\\n<p>（さらにherokuへのデプロイ用のキーを登録する必要があるかも）</p>\\n<p>That\'s it.</p>\\n<h2>だったらstack templateにしてしまおう</h2>\\n<p>ということで以上の変更をしたテンプレート https://gitlab.com/snippets/1728485/raw を作りました．\\nテンプレートはurl指定で使えるので，以下のようにするのが一番速いでしょう．</p>\\n<pre><code>stack new projectname https://gitlab.com/snippets/1728485/raw\\n</code></pre>\\n<p>ということで結論</p>\\n<ol>\\n<li>プロジェクト生成： <code>stack new PROJECT https://gitlab.com/snippets/1728485/raw</code></li>\\n<li>dockerで確認： <code>docker build -t PROJECT .</code></li>\\n<li>herokuにログイン： <code>heroku container:login</code></li>\\n<li>プッシュ: <code>heroku container:push web --app PROJECT</code></li>\\n<li>実行開始: <code>heroku container:release web --app PROJECT</code></li>\\n</ol>\\n<h2>PostgreSQLにつないでみよう</h2>\\n<p>このプログラムはPostgreSQLを使うために外部プログラムを呼び出していません。\\n対応するのは簡単で以下の通り：</p>\\n<ul>\\n<li>Dockerのベースイメージを <code>nixos:2.0.4</code> に変更</li>\\n<li>servantのプログラムはtutorialの<a href=\\"http://haskell-servant.readthedocs.io/en/stable/cookbook/db-postgres-pool/PostgresPool.html\\">Cookbook PostgreSQL connection pool</a>をそのまま流用</li>\\n</ul>\\n<p>あとはherokuでpostgreSQLを有効にすればOK。\\nDockerfileはこのようになりました。</p>\\n<pre><code>FROM nixos/nix:2.0.4\\nENV LANG C.UTF-8\\n\\nRUN nix-channel --update\\nRUN nix-env -u\\nRUN nix-env -f &quot;&lt;nixpkgs&gt;&quot; -iA haskell.compiler.ghc843\\nRUN nix-env -i stack\\n\\nWORKDIR /opt/PROJECT/src\\nENV PATH &quot;/opt/PROJECT/bin:$PATH&quot;\\n\\n# Build and install application binaries to /opt/PROJECT/bin.\\nCOPY *.yaml /opt/PROJECT/src/\\nRUN stack --no-terminal build --only-dependencies\\nCOPY . /opt/PROJECT/src\\nRUN stack --no-terminal --local-bin-path /opt/PROJECT/bin install\\n\\n# clean up and run\\nRUN rm -rf /opt/PROJECT/src\\nCMD /opt/PROJECT/bin/PROJECT\\n</code></pre>\\n","dir":"article/.json/2018","base":"2018-06-24-haskell-on-heroku.json","ext":".json","sourceBase":"2018-06-24-haskell-on-heroku.md","sourceExt":".md"}')}}]);