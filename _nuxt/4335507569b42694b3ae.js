(window.webpackJsonp=window.webpackJsonp||[]).push([[83],{555:function(n){n.exports=JSON.parse('{"title":"Vivification","subtitle":"a CNF preprocessor","date":"2020-06-20T00:00:00.000Z","tags":["SAT"],"bodyContent":"Vivification がなんなのか、日本語で探しても出てこないので以下をまとめる。\\n（最新の話かと思っていたけど2008年とは。。。）\\n\\n* C. Piette, Y. Hamadi, and L. Saïs, \\"Vivifying propositional clausal formulae,” *Front. Artif. Intell*. Appl., vol. 178, pp. 525–529, 2008.\\n\\nSplrでいうところの、現在のprocessorが網羅的に節数に対する制約内での全ての変数除去、節包摂(clause subsumption)を実行するのに対し、vivificationは（その節に「対応」する割り当てを仮定して）propagateを行った結果を用いて節の包摂方針を決めるというもの。\\nその分、不要な複雑さの導入を抑えることができるらしい。\\n\\n### アルゴリズム\\n\\n![](/img/2020/06-20/algorithm1.jpg)\\n\\n何も考えずにRustで書いてみるとこんな感じ。\\n\\n```rust\\n/// Vivification of a given CNF formula, returning a vivified CNF formula\\n/// ## Note\\n/// `remove` used here is a non-destructive function (`Fn<T>([T]) -> Vec<T>`).\\nfn vivify(mut sigma: &CNF) {\\n    let mut testing_cnf;\\n    let mut change: bool = true;\\n    let mut shortened: bool = true;\\n    let mut cb: Vec<Lit> = Vec::new();\\n    let mut ci: usize;\\n    while change {\\n        change = false;\\n        i = 0;\\n        while i < sigma.len() {\\n            let mut c = &mut sigma[i];\\n            let c_len = c.len();\\n            i += 1;\\n            testing_cnf = sigma.remove(c).clone();\\n            cb.clear();\\n            shortened = false;\\n            while !shortened && c != cb {\\n                let cx = c.remove_items(cb);\\n                l = select_literal(cx);\\n                cb.push(l);                                   // cb = cb ∪ {l};\\n                testing_cnf.push(vec![!l]);                   // Σb ← (Σb ∪ {¬l})\\n                if let Some(ls) == testing_cnf.propagate() {  // ⊥ ∈ UP(Σb)\\n                    let learnt = conflict_analyze();          // returns a learnt clause\\n                    if learnt.iter().all(|l| c.includes(l)) { // cl ⊂ c\\n                        sigma.new_clause(learnt);             // Σ ← Σ ∪ {cl}\\n                        shortened = true;\\n                    } else {\\n                        if learnt.len() == c_len {\\n                            sigma.new_clause(learnt);         // Σ ← Σ ∪ { cl }\\n                            cb = c;\\n                        }\\n                        if c != cb {\\n                            sigma.new_clause(cb);             // Σ ← Σ ∪ {cb}\\n                            shortened = true;\\n                        }\\n                    }\\n                } else {\\n                    if cx.includes(ls) {                      // ∃(ls ∈ (c\\\\cb))\\n                        if 1 < cx.len() {                     // (c\\\\cb) /= {ls}\\n                            sigma.new_clause(cb.push(ls));    // Σ ← Σ ∪ {cb ∪ {ls}} ;\\n                            shortened = true;\\n                        }\\n                    }\\n                    if cx.includes(!ls) {                     // ∃(¬ls ∈ (c\\\\cb))\\n                        sigma.new_clause(c.remove(ls));       // Σ ← Σ ∪ {c\\\\{ls}}\\n                        shortened = true;\\n                    }\\n                }\\n                if shortened {\\n                    sigma.remove(c);\\n                    change = true;\\n                }\\n            }\\n        }\\n    }\\n    // return sigma;\\n}\\n```\\n\\nつまり\\n\\n```rust\\nfn vivify(mut sigma: CNF) -> CNF {\\n    let mut testing_cnf;\\n    let mut change: bool = true;                            // 変化したかどうか\\n    let mut shortened: bool = true;                         // 節cを短い節で置き換えできたかどうか\\n    let mut cb: Vec<Lit> = Vec::new();                      // 節cの中で処理した部分\\n    while 不動点になるまで\\n        for sigma中の全ての節cに対して\\n            現在のsigmaのコピーをtesting_cnfとする\\n            sigmaからcを削除する\\n            cb.clear();\\n            shortened = false;\\n            while !shortened && c != cb                     // == until shorten || c == cb { .. }\\n                c\\\\cbから適当に選んだリテラルlを割り当ててみて伝播させる\\n                cbにlを追加する\\n                if 矛盾してないなら\\n                    その学習節をclとする\\n                    if 学習節clが元々の節cを包摂するなら\\n                        clをsigmaに追加; shortened = true;\\n                    else\\n                        if cとclが同じ長さなら\\n                            clをsigmaに追加; cb = c;        // これは終了条件, cは後でsigmaに追加される\\n                        if c != cb   　　　                 // ここがわからん\\n                            sigma.push(cb); shortened = true\\n                else\\n                    if cの残り(c.remove(cb))が ls を含むなら\\n                        if cの残りが単位節{ls}になっていたら\\n                            単位節{ls}を sigma に追加; shortened = true;\\n                    if cの残り(c.remove(cb))が !ls を含むなら\\n　　　　　　　　　　　     cからリテラルlsを除いてsigma に追加; shortened = true;\\n                if !shorted\\n                    sigma.push(c);\\n                else\\n                    change = true;\\n    return sigma;\\n}\\n```\\n\\nうーむ、実装してみなくては。","bodyHtml":"<p>Vivification がなんなのか、日本語で探しても出てこないので以下をまとめる。\\n（最新の話かと思っていたけど2008年とは。。。）</p>\\n<ul>\\n<li>C. Piette, Y. Hamadi, and L. Saïs, &quot;Vivifying propositional clausal formulae,” <em>Front. Artif. Intell</em>. Appl., vol. 178, pp. 525–529, 2008.</li>\\n</ul>\\n<p>Splrでいうところの、現在のprocessorが網羅的に節数に対する制約内での全ての変数除去、節包摂(clause subsumption)を実行するのに対し、vivificationは（その節に「対応」する割り当てを仮定して）propagateを行った結果を用いて節の包摂方針を決めるというもの。\\nその分、不要な複雑さの導入を抑えることができるらしい。</p>\\n<h3>アルゴリズム</h3>\\n<p><img src=\\"/img/2020/06-20/algorithm1.jpg\\" alt=\\"\\"></p>\\n<p>何も考えずにRustで書いてみるとこんな感じ。</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-comment\\">/// Vivification of a given CNF formula, returning a vivified CNF formula</span>\\n<span class=\\"hljs-comment\\">/// ## Note</span>\\n<span class=\\"hljs-comment\\">/// `remove` used here is a non-destructive function (`Fn&lt;T&gt;([T]) -&gt; Vec&lt;T&gt;`).</span>\\n<span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">fn</span> <span class=\\"hljs-title\\">vivify</span></span>(<span class=\\"hljs-keyword\\">mut</span> sigma: &amp;CNF) {\\n    <span class=\\"hljs-keyword\\">let</span> <span class=\\"hljs-keyword\\">mut</span> testing_cnf;\\n    <span class=\\"hljs-keyword\\">let</span> <span class=\\"hljs-keyword\\">mut</span> change: <span class=\\"hljs-built_in\\">bool</span> = <span class=\\"hljs-literal\\">true</span>;\\n    <span class=\\"hljs-keyword\\">let</span> <span class=\\"hljs-keyword\\">mut</span> shortened: <span class=\\"hljs-built_in\\">bool</span> = <span class=\\"hljs-literal\\">true</span>;\\n    <span class=\\"hljs-keyword\\">let</span> <span class=\\"hljs-keyword\\">mut</span> cb: <span class=\\"hljs-built_in\\">Vec</span>&lt;Lit&gt; = <span class=\\"hljs-built_in\\">Vec</span>::new();\\n    <span class=\\"hljs-keyword\\">let</span> <span class=\\"hljs-keyword\\">mut</span> ci: <span class=\\"hljs-built_in\\">usize</span>;\\n    <span class=\\"hljs-keyword\\">while</span> change {\\n        change = <span class=\\"hljs-literal\\">false</span>;\\n        i = <span class=\\"hljs-number\\">0</span>;\\n        <span class=\\"hljs-keyword\\">while</span> i &lt; sigma.len() {\\n            <span class=\\"hljs-keyword\\">let</span> <span class=\\"hljs-keyword\\">mut</span> c = &amp;<span class=\\"hljs-keyword\\">mut</span> sigma[i];\\n            <span class=\\"hljs-keyword\\">let</span> c_len = c.len();\\n            i += <span class=\\"hljs-number\\">1</span>;\\n            testing_cnf = sigma.remove(c).clone();\\n            cb.clear();\\n            shortened = <span class=\\"hljs-literal\\">false</span>;\\n            <span class=\\"hljs-keyword\\">while</span> !shortened &amp;&amp; c != cb {\\n                <span class=\\"hljs-keyword\\">let</span> cx = c.remove_items(cb);\\n                l = select_literal(cx);\\n                cb.push(l);                                   <span class=\\"hljs-comment\\">// cb = cb ∪ {l};</span>\\n                testing_cnf.push(<span class=\\"hljs-built_in\\">vec!</span>[!l]);                   <span class=\\"hljs-comment\\">// Σb ← (Σb ∪ {¬l})</span>\\n                <span class=\\"hljs-keyword\\">if</span> <span class=\\"hljs-keyword\\">let</span> <span class=\\"hljs-literal\\">Some</span>(ls) == testing_cnf.propagate() {  <span class=\\"hljs-comment\\">// ⊥ ∈ UP(Σb)</span>\\n                    <span class=\\"hljs-keyword\\">let</span> learnt = conflict_analyze();          <span class=\\"hljs-comment\\">// returns a learnt clause</span>\\n                    <span class=\\"hljs-keyword\\">if</span> learnt.iter().all(|l| c.includes(l)) { <span class=\\"hljs-comment\\">// cl ⊂ c</span>\\n                        sigma.new_clause(learnt);             <span class=\\"hljs-comment\\">// Σ ← Σ ∪ {cl}</span>\\n                        shortened = <span class=\\"hljs-literal\\">true</span>;\\n                    } <span class=\\"hljs-keyword\\">else</span> {\\n                        <span class=\\"hljs-keyword\\">if</span> learnt.len() == c_len {\\n                            sigma.new_clause(learnt);         <span class=\\"hljs-comment\\">// Σ ← Σ ∪ { cl }</span>\\n                            cb = c;\\n                        }\\n                        <span class=\\"hljs-keyword\\">if</span> c != cb {\\n                            sigma.new_clause(cb);             <span class=\\"hljs-comment\\">// Σ ← Σ ∪ {cb}</span>\\n                            shortened = <span class=\\"hljs-literal\\">true</span>;\\n                        }\\n                    }\\n                } <span class=\\"hljs-keyword\\">else</span> {\\n                    <span class=\\"hljs-keyword\\">if</span> cx.includes(ls) {                      <span class=\\"hljs-comment\\">// ∃(ls ∈ (c\\\\cb))</span>\\n                        <span class=\\"hljs-keyword\\">if</span> <span class=\\"hljs-number\\">1</span> &lt; cx.len() {                     <span class=\\"hljs-comment\\">// (c\\\\cb) /= {ls}</span>\\n                            sigma.new_clause(cb.push(ls));    <span class=\\"hljs-comment\\">// Σ ← Σ ∪ {cb ∪ {ls}} ;</span>\\n                            shortened = <span class=\\"hljs-literal\\">true</span>;\\n                        }\\n                    }\\n                    <span class=\\"hljs-keyword\\">if</span> cx.includes(!ls) {                     <span class=\\"hljs-comment\\">// ∃(¬ls ∈ (c\\\\cb))</span>\\n                        sigma.new_clause(c.remove(ls));       <span class=\\"hljs-comment\\">// Σ ← Σ ∪ {c\\\\{ls}}</span>\\n                        shortened = <span class=\\"hljs-literal\\">true</span>;\\n                    }\\n                }\\n                <span class=\\"hljs-keyword\\">if</span> shortened {\\n                    sigma.remove(c);\\n                    change = <span class=\\"hljs-literal\\">true</span>;\\n                }\\n            }\\n        }\\n    }\\n    <span class=\\"hljs-comment\\">// return sigma;</span>\\n}</code></pre><p>つまり</p>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">fn</span> <span class=\\"hljs-title\\">vivify</span></span>(<span class=\\"hljs-keyword\\">mut</span> sigma: CNF) -&gt; CNF {\\n    <span class=\\"hljs-keyword\\">let</span> <span class=\\"hljs-keyword\\">mut</span> testing_cnf;\\n    <span class=\\"hljs-keyword\\">let</span> <span class=\\"hljs-keyword\\">mut</span> change: <span class=\\"hljs-built_in\\">bool</span> = <span class=\\"hljs-literal\\">true</span>;                            <span class=\\"hljs-comment\\">// 変化したかどうか</span>\\n    <span class=\\"hljs-keyword\\">let</span> <span class=\\"hljs-keyword\\">mut</span> shortened: <span class=\\"hljs-built_in\\">bool</span> = <span class=\\"hljs-literal\\">true</span>;                         <span class=\\"hljs-comment\\">// 節cを短い節で置き換えできたかどうか</span>\\n    <span class=\\"hljs-keyword\\">let</span> <span class=\\"hljs-keyword\\">mut</span> cb: <span class=\\"hljs-built_in\\">Vec</span>&lt;Lit&gt; = <span class=\\"hljs-built_in\\">Vec</span>::new();                      <span class=\\"hljs-comment\\">// 節cの中で処理した部分</span>\\n    <span class=\\"hljs-keyword\\">while</span> 不動点になるまで\\n        <span class=\\"hljs-keyword\\">for</span> sigma中の全ての節cに対して\\n            現在のsigmaのコピーをtesting_cnfとする\\n            sigmaからcを削除する\\n            cb.clear();\\n            shortened = <span class=\\"hljs-literal\\">false</span>;\\n            <span class=\\"hljs-keyword\\">while</span> !shortened &amp;&amp; c != cb                     <span class=\\"hljs-comment\\">// == until shorten || c == cb { .. }</span>\\n                c\\\\cbから適当に選んだリテラルlを割り当ててみて伝播させる\\n                cbにlを追加する\\n                <span class=\\"hljs-keyword\\">if</span> 矛盾してないなら\\n                    その学習節をclとする\\n                    <span class=\\"hljs-keyword\\">if</span> 学習節clが元々の節cを包摂するなら\\n                        clをsigmaに追加; shortened = <span class=\\"hljs-literal\\">true</span>;\\n                    <span class=\\"hljs-keyword\\">else</span>\\n                        <span class=\\"hljs-keyword\\">if</span> cとclが同じ長さなら\\n                            clをsigmaに追加; cb = c;        <span class=\\"hljs-comment\\">// これは終了条件, cは後でsigmaに追加される</span>\\n                        <span class=\\"hljs-keyword\\">if</span> c != cb   　　　                 <span class=\\"hljs-comment\\">// ここがわからん</span>\\n                            sigma.push(cb); shortened = <span class=\\"hljs-literal\\">true</span>\\n                <span class=\\"hljs-keyword\\">else</span>\\n                    <span class=\\"hljs-keyword\\">if</span> cの残り(c.remove(cb))が ls を含むなら\\n                        <span class=\\"hljs-keyword\\">if</span> cの残りが単位節{ls}になっていたら\\n                            単位節{ls}を sigma に追加; shortened = <span class=\\"hljs-literal\\">true</span>;\\n                    <span class=\\"hljs-keyword\\">if</span> cの残り(c.remove(cb))が !ls を含むなら\\n　　　　　　　　　　　     cからリテラルlsを除いてsigma に追加; shortened = <span class=\\"hljs-literal\\">true</span>;\\n                <span class=\\"hljs-keyword\\">if</span> !shorted\\n                    sigma.push(c);\\n                <span class=\\"hljs-keyword\\">else</span>\\n                    change = <span class=\\"hljs-literal\\">true</span>;\\n    <span class=\\"hljs-keyword\\">return</span> sigma;\\n}</code></pre><p>うーむ、実装してみなくては。</p>\\n","dir":"article/.json/2020","base":"2020-06-20-vivification.json","ext":".json","sourceBase":"2020-06-20-vivification.md","sourceExt":".md"}')}}]);